/**
 * Flipdish Open API v1.0
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://api.flipdish.co';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

/**
* Accept
*/
export class Accept {
    /**
    * Estimated minutes for delivery
    */
    'EstimatedMinutesForDelivery'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EstimatedMinutesForDelivery",
            "baseName": "EstimatedMinutesForDelivery",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Accept.attributeTypeMap;
    }
}

/**
* Account details
*/
export class AccountDetail {
    /**
    * Email
    */
    'Email'?: string;
    /**
    * Signup steps
    */
    'SignupSteps'?: Array<SignupStep>;
    /**
    * Is account email verified
    */
    'IsVerified'?: boolean;
    /**
    * is the account a Self Server
    */
    'IsSelfServeUser'?: boolean;
    /**
    * Accounts Id
    */
    'AccountId'?: number;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Language Id
    */
    'Language'?: string;
    /**
    * Time Zone Info Id
    */
    'TimeZoneInfoId'?: string;
    /**
    * Display the time in time zone local to the user
    */
    'DisplayTimesInUserLocalTimeZone'?: boolean;
    /**
    * Show hidden features
    */
    'ShowHiddenFeatures'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "SignupSteps",
            "baseName": "SignupSteps",
            "type": "Array<SignupStep>"
        },
        {
            "name": "IsVerified",
            "baseName": "IsVerified",
            "type": "boolean"
        },
        {
            "name": "IsSelfServeUser",
            "baseName": "IsSelfServeUser",
            "type": "boolean"
        },
        {
            "name": "AccountId",
            "baseName": "AccountId",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Language",
            "baseName": "Language",
            "type": "string"
        },
        {
            "name": "TimeZoneInfoId",
            "baseName": "TimeZoneInfoId",
            "type": "string"
        },
        {
            "name": "DisplayTimesInUserLocalTimeZone",
            "baseName": "DisplayTimesInUserLocalTimeZone",
            "type": "boolean"
        },
        {
            "name": "ShowHiddenFeatures",
            "baseName": "ShowHiddenFeatures",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return AccountDetail.attributeTypeMap;
    }
}

/**
* Account Details Base
*/
export class AccountDetailBase {
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Language Id
    */
    'Language'?: string;
    /**
    * Time Zone Info Id
    */
    'TimeZoneInfoId'?: string;
    /**
    * Display the time in time zone local to the user
    */
    'DisplayTimesInUserLocalTimeZone'?: boolean;
    /**
    * Show hidden features
    */
    'ShowHiddenFeatures'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Language",
            "baseName": "Language",
            "type": "string"
        },
        {
            "name": "TimeZoneInfoId",
            "baseName": "TimeZoneInfoId",
            "type": "string"
        },
        {
            "name": "DisplayTimesInUserLocalTimeZone",
            "baseName": "DisplayTimesInUserLocalTimeZone",
            "type": "boolean"
        },
        {
            "name": "ShowHiddenFeatures",
            "baseName": "ShowHiddenFeatures",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return AccountDetailBase.attributeTypeMap;
    }
}

/**
* Represents the format of a bank account field
*/
export class AccountFieldDefinition {
    /**
    * Depending on the Key, the field's value will be stored in a different field in PayeeBankAccountData
    */
    'Key'?: AccountFieldDefinition.KeyEnum;
    /**
    * Display name of the field
    */
    'DisplayName'?: string;
    /**
    * There are some fields that are of type known to the frontend (IBAN, Swift) -- for those frontend should use its own validation library, e.g. ibantools
    */
    'Type'?: AccountFieldDefinition.TypeEnum;
    /**
    * Minimum length of the field
    */
    'MinLength'?: number;
    /**
    * Maximum length of the field
    */
    'MaxLength'?: number;
    /**
    * Is the field digits (numeric) only
    */
    'DigitsOnly'?: boolean;
    /**
    * Regex for validating the field (if specified)
    */
    'Regex'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Key",
            "baseName": "Key",
            "type": "AccountFieldDefinition.KeyEnum"
        },
        {
            "name": "DisplayName",
            "baseName": "DisplayName",
            "type": "string"
        },
        {
            "name": "Type",
            "baseName": "Type",
            "type": "AccountFieldDefinition.TypeEnum"
        },
        {
            "name": "MinLength",
            "baseName": "MinLength",
            "type": "number"
        },
        {
            "name": "MaxLength",
            "baseName": "MaxLength",
            "type": "number"
        },
        {
            "name": "DigitsOnly",
            "baseName": "DigitsOnly",
            "type": "boolean"
        },
        {
            "name": "Regex",
            "baseName": "Regex",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AccountFieldDefinition.attributeTypeMap;
    }
}

export namespace AccountFieldDefinition {
    export enum KeyEnum {
        Iban = <any> 'Iban',
        AccountNumber = <any> 'AccountNumber',
        RoutingNumber = <any> 'RoutingNumber',
        BSB = <any> 'BSB',
        BranchCode = <any> 'BranchCode',
        BankCode = <any> 'BankCode',
        InstitutionNumber = <any> 'InstitutionNumber',
        TransitNumber = <any> 'TransitNumber',
        ClearingCode = <any> 'ClearingCode',
        IfscCode = <any> 'IfscCode',
        Clabe = <any> 'Clabe',
        SortCode = <any> 'SortCode',
        Swift = <any> 'Swift'
    }
    export enum TypeEnum {
        None = <any> 'None',
        Iban = <any> 'Iban'
    }
}
/**
* Represents one populated account field (its key and value)
*/
export class AccountFieldKeyValuePair {
    /**
    * Depending on the Key, the field's value will be stored in a different field in PayeeBankAccountData
    */
    'Key'?: AccountFieldKeyValuePair.KeyEnum;
    /**
    * The value of the field
    */
    'Value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Key",
            "baseName": "Key",
            "type": "AccountFieldKeyValuePair.KeyEnum"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AccountFieldKeyValuePair.attributeTypeMap;
    }
}

export namespace AccountFieldKeyValuePair {
    export enum KeyEnum {
        Iban = <any> 'Iban',
        AccountNumber = <any> 'AccountNumber',
        RoutingNumber = <any> 'RoutingNumber',
        BSB = <any> 'BSB',
        BranchCode = <any> 'BranchCode',
        BankCode = <any> 'BankCode',
        InstitutionNumber = <any> 'InstitutionNumber',
        TransitNumber = <any> 'TransitNumber',
        ClearingCode = <any> 'ClearingCode',
        IfscCode = <any> 'IfscCode',
        Clabe = <any> 'Clabe',
        SortCode = <any> 'SortCode',
        Swift = <any> 'Swift'
    }
}
/**
* List of field definitions per country
*/
export class AccountFieldsDefinitions {
    /**
    * List of field definitions per country
    */
    'DefinitionsPerCountry'?: { [key: string]: Array<AccountFieldDefinition>; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DefinitionsPerCountry",
            "baseName": "DefinitionsPerCountry",
            "type": "{ [key: string]: Array<AccountFieldDefinition>; }"
        }    ];

    static getAttributeTypeMap() {
        return AccountFieldsDefinitions.attributeTypeMap;
    }
}

export class AddressFormDisplayFormat {
    'OneLine'?: string;
    'TwoLines'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OneLine",
            "baseName": "OneLine",
            "type": "string"
        },
        {
            "name": "TwoLines",
            "baseName": "TwoLines",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return AddressFormDisplayFormat.attributeTypeMap;
    }
}

/**
* A response of a dyanmic form definition.
*/
export class AddressFormResponse {
    /**
    * List of field definitions.
    */
    'FormData'?: Array<DynamicFormField>;
    /**
    * ISO two letter code.
    */
    'CountryCode'?: string;
    /**
    * ISO culture code.
    */
    'Language'?: string;
    /**
    * Templates used to format form fields when displaying items in a list.
    */
    'DisplayFormat'?: AddressFormDisplayFormat;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "FormData",
            "baseName": "FormData",
            "type": "Array<DynamicFormField>"
        },
        {
            "name": "CountryCode",
            "baseName": "CountryCode",
            "type": "string"
        },
        {
            "name": "Language",
            "baseName": "Language",
            "type": "string"
        },
        {
            "name": "DisplayFormat",
            "baseName": "DisplayFormat",
            "type": "AddressFormDisplayFormat"
        }    ];

    static getAttributeTypeMap() {
        return AddressFormResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class AllMetadataResult {
    /**
    * Menu item metadata
    */
    'MenuItemMetadata'?: Array<Metadata>;
    /**
    * Menu item optionset item metadata
    */
    'MenuItemOptionSetItemMetadata'?: Array<Metadata>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuItemMetadata",
            "baseName": "MenuItemMetadata",
            "type": "Array<Metadata>"
        },
        {
            "name": "MenuItemOptionSetItemMetadata",
            "baseName": "MenuItemOptionSetItemMetadata",
            "type": "Array<Metadata>"
        }    ];

    static getAttributeTypeMap() {
        return AllMetadataResult.attributeTypeMap;
    }
}

export class Allergen {
    /**
    * A unique identifier for the allergen
    */
    'AllergenId'?: string;
    /**
    * Localized name of the allergen
    */
    'LocalizedName'?: string;
    /**
    * Url to the icon for the allergen
    */
    'IconUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AllergenId",
            "baseName": "AllergenId",
            "type": "string"
        },
        {
            "name": "LocalizedName",
            "baseName": "LocalizedName",
            "type": "string"
        },
        {
            "name": "IconUrl",
            "baseName": "IconUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Allergen.attributeTypeMap;
    }
}

/**
* Client Analytics event
*/
export class AnalyticsClientEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Type of the event
    */
    'EventType'?: string;
    /**
    * Type of the app the event is coming from
    */
    'AppType'?: string;
    /**
    * JSON Metadata
    */
    'Metadata'?: string;
    /**
    * User Id
    */
    'UserId'?: number;
    /**
    * Latitude of the event
    */
    'Latitude'?: number;
    /**
    * Longitude of the event
    */
    'Longitude'?: number;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "EventType",
            "baseName": "EventType",
            "type": "string"
        },
        {
            "name": "AppType",
            "baseName": "AppType",
            "type": "string"
        },
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "string"
        },
        {
            "name": "UserId",
            "baseName": "UserId",
            "type": "number"
        },
        {
            "name": "Latitude",
            "baseName": "Latitude",
            "type": "number"
        },
        {
            "name": "Longitude",
            "baseName": "Longitude",
            "type": "number"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AnalyticsClientEvent.attributeTypeMap;
    }
}

/**
* A single data point in timeline graphs related to APM
*/
export class ApmCurrencyDataPoint {
    /**
    * Date from which the data point starts
    */
    'PeriodStart'?: Date;
    /**
    * The length in days that this data point covers
    */
    'PeriodLengthInDays'?: number;
    /**
    * The values of this data point
    */
    'CurrencyData'?: Array<CurrencyData>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PeriodStart",
            "baseName": "PeriodStart",
            "type": "Date"
        },
        {
            "name": "PeriodLengthInDays",
            "baseName": "PeriodLengthInDays",
            "type": "number"
        },
        {
            "name": "CurrencyData",
            "baseName": "CurrencyData",
            "type": "Array<CurrencyData>"
        }    ];

    static getAttributeTypeMap() {
        return ApmCurrencyDataPoint.attributeTypeMap;
    }
}

/**
* A single data point in timeline graphs related to APM
*/
export class ApmDataPoint {
    /**
    * Date from which the data point starts
    */
    'PeriodStart'?: Date;
    /**
    * The length in days that this data point covers
    */
    'PeriodLengthInDays'?: number;
    /**
    * The value of this data point
    */
    'Value'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PeriodStart",
            "baseName": "PeriodStart",
            "type": "Date"
        },
        {
            "name": "PeriodLengthInDays",
            "baseName": "PeriodLengthInDays",
            "type": "number"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApmDataPoint.attributeTypeMap;
    }
}

/**
* Provides an average value for a single hour of day of the week
*/
export class ApmHourlyDataPoint {
    /**
    * Day of the week
    */
    'Day'?: ApmHourlyDataPoint.DayEnum;
    /**
    * Hour in the day
    */
    'Hour'?: number;
    /**
    * Total Value
    */
    'TotalValue'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Day",
            "baseName": "Day",
            "type": "ApmHourlyDataPoint.DayEnum"
        },
        {
            "name": "Hour",
            "baseName": "Hour",
            "type": "number"
        },
        {
            "name": "TotalValue",
            "baseName": "TotalValue",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApmHourlyDataPoint.attributeTypeMap;
    }
}

export namespace ApmHourlyDataPoint {
    export enum DayEnum {
        Sunday = <any> 'Sunday',
        Monday = <any> 'Monday',
        Tuesday = <any> 'Tuesday',
        Wednesday = <any> 'Wednesday',
        Thursday = <any> 'Thursday',
        Friday = <any> 'Friday',
        Saturday = <any> 'Saturday'
    }
}
/**
* APM Statistics
*/
export class ApmStatistics {
    /**
    * Total amount of time spent with APM
    */
    'EstimatedMinutesSaved'?: number;
    /**
    * Total amount of time that could be saved
    */
    'EstimatedMinutesCouldSaved'?: number;
    /**
    * Currency based data
    */
    'CurrencyData'?: Array<StatisticsCurrencyDataPoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EstimatedMinutesSaved",
            "baseName": "EstimatedMinutesSaved",
            "type": "number"
        },
        {
            "name": "EstimatedMinutesCouldSaved",
            "baseName": "EstimatedMinutesCouldSaved",
            "type": "number"
        },
        {
            "name": "CurrencyData",
            "baseName": "CurrencyData",
            "type": "Array<StatisticsCurrencyDataPoint>"
        }    ];

    static getAttributeTypeMap() {
        return ApmStatistics.attributeTypeMap;
    }
}

/**
* APM status
*/
export class ApmStatus {
    /**
    * Indicates if APM is active or otherwise
    */
    'IsApmEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IsApmEnabled",
            "baseName": "IsApmEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ApmStatus.attributeTypeMap;
    }
}

/**
* App
*/
export class App {
    /**
    * App Identifier
    */
    'AppId'?: string;
    /**
    * Has iOS app in Apple App Store. This is readonly.
    */
    'HasIosApp'?: boolean;
    /**
    * Has Android app in Google Play Store. This is readonly.
    */
    'HasAndroidApp'?: boolean;
    /**
    * Country identifier in ISO 3166-1 alpha-2 format.   This code is set automatically based on the locations of the Stores in the App.     The App Country is used    - to determine how to parse mobile phone numbers that are entered in their local numbering format   - to determine if country specific payment methods should be offered   - in various fraud checks
    */
    'CountryId'?: string;
    /**
    * Application Logo.
    */
    'LogoImageUrl'?: string;
    /**
    * Languages that have been selected to be available to customers.
    */
    'Languages'?: Array<Language>;
    /**
    * Lists all languages that are supported by Flipdish.
    */
    'AvailableAppLanguages'?: Array<Language>;
    /**
    * App access level for the logged in user
    */
    'AppAccessLevel'?: App.AppAccessLevelEnum;
    /**
    * Constitutes a list of available resources
    */
    'AppResourceSet'?: Array<App.AppResourceSetEnum>;
    /**
    * Feature flags. These cannot be set by 3rd parties.
    */
    'Features'?: Array<string>;
    /**
    * Center of the map coordinates. This is used to center the map when the iOS and Android app first open.  This value is automatically set based on the locations of the Stores in the App.
    */
    'MapCenter'?: Coordinates;
    /**
    * North East(Top Right) Corner of the map coordinates. This is used to frame the map when the iOS and Android app first open.  This value is automatically set based on the locations of the Stores in the App.
    */
    'MapNorthEast'?: Coordinates;
    /**
    * South West (Bottom Left) Corner of the map coordinates. This is used to frame the map when the iOS and Android app first open.  This value is automatically set based on the locations of the Stores in the App.
    */
    'MapSouthWest'?: Coordinates;
    /**
    * Key to be passed with Google Maps requests
    */
    'GoogleMapsApiKeyWeb'?: string;
    /**
    * App name.   This is used in various places on the Apple App Store, Google Play Store, mobile apps and websites.
    */
    'Name'?: string;
    /**
    * HostName on which the web-ordering system is allowed to be hosted or that a Flipdish website is hosted on.
    */
    'HostName'?: string;
    /**
    * Main color of the web / Android / iOS applications
    */
    'MainColor'?: string;
    /**
    * Primary colour used on the Kiosk
    */
    'KioskPrimaryColour'?: string;
    /**
    * Application Category
    */
    'ApplicationCategory'?: App.ApplicationCategoryEnum;
    /**
    * Panacea is the term used for websites that are hosted on the my.flipdish.com domain. This value is true when the App's website is hosted on this domain.  The aternative to using Panacea websites is to use a custom domain.
    */
    'IsPanaceaEnabled'?: boolean;
    /**
    * In case of IsPanaceaEnabled is true, the app can be accessed via https://my.flipdish.com/{PanaceaVanityUrl}
    */
    'PanaceaVanityUrl'?: string;
    /**
    * Cookie Consent Prompt Enabled
    */
    'CookieConsentPromptEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "HasIosApp",
            "baseName": "HasIosApp",
            "type": "boolean"
        },
        {
            "name": "HasAndroidApp",
            "baseName": "HasAndroidApp",
            "type": "boolean"
        },
        {
            "name": "CountryId",
            "baseName": "CountryId",
            "type": "string"
        },
        {
            "name": "LogoImageUrl",
            "baseName": "LogoImageUrl",
            "type": "string"
        },
        {
            "name": "Languages",
            "baseName": "Languages",
            "type": "Array<Language>"
        },
        {
            "name": "AvailableAppLanguages",
            "baseName": "AvailableAppLanguages",
            "type": "Array<Language>"
        },
        {
            "name": "AppAccessLevel",
            "baseName": "AppAccessLevel",
            "type": "App.AppAccessLevelEnum"
        },
        {
            "name": "AppResourceSet",
            "baseName": "AppResourceSet",
            "type": "Array<App.AppResourceSetEnum>"
        },
        {
            "name": "Features",
            "baseName": "Features",
            "type": "Array<string>"
        },
        {
            "name": "MapCenter",
            "baseName": "MapCenter",
            "type": "Coordinates"
        },
        {
            "name": "MapNorthEast",
            "baseName": "MapNorthEast",
            "type": "Coordinates"
        },
        {
            "name": "MapSouthWest",
            "baseName": "MapSouthWest",
            "type": "Coordinates"
        },
        {
            "name": "GoogleMapsApiKeyWeb",
            "baseName": "GoogleMapsApiKeyWeb",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "HostName",
            "baseName": "HostName",
            "type": "string"
        },
        {
            "name": "MainColor",
            "baseName": "MainColor",
            "type": "string"
        },
        {
            "name": "KioskPrimaryColour",
            "baseName": "KioskPrimaryColour",
            "type": "string"
        },
        {
            "name": "ApplicationCategory",
            "baseName": "ApplicationCategory",
            "type": "App.ApplicationCategoryEnum"
        },
        {
            "name": "IsPanaceaEnabled",
            "baseName": "IsPanaceaEnabled",
            "type": "boolean"
        },
        {
            "name": "PanaceaVanityUrl",
            "baseName": "PanaceaVanityUrl",
            "type": "string"
        },
        {
            "name": "CookieConsentPromptEnabled",
            "baseName": "CookieConsentPromptEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return App.attributeTypeMap;
    }
}

export namespace App {
    export enum AppAccessLevelEnum {
        None = <any> 'None',
        Owner = <any> 'Owner',
        StoreOwner = <any> 'StoreOwner',
        ManagedOwner = <any> 'ManagedOwner',
        Integrator = <any> 'Integrator',
        StoreManager = <any> 'StoreManager',
        StoreStaff = <any> 'StoreStaff',
        StoreReadOnlyAccess = <any> 'StoreReadOnlyAccess',
        FinanceManger = <any> 'FinanceManger',
        Onboarding = <any> 'Onboarding',
        Support = <any> 'Support'
    }
    export enum AppResourceSetEnum {
        ViewApp = <any> 'ViewApp',
        CreateApp = <any> 'CreateApp',
        UpdateApp = <any> 'UpdateApp',
        EditAppAssets = <any> 'EditAppAssets',
        EditAppFeatures = <any> 'EditAppFeatures',
        ViewTeammates = <any> 'ViewTeammates',
        EditTeammates = <any> 'EditTeammates',
        CreateTeammateOwner = <any> 'CreateTeammateOwner',
        CreateTeammateManagedOwner = <any> 'CreateTeammateManagedOwner',
        CreateTeammateStoreOwner = <any> 'CreateTeammateStoreOwner',
        CreateTeammateStoreManager = <any> 'CreateTeammateStoreManager',
        CreateTeammateStoreStaff = <any> 'CreateTeammateStoreStaff',
        CreateTeammateStoreReadAccess = <any> 'CreateTeammateStoreReadAccess',
        CreateTeammateFinanceManager = <any> 'CreateTeammateFinanceManager',
        CreateTeammateIntegrator = <any> 'CreateTeammateIntegrator',
        CreateTeammateOnboarding = <any> 'CreateTeammateOnboarding',
        ViewApmConfigurations = <any> 'ViewApmConfigurations',
        EditApmConfigurations = <any> 'EditApmConfigurations',
        ViewCampaignsConfigurations = <any> 'ViewCampaignsConfigurations',
        CreateCampaignsConfigurations = <any> 'CreateCampaignsConfigurations',
        UpdateCampaignsConfigurations = <any> 'UpdateCampaignsConfigurations',
        DeleteCampaignsConfigurations = <any> 'DeleteCampaignsConfigurations',
        StampLoyaltyCardAgainstCampaignsConfigurations = <any> 'StampLoyaltyCardAgainstCampaignsConfigurations',
        ViewDevelopersSettings = <any> 'ViewDevelopersSettings',
        EditDevelopersSettings = <any> 'EditDevelopersSettings',
        ViewOrders = <any> 'ViewOrders',
        UpdateOrdersAccept = <any> 'UpdateOrdersAccept',
        UpdateOrdersReject = <any> 'UpdateOrdersReject',
        UpdateOrdersRefund = <any> 'UpdateOrdersRefund',
        UpdateOrdersDispatch = <any> 'UpdateOrdersDispatch',
        ViewStores = <any> 'ViewStores',
        CreateStores = <any> 'CreateStores',
        EditStores = <any> 'EditStores',
        ViewStoresOpeningHours = <any> 'ViewStoresOpeningHours',
        UpdateStoresOpenForCollectionOrDelivery = <any> 'UpdateStoresOpenForCollectionOrDelivery',
        UpdateStoresOpeningHours = <any> 'UpdateStoresOpeningHours',
        ViewStoresOpeningHoursOverride = <any> 'ViewStoresOpeningHoursOverride',
        EditStoresOpeningHoursOverride = <any> 'EditStoresOpeningHoursOverride',
        EditStoresOpeningHoursOverrideTemporary = <any> 'EditStoresOpeningHoursOverrideTemporary',
        UpdateStoresName = <any> 'UpdateStoresName',
        EditStoreKioskSettings = <any> 'EditStoreKioskSettings',
        EditStoreOrderCapacity = <any> 'EditStoreOrderCapacity',
        UpdatePrinterTerminalsAssign = <any> 'UpdatePrinterTerminalsAssign',
        UpdatePrinterTerminalsToggle = <any> 'UpdatePrinterTerminalsToggle',
        EditStoreNotifications = <any> 'EditStoreNotifications',
        ViewStoreGroups = <any> 'ViewStoreGroups',
        CreateStoreGroups = <any> 'CreateStoreGroups',
        UpdateStoreGroups = <any> 'UpdateStoreGroups',
        DeleteStoreGroups = <any> 'DeleteStoreGroups',
        ViewDeliveryZones = <any> 'ViewDeliveryZones',
        CreateDeliveryZones = <any> 'CreateDeliveryZones',
        UpdateDeliveryZones = <any> 'UpdateDeliveryZones',
        DeleteDeliveryZones = <any> 'DeleteDeliveryZones',
        ViewMenu = <any> 'ViewMenu',
        CreateMenu = <any> 'CreateMenu',
        UpdateMenu = <any> 'UpdateMenu',
        DeleteMenu = <any> 'DeleteMenu',
        UpdateMenuLock = <any> 'UpdateMenuLock',
        UpdateMenuItemsHideTemporarily = <any> 'UpdateMenuItemsHideTemporarily',
        EditMenuImage = <any> 'EditMenuImage',
        ViewVouchers = <any> 'ViewVouchers',
        EditVouchers = <any> 'EditVouchers',
        ViewWebsiteContent = <any> 'ViewWebsiteContent',
        EditWebsiteContent = <any> 'EditWebsiteContent',
        ViewWebsiteDnsVerified = <any> 'ViewWebsiteDnsVerified',
        ViewWebsiteCertificateCreated = <any> 'ViewWebsiteCertificateCreated',
        ViewWebsiteCertificateRenewed = <any> 'ViewWebsiteCertificateRenewed',
        ViewBankAccounts = <any> 'ViewBankAccounts',
        CreateBankAccounts = <any> 'CreateBankAccounts',
        UpdateBankAccounts = <any> 'UpdateBankAccounts',
        UpdateBankAccountsAssign = <any> 'UpdateBankAccountsAssign',
        ViewAssignedBankAccount = <any> 'ViewAssignedBankAccount',
        VerifyBankAccounts = <any> 'VerifyBankAccounts',
        ViewServiceChargeConfigurations = <any> 'ViewServiceChargeConfigurations',
        EditServiceChargeConfigurations = <any> 'EditServiceChargeConfigurations',
        EditStoreDeliveryZoneFees = <any> 'EditStoreDeliveryZoneFees',
        ViewHydraConfig = <any> 'ViewHydraConfig',
        UpdateHydraConfigManage = <any> 'UpdateHydraConfigManage',
        InitiateBluetoothPairingMode = <any> 'InitiateBluetoothPairingMode',
        DeleteTerminal = <any> 'DeleteTerminal',
        ViewKioskTelemetry = <any> 'ViewKioskTelemetry',
        ViewCustomers = <any> 'ViewCustomers',
        EditCustomers = <any> 'EditCustomers',
        CreateCustomers = <any> 'CreateCustomers',
        CreateCatalogElements = <any> 'CreateCatalogElements',
        UpdateCatalogElements = <any> 'UpdateCatalogElements',
        ViewCatalogElements = <any> 'ViewCatalogElements',
        DeleteCatalogElements = <any> 'DeleteCatalogElements',
        ViewMetafieldDefinitions = <any> 'ViewMetafieldDefinitions',
        CreateMetafieldDefinitions = <any> 'CreateMetafieldDefinitions',
        UpdateMetafieldDefinitions = <any> 'UpdateMetafieldDefinitions',
        DeleteMetafieldDefinitions = <any> 'DeleteMetafieldDefinitions',
        UpdateMetafields = <any> 'UpdateMetafields',
        ViewCatalogMenuChanges = <any> 'ViewCatalogMenuChanges',
        PublishCatalogMenuChanges = <any> 'PublishCatalogMenuChanges',
        ViewAppStatistics = <any> 'ViewAppStatistics',
        ViewApmStatistics = <any> 'ViewApmStatistics',
        ViewCampaignsStatistics = <any> 'ViewCampaignsStatistics',
        ViewCustomerStatistics = <any> 'ViewCustomerStatistics',
        ViewLiveStatistics = <any> 'ViewLiveStatistics',
        ViewOrderStatistics = <any> 'ViewOrderStatistics',
        ViewSalesStatistics = <any> 'ViewSalesStatistics',
        ViewSalesEndOfDayStatistics = <any> 'ViewSalesEndOfDayStatistics',
        ViewVouchersStatistics = <any> 'ViewVouchersStatistics',
        DownloadCustomerCsvExport = <any> 'DownloadCustomerCsvExport',
        ViewApmAuditLogs = <any> 'ViewApmAuditLogs',
        ViewStoreAuditLogs = <any> 'ViewStoreAuditLogs',
        ViewMenuAuditLogs = <any> 'ViewMenuAuditLogs',
        ViewBankAccountAuditLogs = <any> 'ViewBankAccountAuditLogs',
        ViewFeeConfigurationsAuditLogs = <any> 'ViewFeeConfigurationsAuditLogs',
        ViewOrdersAuditLogs = <any> 'ViewOrdersAuditLogs',
        ViewVouchersAuditLogs = <any> 'ViewVouchersAuditLogs',
        ViewUserEventsAuditLogs = <any> 'ViewUserEventsAuditLogs',
        ViewCampaignsAuditLogs = <any> 'ViewCampaignsAuditLogs',
        ViewTeammatesAuditLogs = <any> 'ViewTeammatesAuditLogs',
        ViewAppAuditLogs = <any> 'ViewAppAuditLogs',
        ViewCustomerAuditLogs = <any> 'ViewCustomerAuditLogs',
        ViewPrinterAuditLogs = <any> 'ViewPrinterAuditLogs',
        ViewHydraAuditLogs = <any> 'ViewHydraAuditLogs',
        ViewPushNotificationAuditLogs = <any> 'ViewPushNotificationAuditLogs',
        ViewStripeCustomConnectedAccountAuditLogs = <any> 'ViewStripeCustomConnectedAccountAuditLogs',
        ViewKioskBluetoothDeviceAuditLogs = <any> 'ViewKioskBluetoothDeviceAuditLogs',
        ViewExternalAuditLogs = <any> 'ViewExternalAuditLogs',
        CreateExternalAuditLogEvents = <any> 'CreateExternalAuditLogEvents',
        ViewCatalogAuditLogs = <any> 'ViewCatalogAuditLogs',
        ViewOrderFulfillmentAuditLogs = <any> 'ViewOrderFulfillmentAuditLogs',
        ViewChannelAuditLogs = <any> 'ViewChannelAuditLogs',
        SendPushNotificationToCustomer = <any> 'SendPushNotificationToCustomer',
        InviteDriverToApp = <any> 'InviteDriverToApp',
        GetDriverForApp = <any> 'GetDriverForApp',
        RemoveDriverFromApp = <any> 'RemoveDriverFromApp',
        AssignDriverToOrder = <any> 'AssignDriverToOrder',
        UnassignDriverFromOrder = <any> 'UnassignDriverFromOrder',
        UpdateOrdersDeliveryTrackingStatus = <any> 'UpdateOrdersDeliveryTrackingStatus',
        UpdateOrderFulfillmentStatus = <any> 'UpdateOrderFulfillmentStatus',
        ViewFulfillmentStatesConfiguration = <any> 'ViewFulfillmentStatesConfiguration',
        CreateFulfillmentStatesConfiguration = <any> 'CreateFulfillmentStatesConfiguration',
        UpdateFulfillmentStatesConfiguration = <any> 'UpdateFulfillmentStatesConfiguration',
        DeleteFulfillmentStatesConfiguration = <any> 'DeleteFulfillmentStatesConfiguration',
        ViewPayouts = <any> 'ViewPayouts',
        ViewChannels = <any> 'ViewChannels',
        ViewOnboarding = <any> 'ViewOnboarding',
        UpdateOnboarding = <any> 'UpdateOnboarding',
        ViewClientDevices = <any> 'ViewClientDevices',
        UpdateClientDevices = <any> 'UpdateClientDevices',
        EnrollClientDevices = <any> 'EnrollClientDevices',
        AssignClientDevices = <any> 'AssignClientDevices',
        ViewClientAuditLogs = <any> 'ViewClientAuditLogs',
        CreateAppStoreAppConfiguration = <any> 'CreateAppStoreAppConfiguration',
        ViewAppStoreAppConfiguration = <any> 'ViewAppStoreAppConfiguration',
        UpdateAppStoreAppConfiguration = <any> 'UpdateAppStoreAppConfiguration',
        DeleteAppStoreAppConfiguration = <any> 'DeleteAppStoreAppConfiguration',
        UpdateAppStoreAppConfigurationSettings = <any> 'UpdateAppStoreAppConfigurationSettings',
        CreateAppStoreSubscription = <any> 'CreateAppStoreSubscription',
        UpdateAppStoreSubscription = <any> 'UpdateAppStoreSubscription',
        DeleteAppStoreSubscription = <any> 'DeleteAppStoreSubscription',
        ViewSalesChannels = <any> 'ViewSalesChannels',
        EditSalesChannels = <any> 'EditSalesChannels',
        ViewPayGreenWhiteLabelConfiguration = <any> 'ViewPayGreenWhiteLabelConfiguration',
        CreatePayGreenWhiteLabelConfiguration = <any> 'CreatePayGreenWhiteLabelConfiguration',
        UpdatePayGreenWhiteLabelConfiguration = <any> 'UpdatePayGreenWhiteLabelConfiguration',
        UpdatePayGreenStoreConfiguration = <any> 'UpdatePayGreenStoreConfiguration',
        ViewSubscriptions = <any> 'ViewSubscriptions'
    }
    export enum ApplicationCategoryEnum {
        Restaurant = <any> 'Restaurant',
        Cafe = <any> 'Cafe',
        Convenience = <any> 'Convenience'
    }
}
/**
* Describes a ChannelAssignment which is   when a AppId is assigned to a Sales Channel
*/
export class AppChannelAssignment {
    /**
    * Id of the channel on the assignment
    */
    'ChannelId'?: number;
    /**
    * AppId of the assignment
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ChannelId",
            "baseName": "ChannelId",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AppChannelAssignment.attributeTypeMap;
    }
}

/**
* Application compliance model
*/
export class AppCompliance {
    /**
    * App ID
    */
    'AppId'?: string;
    /**
    * Type of compliance.  This controls if the Flipdish websites and apps display cookie consent banners and adjust cookies to be inline with various regulations.   You should set this correctly based on your region.
    */
    'ComplianceType'?: AppCompliance.ComplianceTypeEnum;
    /**
    * For EU countries, we should not allow to change the option to “Default banner”, but all other countries should be able to do so.
    */
    'AllowDisablingOfGdpr'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "ComplianceType",
            "baseName": "ComplianceType",
            "type": "AppCompliance.ComplianceTypeEnum"
        },
        {
            "name": "AllowDisablingOfGdpr",
            "baseName": "AllowDisablingOfGdpr",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return AppCompliance.attributeTypeMap;
    }
}

export namespace AppCompliance {
    export enum ComplianceTypeEnum {
        Default = <any> 'Default',
        GdprCompliance = <any> 'GdprCompliance'
    }
}
/**
* App Config Sales Channel
*/
export class AppConfigSalesChannel {
    /**
    * Display a popup to users requesting their email address
    */
    'EmailRequestMode'?: AppConfigSalesChannel.EmailRequestModeEnum;
    /**
    * Sends users to their native apps or request them to install the pwa
    */
    'WebToAppRedirect'?: AppConfigSalesChannel.WebToAppRedirectEnum;
    /**
    * Address entry type
    */
    'AddressEntryType'?: AppConfigSalesChannel.AddressEntryTypeEnum;
    /**
    * Display Pickup Restaurant List Screen
    */
    'DisplayDeliveryRestaurantListScreen'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EmailRequestMode",
            "baseName": "EmailRequestMode",
            "type": "AppConfigSalesChannel.EmailRequestModeEnum"
        },
        {
            "name": "WebToAppRedirect",
            "baseName": "WebToAppRedirect",
            "type": "AppConfigSalesChannel.WebToAppRedirectEnum"
        },
        {
            "name": "AddressEntryType",
            "baseName": "AddressEntryType",
            "type": "AppConfigSalesChannel.AddressEntryTypeEnum"
        },
        {
            "name": "DisplayDeliveryRestaurantListScreen",
            "baseName": "DisplayDeliveryRestaurantListScreen",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return AppConfigSalesChannel.attributeTypeMap;
    }
}

export namespace AppConfigSalesChannel {
    export enum EmailRequestModeEnum {
        DoNotRequest = <any> 'DoNotRequest',
        Request = <any> 'Request',
        Require = <any> 'Require'
    }
    export enum WebToAppRedirectEnum {
        NoRedirect = <any> 'NoRedirect',
        RedirectOnce = <any> 'RedirectOnce',
        RedirectAlways = <any> 'RedirectAlways',
        SuggestPwa = <any> 'SuggestPwa',
        ForcePwa = <any> 'ForcePwa'
    }
    export enum AddressEntryTypeEnum {
        MapFirst = <any> 'MapFirst',
        TextEntryManualAllowed = <any> 'TextEntryManualAllowed',
        TextEntryManualDisallowed = <any> 'TextEntryManualDisallowed'
    }
}
/**
* Application configuration
*/
export class AppConfigUpdateModel {
    /**
    * App name.   This is used in various places on the Apple App Store, Google Play Store, mobile apps and websites.
    */
    'Name'?: string;
    /**
    * HostName on which the web-ordering system is allowed to be hosted or that a Flipdish website is hosted on.
    */
    'HostName'?: string;
    /**
    * Main color of the web / Android / iOS applications
    */
    'MainColor'?: string;
    /**
    * Primary colour used on the Kiosk
    */
    'KioskPrimaryColour'?: string;
    /**
    * Application Category
    */
    'ApplicationCategory'?: AppConfigUpdateModel.ApplicationCategoryEnum;
    /**
    * Panacea is the term used for websites that are hosted on the my.flipdish.com domain. This value is true when the App's website is hosted on this domain.  The aternative to using Panacea websites is to use a custom domain.
    */
    'IsPanaceaEnabled'?: boolean;
    /**
    * In case of IsPanaceaEnabled is true, the app can be accessed via https://my.flipdish.com/{PanaceaVanityUrl}
    */
    'PanaceaVanityUrl'?: string;
    /**
    * Cookie Consent Prompt Enabled
    */
    'CookieConsentPromptEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "HostName",
            "baseName": "HostName",
            "type": "string"
        },
        {
            "name": "MainColor",
            "baseName": "MainColor",
            "type": "string"
        },
        {
            "name": "KioskPrimaryColour",
            "baseName": "KioskPrimaryColour",
            "type": "string"
        },
        {
            "name": "ApplicationCategory",
            "baseName": "ApplicationCategory",
            "type": "AppConfigUpdateModel.ApplicationCategoryEnum"
        },
        {
            "name": "IsPanaceaEnabled",
            "baseName": "IsPanaceaEnabled",
            "type": "boolean"
        },
        {
            "name": "PanaceaVanityUrl",
            "baseName": "PanaceaVanityUrl",
            "type": "string"
        },
        {
            "name": "CookieConsentPromptEnabled",
            "baseName": "CookieConsentPromptEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return AppConfigUpdateModel.attributeTypeMap;
    }
}

export namespace AppConfigUpdateModel {
    export enum ApplicationCategoryEnum {
        Restaurant = <any> 'Restaurant',
        Cafe = <any> 'Cafe',
        Convenience = <any> 'Convenience'
    }
}
/**
* Application created event
*/
export class AppCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * App Name
    */
    'AppName'?: string;
    /**
    * Country Id
    */
    'CountryId'?: string;
    /**
    * User information
    */
    'User'?: UserEventInfo;
    /**
    * Salesforce Account Id
    */
    'AccountId'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "AppName",
            "baseName": "AppName",
            "type": "string"
        },
        {
            "name": "CountryId",
            "baseName": "CountryId",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "AccountId",
            "baseName": "AccountId",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AppCreatedEvent.attributeTypeMap;
    }
}

/**
* App lookup model
*/
export class AppLookup {
    /**
    * App id
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AppLookup.attributeTypeMap;
    }
}

export class AppStoreApp {
    'Id': string;
    'VerificationStatus': AppStoreApp.VerificationStatusEnum;
    'Logo'?: string;
    'OAuthAppId': string;
    'Internal': boolean;
    'Details': string;
    'ConfigurationType': AppStoreApp.ConfigurationTypeEnum;
    'StoreSelectorType': AppStoreApp.StoreSelectorTypeEnum;
    'FieldGroups'?: Array<FieldGroup>;
    'SetupInstructions'?: string;
    'ExternalSetupLink'?: string;
    'TeammateAppAccessLevel'?: AppStoreApp.TeammateAppAccessLevelEnum;
    'PermissionsType': AppStoreApp.PermissionsTypeEnum;
    'Support'?: AppStoreAppSupportInfo;
    'ExternalFunctionActionUrl'?: string;
    'ExternalFunctionSignatureKey'?: string;
    'IsPaid'?: boolean;
    'Name': string;
    'Description': string;
    'IsEnabled'?: boolean;
    'Categories': Array<AppStoreApp.CategoriesEnum>;
    'Countries': Array<AppStoreApp.CountriesEnum>;
    'DeveloperName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "string"
        },
        {
            "name": "VerificationStatus",
            "baseName": "VerificationStatus",
            "type": "AppStoreApp.VerificationStatusEnum"
        },
        {
            "name": "Logo",
            "baseName": "Logo",
            "type": "string"
        },
        {
            "name": "OAuthAppId",
            "baseName": "OAuthAppId",
            "type": "string"
        },
        {
            "name": "Internal",
            "baseName": "Internal",
            "type": "boolean"
        },
        {
            "name": "Details",
            "baseName": "Details",
            "type": "string"
        },
        {
            "name": "ConfigurationType",
            "baseName": "ConfigurationType",
            "type": "AppStoreApp.ConfigurationTypeEnum"
        },
        {
            "name": "StoreSelectorType",
            "baseName": "StoreSelectorType",
            "type": "AppStoreApp.StoreSelectorTypeEnum"
        },
        {
            "name": "FieldGroups",
            "baseName": "FieldGroups",
            "type": "Array<FieldGroup>"
        },
        {
            "name": "SetupInstructions",
            "baseName": "SetupInstructions",
            "type": "string"
        },
        {
            "name": "ExternalSetupLink",
            "baseName": "ExternalSetupLink",
            "type": "string"
        },
        {
            "name": "TeammateAppAccessLevel",
            "baseName": "TeammateAppAccessLevel",
            "type": "AppStoreApp.TeammateAppAccessLevelEnum"
        },
        {
            "name": "PermissionsType",
            "baseName": "PermissionsType",
            "type": "AppStoreApp.PermissionsTypeEnum"
        },
        {
            "name": "Support",
            "baseName": "Support",
            "type": "AppStoreAppSupportInfo"
        },
        {
            "name": "ExternalFunctionActionUrl",
            "baseName": "ExternalFunctionActionUrl",
            "type": "string"
        },
        {
            "name": "ExternalFunctionSignatureKey",
            "baseName": "ExternalFunctionSignatureKey",
            "type": "string"
        },
        {
            "name": "IsPaid",
            "baseName": "IsPaid",
            "type": "boolean"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "Categories",
            "baseName": "Categories",
            "type": "Array<AppStoreApp.CategoriesEnum>"
        },
        {
            "name": "Countries",
            "baseName": "Countries",
            "type": "Array<AppStoreApp.CountriesEnum>"
        },
        {
            "name": "DeveloperName",
            "baseName": "DeveloperName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AppStoreApp.attributeTypeMap;
    }
}

export namespace AppStoreApp {
    export enum VerificationStatusEnum {
        Draft = <any> 'Draft',
        Submitted = <any> 'Submitted',
        Verified = <any> 'Verified'
    }
    export enum ConfigurationTypeEnum {
        ExternalLink = <any> 'ExternalLink',
        FlipdishHosted = <any> 'FlipdishHosted'
    }
    export enum StoreSelectorTypeEnum {
        None = <any> 'None',
        Single = <any> 'Single',
        Multiple = <any> 'Multiple'
    }
    export enum TeammateAppAccessLevelEnum {
        Owner = <any> 'Owner',
        StoreOwner = <any> 'StoreOwner',
        ManagedOwner = <any> 'ManagedOwner',
        Integrator = <any> 'Integrator',
        StoreManager = <any> 'StoreManager',
        StoreStaff = <any> 'StoreStaff',
        StoreReadOnlyAccess = <any> 'StoreReadOnlyAccess',
        FinanceManger = <any> 'FinanceManger'
    }
    export enum PermissionsTypeEnum {
        Teammate = <any> 'Teammate'
    }
    export enum CategoriesEnum {
        PointOfSale = <any> 'PointOfSale',
        DeliveryAndLogistics = <any> 'DeliveryAndLogistics',
        CRM = <any> 'CRM',
        GiftCard = <any> 'GiftCard',
        Accounting = <any> 'Accounting',
        LoyaltyAndMarketing = <any> 'LoyaltyAndMarketing',
        Other = <any> 'Other'
    }
    export enum CountriesEnum {
        GB = <any> 'GB',
        IE = <any> 'IE',
        FR = <any> 'FR',
        ES = <any> 'ES',
        PT = <any> 'PT',
        IT = <any> 'IT',
        DE = <any> 'DE',
        PL = <any> 'PL',
        BE = <any> 'BE',
        LU = <any> 'LU',
        NL = <any> 'NL',
        US = <any> 'US',
        CA = <any> 'CA',
        BG = <any> 'BG',
        MX = <any> 'MX',
        AU = <any> 'AU',
        NZ = <any> 'NZ'
    }
}
export class AppStoreAppConfiguration {
    'Id': string;
    'AppId': string;
    'AppStoreAppId': string;
    'IsEnabled': boolean;
    'StoreIds'?: Array<number>;
    'Settings'?: Array<Setting>;
    'VerificationStatus': AppStoreAppConfiguration.VerificationStatusEnum;
    'Logo'?: string;
    'OAuthAppId': string;
    'Internal': boolean;
    'Details': string;
    'ConfigurationType': AppStoreAppConfiguration.ConfigurationTypeEnum;
    'StoreSelectorType': AppStoreAppConfiguration.StoreSelectorTypeEnum;
    'FieldGroups'?: Array<FieldGroup>;
    'SetupInstructions'?: string;
    'ExternalSetupLink'?: string;
    'TeammateAppAccessLevel'?: AppStoreAppConfiguration.TeammateAppAccessLevelEnum;
    'PermissionsType': AppStoreAppConfiguration.PermissionsTypeEnum;
    'Support'?: AppStoreAppSupportInfo;
    'ExternalFunctionActionUrl'?: string;
    'ExternalFunctionSignatureKey'?: string;
    'IsPaid'?: boolean;
    'Name': string;
    'Description': string;
    'Categories': Array<AppStoreAppConfiguration.CategoriesEnum>;
    'Countries': Array<AppStoreAppConfiguration.CountriesEnum>;
    'DeveloperName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "string"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "AppStoreAppId",
            "baseName": "AppStoreAppId",
            "type": "string"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "Settings",
            "baseName": "Settings",
            "type": "Array<Setting>"
        },
        {
            "name": "VerificationStatus",
            "baseName": "VerificationStatus",
            "type": "AppStoreAppConfiguration.VerificationStatusEnum"
        },
        {
            "name": "Logo",
            "baseName": "Logo",
            "type": "string"
        },
        {
            "name": "OAuthAppId",
            "baseName": "OAuthAppId",
            "type": "string"
        },
        {
            "name": "Internal",
            "baseName": "Internal",
            "type": "boolean"
        },
        {
            "name": "Details",
            "baseName": "Details",
            "type": "string"
        },
        {
            "name": "ConfigurationType",
            "baseName": "ConfigurationType",
            "type": "AppStoreAppConfiguration.ConfigurationTypeEnum"
        },
        {
            "name": "StoreSelectorType",
            "baseName": "StoreSelectorType",
            "type": "AppStoreAppConfiguration.StoreSelectorTypeEnum"
        },
        {
            "name": "FieldGroups",
            "baseName": "FieldGroups",
            "type": "Array<FieldGroup>"
        },
        {
            "name": "SetupInstructions",
            "baseName": "SetupInstructions",
            "type": "string"
        },
        {
            "name": "ExternalSetupLink",
            "baseName": "ExternalSetupLink",
            "type": "string"
        },
        {
            "name": "TeammateAppAccessLevel",
            "baseName": "TeammateAppAccessLevel",
            "type": "AppStoreAppConfiguration.TeammateAppAccessLevelEnum"
        },
        {
            "name": "PermissionsType",
            "baseName": "PermissionsType",
            "type": "AppStoreAppConfiguration.PermissionsTypeEnum"
        },
        {
            "name": "Support",
            "baseName": "Support",
            "type": "AppStoreAppSupportInfo"
        },
        {
            "name": "ExternalFunctionActionUrl",
            "baseName": "ExternalFunctionActionUrl",
            "type": "string"
        },
        {
            "name": "ExternalFunctionSignatureKey",
            "baseName": "ExternalFunctionSignatureKey",
            "type": "string"
        },
        {
            "name": "IsPaid",
            "baseName": "IsPaid",
            "type": "boolean"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Categories",
            "baseName": "Categories",
            "type": "Array<AppStoreAppConfiguration.CategoriesEnum>"
        },
        {
            "name": "Countries",
            "baseName": "Countries",
            "type": "Array<AppStoreAppConfiguration.CountriesEnum>"
        },
        {
            "name": "DeveloperName",
            "baseName": "DeveloperName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AppStoreAppConfiguration.attributeTypeMap;
    }
}

export namespace AppStoreAppConfiguration {
    export enum VerificationStatusEnum {
        Draft = <any> 'Draft',
        Submitted = <any> 'Submitted',
        Verified = <any> 'Verified'
    }
    export enum ConfigurationTypeEnum {
        ExternalLink = <any> 'ExternalLink',
        FlipdishHosted = <any> 'FlipdishHosted'
    }
    export enum StoreSelectorTypeEnum {
        None = <any> 'None',
        Single = <any> 'Single',
        Multiple = <any> 'Multiple'
    }
    export enum TeammateAppAccessLevelEnum {
        Owner = <any> 'Owner',
        StoreOwner = <any> 'StoreOwner',
        ManagedOwner = <any> 'ManagedOwner',
        Integrator = <any> 'Integrator',
        StoreManager = <any> 'StoreManager',
        StoreStaff = <any> 'StoreStaff',
        StoreReadOnlyAccess = <any> 'StoreReadOnlyAccess',
        FinanceManger = <any> 'FinanceManger'
    }
    export enum PermissionsTypeEnum {
        Teammate = <any> 'Teammate'
    }
    export enum CategoriesEnum {
        PointOfSale = <any> 'PointOfSale',
        DeliveryAndLogistics = <any> 'DeliveryAndLogistics',
        CRM = <any> 'CRM',
        GiftCard = <any> 'GiftCard',
        Accounting = <any> 'Accounting',
        LoyaltyAndMarketing = <any> 'LoyaltyAndMarketing',
        Other = <any> 'Other'
    }
    export enum CountriesEnum {
        GB = <any> 'GB',
        IE = <any> 'IE',
        FR = <any> 'FR',
        ES = <any> 'ES',
        PT = <any> 'PT',
        IT = <any> 'IT',
        DE = <any> 'DE',
        PL = <any> 'PL',
        BE = <any> 'BE',
        LU = <any> 'LU',
        NL = <any> 'NL',
        US = <any> 'US',
        CA = <any> 'CA',
        BG = <any> 'BG',
        MX = <any> 'MX',
        AU = <any> 'AU',
        NZ = <any> 'NZ'
    }
}
export class AppStoreAppConfigurationSummary {
    'Id': string;
    'AppId': string;
    'IsEnabled': boolean;
    'Stores': Array<ConfiguredStore>;
    'ConfigurationType': AppStoreAppConfigurationSummary.ConfigurationTypeEnum;
    'StoreSelectorType': AppStoreAppConfigurationSummary.StoreSelectorTypeEnum;
    'Internal': boolean;
    'AppStoreAppId': string;
    'Name': string;
    'Description': string;
    'Logo'?: string;
    'DeveloperName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "string"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "Stores",
            "baseName": "Stores",
            "type": "Array<ConfiguredStore>"
        },
        {
            "name": "ConfigurationType",
            "baseName": "ConfigurationType",
            "type": "AppStoreAppConfigurationSummary.ConfigurationTypeEnum"
        },
        {
            "name": "StoreSelectorType",
            "baseName": "StoreSelectorType",
            "type": "AppStoreAppConfigurationSummary.StoreSelectorTypeEnum"
        },
        {
            "name": "Internal",
            "baseName": "Internal",
            "type": "boolean"
        },
        {
            "name": "AppStoreAppId",
            "baseName": "AppStoreAppId",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Logo",
            "baseName": "Logo",
            "type": "string"
        },
        {
            "name": "DeveloperName",
            "baseName": "DeveloperName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AppStoreAppConfigurationSummary.attributeTypeMap;
    }
}

export namespace AppStoreAppConfigurationSummary {
    export enum ConfigurationTypeEnum {
        ExternalLink = <any> 'ExternalLink',
        FlipdishHosted = <any> 'FlipdishHosted'
    }
    export enum StoreSelectorTypeEnum {
        None = <any> 'None',
        Single = <any> 'Single',
        Multiple = <any> 'Multiple'
    }
}
export class AppStoreAppConfigurationsWithSubscriptions {
    'Subscription'?: AppStoreAppSubscriptionSummary;
    'Configurations'?: Array<AppStoreAppConfigurationSummary>;
    'Prices'?: Array<SubscriptionProductPriceInfo>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Subscription",
            "baseName": "Subscription",
            "type": "AppStoreAppSubscriptionSummary"
        },
        {
            "name": "Configurations",
            "baseName": "Configurations",
            "type": "Array<AppStoreAppConfigurationSummary>"
        },
        {
            "name": "Prices",
            "baseName": "Prices",
            "type": "Array<SubscriptionProductPriceInfo>"
        }    ];

    static getAttributeTypeMap() {
        return AppStoreAppConfigurationsWithSubscriptions.attributeTypeMap;
    }
}

export class AppStoreAppEntitlements {
    'EntitlementQuantity'?: number;
    'CurrentUsage'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EntitlementQuantity",
            "baseName": "EntitlementQuantity",
            "type": "number"
        },
        {
            "name": "CurrentUsage",
            "baseName": "CurrentUsage",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return AppStoreAppEntitlements.attributeTypeMap;
    }
}

export class AppStoreAppSubscriptionAccount {
    'Email'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AppStoreAppSubscriptionAccount.attributeTypeMap;
    }
}

export class AppStoreAppSubscriptionSummary {
    'TotalSubscriptions'?: number;
    'UsedSubscriptions'?: number;
    'SubscriptionAccountIsSetupForClient'?: boolean;
    'SubscriptionAccounts'?: Array<AppStoreAppSubscriptionAccount>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TotalSubscriptions",
            "baseName": "TotalSubscriptions",
            "type": "number"
        },
        {
            "name": "UsedSubscriptions",
            "baseName": "UsedSubscriptions",
            "type": "number"
        },
        {
            "name": "SubscriptionAccountIsSetupForClient",
            "baseName": "SubscriptionAccountIsSetupForClient",
            "type": "boolean"
        },
        {
            "name": "SubscriptionAccounts",
            "baseName": "SubscriptionAccounts",
            "type": "Array<AppStoreAppSubscriptionAccount>"
        }    ];

    static getAttributeTypeMap() {
        return AppStoreAppSubscriptionSummary.attributeTypeMap;
    }
}

export class AppStoreAppSummary {
    'Id': string;
    'VerificationStatus': AppStoreAppSummary.VerificationStatusEnum;
    'Logo'?: string;
    'Internal': boolean;
    'Name': string;
    'Description': string;
    'IsEnabled'?: boolean;
    'Categories': Array<AppStoreAppSummary.CategoriesEnum>;
    'Countries': Array<AppStoreAppSummary.CountriesEnum>;
    'DeveloperName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "string"
        },
        {
            "name": "VerificationStatus",
            "baseName": "VerificationStatus",
            "type": "AppStoreAppSummary.VerificationStatusEnum"
        },
        {
            "name": "Logo",
            "baseName": "Logo",
            "type": "string"
        },
        {
            "name": "Internal",
            "baseName": "Internal",
            "type": "boolean"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "Categories",
            "baseName": "Categories",
            "type": "Array<AppStoreAppSummary.CategoriesEnum>"
        },
        {
            "name": "Countries",
            "baseName": "Countries",
            "type": "Array<AppStoreAppSummary.CountriesEnum>"
        },
        {
            "name": "DeveloperName",
            "baseName": "DeveloperName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AppStoreAppSummary.attributeTypeMap;
    }
}

export namespace AppStoreAppSummary {
    export enum VerificationStatusEnum {
        Draft = <any> 'Draft',
        Submitted = <any> 'Submitted',
        Verified = <any> 'Verified'
    }
    export enum CategoriesEnum {
        PointOfSale = <any> 'PointOfSale',
        DeliveryAndLogistics = <any> 'DeliveryAndLogistics',
        CRM = <any> 'CRM',
        GiftCard = <any> 'GiftCard',
        Accounting = <any> 'Accounting',
        LoyaltyAndMarketing = <any> 'LoyaltyAndMarketing',
        Other = <any> 'Other'
    }
    export enum CountriesEnum {
        GB = <any> 'GB',
        IE = <any> 'IE',
        FR = <any> 'FR',
        ES = <any> 'ES',
        PT = <any> 'PT',
        IT = <any> 'IT',
        DE = <any> 'DE',
        PL = <any> 'PL',
        BE = <any> 'BE',
        LU = <any> 'LU',
        NL = <any> 'NL',
        US = <any> 'US',
        CA = <any> 'CA',
        BG = <any> 'BG',
        MX = <any> 'MX',
        AU = <any> 'AU',
        NZ = <any> 'NZ'
    }
}
export class AppStoreAppSupportInfo {
    'PrivacyPolicy'?: string;
    'TermsOfUse'?: string;
    'CompanyWebsite'?: string;
    'LearnMore'?: string;
    'InstallationMessage'?: string;
    'SupportEmail'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PrivacyPolicy",
            "baseName": "PrivacyPolicy",
            "type": "string"
        },
        {
            "name": "TermsOfUse",
            "baseName": "TermsOfUse",
            "type": "string"
        },
        {
            "name": "CompanyWebsite",
            "baseName": "CompanyWebsite",
            "type": "string"
        },
        {
            "name": "LearnMore",
            "baseName": "LearnMore",
            "type": "string"
        },
        {
            "name": "InstallationMessage",
            "baseName": "InstallationMessage",
            "type": "string"
        },
        {
            "name": "SupportEmail",
            "baseName": "SupportEmail",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AppStoreAppSupportInfo.attributeTypeMap;
    }
}

/**
* AppStore Config Created event
*/
export class AppStoreConfigCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * App Store App Id
    */
    'AppStoreAppId'?: string;
    /**
    * App Store Configuration Id
    */
    'AppStoreAppConfigurationId'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "AppStoreAppId",
            "baseName": "AppStoreAppId",
            "type": "string"
        },
        {
            "name": "AppStoreAppConfigurationId",
            "baseName": "AppStoreAppConfigurationId",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AppStoreConfigCreatedEvent.attributeTypeMap;
    }
}

/**
* AppStore Config Deleted event
*/
export class AppStoreConfigDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * App Store Id
    */
    'AppStoreAppId'?: string;
    /**
    * App Store Configuration Id
    */
    'AppStoreAppConfigurationId'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "AppStoreAppId",
            "baseName": "AppStoreAppId",
            "type": "string"
        },
        {
            "name": "AppStoreAppConfigurationId",
            "baseName": "AppStoreAppConfigurationId",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AppStoreConfigDeletedEvent.attributeTypeMap;
    }
}

/**
* AppStore Config Updated event
*/
export class AppStoreConfigUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * App Store Id
    */
    'AppStoreAppId'?: string;
    /**
    * App Configuration
    */
    'AppStoreAppConfiguration'?: UpdateAppStoreAppConfigurationWebhookDTO;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "AppStoreAppId",
            "baseName": "AppStoreAppId",
            "type": "string"
        },
        {
            "name": "AppStoreAppConfiguration",
            "baseName": "AppStoreAppConfiguration",
            "type": "UpdateAppStoreAppConfigurationWebhookDTO"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AppStoreConfigUpdatedEvent.attributeTypeMap;
    }
}

/**
* Subscription change job status updated event
*/
export class AppStoreSubscriptionChangeJobUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * App Store Id
    */
    'AppStoreAppId'?: string;
    /**
    * Status
    */
    'Status'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "AppStoreAppId",
            "baseName": "AppStoreAppId",
            "type": "string"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AppStoreSubscriptionChangeJobUpdatedEvent.attributeTypeMap;
    }
}

/**
* Application updated event
*/
export class AppUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * A summary of changes made
    */
    'Changes'?: string;
    /**
    * App Name
    */
    'AppName'?: string;
    /**
    * Country Id
    */
    'CountryId'?: string;
    /**
    * User information
    */
    'User'?: UserEventInfo;
    /**
    * App - Whitelabel config
    */
    'App'?: App;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Changes",
            "baseName": "Changes",
            "type": "string"
        },
        {
            "name": "AppName",
            "baseName": "AppName",
            "type": "string"
        },
        {
            "name": "CountryId",
            "baseName": "CountryId",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "App",
            "baseName": "App",
            "type": "App"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AppUpdatedEvent.attributeTypeMap;
    }
}

/**
* Assigned to Store Bank Account
*/
export class AssignedBankAccount {
    /**
    * Id of Bank Account
    */
    'Id'?: number;
    /**
    * Name of Bank Account
    */
    'BankAccountName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "BankAccountName",
            "baseName": "BankAccountName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AssignedBankAccount.attributeTypeMap;
    }
}

/**
* Change information for a field
*/
export class AuditLogFieldChangeInformation {
    /**
    * Path (hierarchy)
    */
    'Path'?: string;
    /**
    * Name of field
    */
    'Name'?: string;
    /**
    * Key (code) of field
    */
    'Key'?: string;
    /**
    * Old value
    */
    'OldValue'?: string;
    /**
    * New value
    */
    'NewValue'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Path",
            "baseName": "Path",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Key",
            "baseName": "Key",
            "type": "string"
        },
        {
            "name": "OldValue",
            "baseName": "OldValue",
            "type": "string"
        },
        {
            "name": "NewValue",
            "baseName": "NewValue",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AuditLogFieldChangeInformation.attributeTypeMap;
    }
}

/**
* Period opening and closing balance
*/
export class BalanceDetails {
    'OpeningBalance'?: number;
    'ClosingBalance'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OpeningBalance",
            "baseName": "OpeningBalance",
            "type": "number"
        },
        {
            "name": "ClosingBalance",
            "baseName": "ClosingBalance",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return BalanceDetails.attributeTypeMap;
    }
}

/**
* BANK ACCOUNT
*/
export class BankAccount {
    /**
    * Id of this account
    */
    'Id'?: number;
    /**
    * Name of this account
    */
    'AccountName'?: string;
    /**
    * IBAN of this account
    */
    'Iban'?: string;
    /**
    * SWIFT of this bank account
    */
    'Swift'?: string;
    /**
    * A list of one or more populated account fields (field key-value pairs).  If this list contains at least one item, the Iban, Swift and NationalClearingCode fields should be ignored.
    */
    'PopulatedAccountFields'?: Array<AccountFieldKeyValuePair>;
    /**
    * Status of Account
    */
    'AccountState'?: BankAccount.AccountStateEnum;
    /**
    * Store Names that are attached to this account
    */
    'StoreNames'?: Array<string>;
    /**
    * Address lf the bank
    */
    'BankAddress'?: string;
    /**
    * CountryCode of the Bank Account
    */
    'BankCountryCode'?: string;
    /**
    * Account Holders Address
    */
    'AccountHolderAddress'?: string;
    /**
    * Account Holders Country Code
    */
    'AccountHolderCountryCode'?: string;
    /**
    * Account Holders Vat Number
    */
    'VatNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "AccountName",
            "baseName": "AccountName",
            "type": "string"
        },
        {
            "name": "Iban",
            "baseName": "Iban",
            "type": "string"
        },
        {
            "name": "Swift",
            "baseName": "Swift",
            "type": "string"
        },
        {
            "name": "PopulatedAccountFields",
            "baseName": "PopulatedAccountFields",
            "type": "Array<AccountFieldKeyValuePair>"
        },
        {
            "name": "AccountState",
            "baseName": "AccountState",
            "type": "BankAccount.AccountStateEnum"
        },
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<string>"
        },
        {
            "name": "BankAddress",
            "baseName": "BankAddress",
            "type": "string"
        },
        {
            "name": "BankCountryCode",
            "baseName": "BankCountryCode",
            "type": "string"
        },
        {
            "name": "AccountHolderAddress",
            "baseName": "AccountHolderAddress",
            "type": "string"
        },
        {
            "name": "AccountHolderCountryCode",
            "baseName": "AccountHolderCountryCode",
            "type": "string"
        },
        {
            "name": "VatNumber",
            "baseName": "VatNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BankAccount.attributeTypeMap;
    }
}

export namespace BankAccount {
    export enum AccountStateEnum {
        Unverified = <any> 'Unverified',
        AwatingVerification = <any> 'AwatingVerification',
        Verified = <any> 'Verified',
        Grandfathered = <any> 'Grandfathered'
    }
}
/**
* 
*/
export class BankAccountAssignedEvent {
    /**
    * The assigned bank account
    */
    'BankAccount'?: BankAccount;
    /**
    * Event description
    */
    'Description'?: string;
    /**
    * Updated by user
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "BankAccount",
            "baseName": "BankAccount",
            "type": "BankAccount"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BankAccountAssignedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class BankAccountCreate {
    /**
    * Address lf the bank
    */
    'BankAddress'?: string;
    /**
    * CountryCode of the Bank Account
    */
    'BankCountryCode'?: string;
    /**
    * Account Holders Address
    */
    'AccountHolderAddress'?: string;
    /**
    * Account Holders Country Code
    */
    'AccountHolderCountryCode'?: string;
    /**
    * Account Holders Vat Number
    */
    'VatNumber'?: string;
    /**
    * Currency of Account
    */
    'CurrencyCode'?: BankAccountCreate.CurrencyCodeEnum;
    /**
    * List of stores to attach to Account
    */
    'StoreIds'?: Array<number>;
    /**
    * Name of Bank
    */
    'BankName'?: string;
    /**
    * Name of this account
    */
    'AccountName'?: string;
    /**
    * IBAN of this account
    */
    'Iban'?: string;
    /**
    * SWIFT of this bank account
    */
    'Swift'?: string;
    /**
    * National Clearing Code (BSB in Australia, Routing Number in USA/Canada, NCC in NZ)
    */
    'NationalClearingCode'?: string;
    /**
    * A list of one or more populated account fields (field key-value pairs).  If this list contains at least one item, the Iban, Swift and NationalClearingCode fields will be ignored.
    */
    'PopulatedAccountFields'?: Array<AccountFieldKeyValuePair>;
    /**
    * Reason for Rejection
    */
    'RejectionReason'?: string;
    /**
    * Business Type
    */
    'BusinessType'?: BankAccountCreate.BusinessTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "BankAddress",
            "baseName": "BankAddress",
            "type": "string"
        },
        {
            "name": "BankCountryCode",
            "baseName": "BankCountryCode",
            "type": "string"
        },
        {
            "name": "AccountHolderAddress",
            "baseName": "AccountHolderAddress",
            "type": "string"
        },
        {
            "name": "AccountHolderCountryCode",
            "baseName": "AccountHolderCountryCode",
            "type": "string"
        },
        {
            "name": "VatNumber",
            "baseName": "VatNumber",
            "type": "string"
        },
        {
            "name": "CurrencyCode",
            "baseName": "CurrencyCode",
            "type": "BankAccountCreate.CurrencyCodeEnum"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "BankName",
            "baseName": "BankName",
            "type": "string"
        },
        {
            "name": "AccountName",
            "baseName": "AccountName",
            "type": "string"
        },
        {
            "name": "Iban",
            "baseName": "Iban",
            "type": "string"
        },
        {
            "name": "Swift",
            "baseName": "Swift",
            "type": "string"
        },
        {
            "name": "NationalClearingCode",
            "baseName": "NationalClearingCode",
            "type": "string"
        },
        {
            "name": "PopulatedAccountFields",
            "baseName": "PopulatedAccountFields",
            "type": "Array<AccountFieldKeyValuePair>"
        },
        {
            "name": "RejectionReason",
            "baseName": "RejectionReason",
            "type": "string"
        },
        {
            "name": "BusinessType",
            "baseName": "BusinessType",
            "type": "BankAccountCreate.BusinessTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return BankAccountCreate.attributeTypeMap;
    }
}

export namespace BankAccountCreate {
    export enum CurrencyCodeEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
    export enum BusinessTypeEnum {
        Individual = <any> 'Individual',
        Company = <any> 'Company',
        NonProfit = <any> 'NonProfit',
        GovernmentEntity = <any> 'GovernmentEntity'
    }
}
/**
* 
*/
export class BankAccountCreatedEvent {
    /**
    * The create bank account
    */
    'BankAccount'?: BankAccount;
    /**
    * Updated by user
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "BankAccount",
            "baseName": "BankAccount",
            "type": "BankAccount"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BankAccountCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class BankAccountDeletedEvent {
    /**
    * The create bank account
    */
    'BankAccount'?: BankAccount;
    /**
    * Updated by user
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "BankAccount",
            "baseName": "BankAccount",
            "type": "BankAccount"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BankAccountDeletedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class BankAccountDetail {
    /**
    * Id of this account
    */
    'Id'?: number;
    /**
    * Store Names that are attached to this account
    */
    'StoreNames'?: Array<string>;
    /**
    * Status of Account
    */
    'AccountState'?: BankAccountDetail.AccountStateEnum;
    /**
    * Information about the Stripe connected account associated with this bank account (if any)
    */
    'StripeConnectedAccountInfo'?: StripeConnectedAccountInfo;
    /**
    * Address lf the bank
    */
    'BankAddress'?: string;
    /**
    * CountryCode of the Bank Account
    */
    'BankCountryCode'?: string;
    /**
    * Account Holders Address
    */
    'AccountHolderAddress'?: string;
    /**
    * Account Holders Country Code
    */
    'AccountHolderCountryCode'?: string;
    /**
    * Account Holders Vat Number
    */
    'VatNumber'?: string;
    /**
    * Currency of Account
    */
    'CurrencyCode'?: BankAccountDetail.CurrencyCodeEnum;
    /**
    * List of stores to attach to Account
    */
    'StoreIds'?: Array<number>;
    /**
    * Name of Bank
    */
    'BankName'?: string;
    /**
    * Name of this account
    */
    'AccountName'?: string;
    /**
    * IBAN of this account
    */
    'Iban'?: string;
    /**
    * SWIFT of this bank account
    */
    'Swift'?: string;
    /**
    * National Clearing Code (BSB in Australia, Routing Number in USA/Canada, NCC in NZ)
    */
    'NationalClearingCode'?: string;
    /**
    * A list of one or more populated account fields (field key-value pairs).  If this list contains at least one item, the Iban, Swift and NationalClearingCode fields will be ignored.
    */
    'PopulatedAccountFields'?: Array<AccountFieldKeyValuePair>;
    /**
    * Reason for Rejection
    */
    'RejectionReason'?: string;
    /**
    * Business Type
    */
    'BusinessType'?: BankAccountDetail.BusinessTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<string>"
        },
        {
            "name": "AccountState",
            "baseName": "AccountState",
            "type": "BankAccountDetail.AccountStateEnum"
        },
        {
            "name": "StripeConnectedAccountInfo",
            "baseName": "StripeConnectedAccountInfo",
            "type": "StripeConnectedAccountInfo"
        },
        {
            "name": "BankAddress",
            "baseName": "BankAddress",
            "type": "string"
        },
        {
            "name": "BankCountryCode",
            "baseName": "BankCountryCode",
            "type": "string"
        },
        {
            "name": "AccountHolderAddress",
            "baseName": "AccountHolderAddress",
            "type": "string"
        },
        {
            "name": "AccountHolderCountryCode",
            "baseName": "AccountHolderCountryCode",
            "type": "string"
        },
        {
            "name": "VatNumber",
            "baseName": "VatNumber",
            "type": "string"
        },
        {
            "name": "CurrencyCode",
            "baseName": "CurrencyCode",
            "type": "BankAccountDetail.CurrencyCodeEnum"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "BankName",
            "baseName": "BankName",
            "type": "string"
        },
        {
            "name": "AccountName",
            "baseName": "AccountName",
            "type": "string"
        },
        {
            "name": "Iban",
            "baseName": "Iban",
            "type": "string"
        },
        {
            "name": "Swift",
            "baseName": "Swift",
            "type": "string"
        },
        {
            "name": "NationalClearingCode",
            "baseName": "NationalClearingCode",
            "type": "string"
        },
        {
            "name": "PopulatedAccountFields",
            "baseName": "PopulatedAccountFields",
            "type": "Array<AccountFieldKeyValuePair>"
        },
        {
            "name": "RejectionReason",
            "baseName": "RejectionReason",
            "type": "string"
        },
        {
            "name": "BusinessType",
            "baseName": "BusinessType",
            "type": "BankAccountDetail.BusinessTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return BankAccountDetail.attributeTypeMap;
    }
}

export namespace BankAccountDetail {
    export enum AccountStateEnum {
        Unverified = <any> 'Unverified',
        AwatingVerification = <any> 'AwatingVerification',
        Verified = <any> 'Verified',
        Grandfathered = <any> 'Grandfathered'
    }
    export enum CurrencyCodeEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
    export enum BusinessTypeEnum {
        Individual = <any> 'Individual',
        Company = <any> 'Company',
        NonProfit = <any> 'NonProfit',
        GovernmentEntity = <any> 'GovernmentEntity'
    }
}
/**
* Represents a request to update bank account information details
*/
export class BankAccountDetailsUpdateRequest {
    /**
    * Address of the bank account
    */
    'BankAddress'?: string;
    /**
    * Address of the payee
    */
    'AccountHolderAddress'?: string;
    /**
    * Account Holders Vat Number
    */
    'VatNumber'?: string;
    /**
    * List of stores to attach to Account
    */
    'StoreIds'?: Array<number>;
    /**
    * Name of Bank
    */
    'BankName'?: string;
    /**
    * Name of this account
    */
    'AccountName'?: string;
    /**
    * IBAN of this account
    */
    'Iban'?: string;
    /**
    * SWIFT of this bank account
    */
    'Swift'?: string;
    /**
    * National Clearing Code (BSB in Australia, Routing Number in USA/Canada, NCC in NZ)
    */
    'NationalClearingCode'?: string;
    /**
    * A list of one or more populated account fields (field key-value pairs).  If this list contains at least one item, the Iban, Swift and NationalClearingCode fields will be ignored.
    */
    'PopulatedAccountFields'?: Array<AccountFieldKeyValuePair>;
    /**
    * Reason for Rejection
    */
    'RejectionReason'?: string;
    /**
    * Business Type
    */
    'BusinessType'?: BankAccountDetailsUpdateRequest.BusinessTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "BankAddress",
            "baseName": "BankAddress",
            "type": "string"
        },
        {
            "name": "AccountHolderAddress",
            "baseName": "AccountHolderAddress",
            "type": "string"
        },
        {
            "name": "VatNumber",
            "baseName": "VatNumber",
            "type": "string"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "BankName",
            "baseName": "BankName",
            "type": "string"
        },
        {
            "name": "AccountName",
            "baseName": "AccountName",
            "type": "string"
        },
        {
            "name": "Iban",
            "baseName": "Iban",
            "type": "string"
        },
        {
            "name": "Swift",
            "baseName": "Swift",
            "type": "string"
        },
        {
            "name": "NationalClearingCode",
            "baseName": "NationalClearingCode",
            "type": "string"
        },
        {
            "name": "PopulatedAccountFields",
            "baseName": "PopulatedAccountFields",
            "type": "Array<AccountFieldKeyValuePair>"
        },
        {
            "name": "RejectionReason",
            "baseName": "RejectionReason",
            "type": "string"
        },
        {
            "name": "BusinessType",
            "baseName": "BusinessType",
            "type": "BankAccountDetailsUpdateRequest.BusinessTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return BankAccountDetailsUpdateRequest.attributeTypeMap;
    }
}

export namespace BankAccountDetailsUpdateRequest {
    export enum BusinessTypeEnum {
        Individual = <any> 'Individual',
        Company = <any> 'Company',
        NonProfit = <any> 'NonProfit',
        GovernmentEntity = <any> 'GovernmentEntity'
    }
}
/**
* 
*/
export class BankAccountSummary {
    /**
    * Id of this account
    */
    'Id'?: number;
    /**
    * Store Names that are attached to this account
    */
    'StoreNames'?: Array<string>;
    /**
    * Status of Account
    */
    'AccountState'?: BankAccountSummary.AccountStateEnum;
    /**
    * Currency of Account
    */
    'CurrencyCode'?: string;
    /**
    * Information about the Stripe connected account associated with this bank account (if any)
    */
    'StripeConnectedAccountInfo'?: StripeConnectedAccountInfo;
    /**
    * Name of this account
    */
    'AccountName'?: string;
    /**
    * IBAN of this account
    */
    'Iban'?: string;
    /**
    * SWIFT of this bank account
    */
    'Swift'?: string;
    /**
    * National Clearing Code (BSB in Australia, Routing Number in USA/Canada, NCC in NZ)
    */
    'NationalClearingCode'?: string;
    /**
    * A list of one or more populated account fields (field key-value pairs).  If this list contains at least one item, the Iban, Swift and NationalClearingCode fields will be ignored.
    */
    'PopulatedAccountFields'?: Array<AccountFieldKeyValuePair>;
    /**
    * Reason for Rejection
    */
    'RejectionReason'?: string;
    /**
    * Business Type
    */
    'BusinessType'?: BankAccountSummary.BusinessTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<string>"
        },
        {
            "name": "AccountState",
            "baseName": "AccountState",
            "type": "BankAccountSummary.AccountStateEnum"
        },
        {
            "name": "CurrencyCode",
            "baseName": "CurrencyCode",
            "type": "string"
        },
        {
            "name": "StripeConnectedAccountInfo",
            "baseName": "StripeConnectedAccountInfo",
            "type": "StripeConnectedAccountInfo"
        },
        {
            "name": "AccountName",
            "baseName": "AccountName",
            "type": "string"
        },
        {
            "name": "Iban",
            "baseName": "Iban",
            "type": "string"
        },
        {
            "name": "Swift",
            "baseName": "Swift",
            "type": "string"
        },
        {
            "name": "NationalClearingCode",
            "baseName": "NationalClearingCode",
            "type": "string"
        },
        {
            "name": "PopulatedAccountFields",
            "baseName": "PopulatedAccountFields",
            "type": "Array<AccountFieldKeyValuePair>"
        },
        {
            "name": "RejectionReason",
            "baseName": "RejectionReason",
            "type": "string"
        },
        {
            "name": "BusinessType",
            "baseName": "BusinessType",
            "type": "BankAccountSummary.BusinessTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return BankAccountSummary.attributeTypeMap;
    }
}

export namespace BankAccountSummary {
    export enum AccountStateEnum {
        Unverified = <any> 'Unverified',
        AwatingVerification = <any> 'AwatingVerification',
        Verified = <any> 'Verified',
        Grandfathered = <any> 'Grandfathered'
    }
    export enum BusinessTypeEnum {
        Individual = <any> 'Individual',
        Company = <any> 'Company',
        NonProfit = <any> 'NonProfit',
        GovernmentEntity = <any> 'GovernmentEntity'
    }
}
/**
* 
*/
export class BankAccountUpdatedEvent {
    /**
    * The create bank account
    */
    'BankAccount'?: BankAccount;
    /**
    * Updated by user
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "BankAccount",
            "baseName": "BankAccount",
            "type": "BankAccount"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BankAccountUpdatedEvent.attributeTypeMap;
    }
}

/**
* Status of the bluetooth terminal
*/
export class BluetoothTerminalStatus {
    /**
    * Serial Number
    */
    'SerialNumber'?: string;
    /**
    * Software Version
    */
    'SoftwareVersion'?: string;
    /**
    * Device Type
    */
    'DeviceType'?: BluetoothTerminalStatus.DeviceTypeEnum;
    /**
    * Device Status
    */
    'Status'?: BluetoothTerminalStatus.StatusEnum;
    /**
    * Indication of the battery level from 0 to 1
    */
    'BatteryLevel'?: number;
    /**
    * Last time the status was updated
    */
    'UpdateTime'?: Date;
    /**
    * ReaderId for Stripe Terminal
    */
    'ReaderId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "SerialNumber",
            "baseName": "SerialNumber",
            "type": "string"
        },
        {
            "name": "SoftwareVersion",
            "baseName": "SoftwareVersion",
            "type": "string"
        },
        {
            "name": "DeviceType",
            "baseName": "DeviceType",
            "type": "BluetoothTerminalStatus.DeviceTypeEnum"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "BluetoothTerminalStatus.StatusEnum"
        },
        {
            "name": "BatteryLevel",
            "baseName": "BatteryLevel",
            "type": "number"
        },
        {
            "name": "UpdateTime",
            "baseName": "UpdateTime",
            "type": "Date"
        },
        {
            "name": "ReaderId",
            "baseName": "ReaderId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BluetoothTerminalStatus.attributeTypeMap;
    }
}

export namespace BluetoothTerminalStatus {
    export enum DeviceTypeEnum {
        CHIPPER2X = <any> 'CHIPPER_2X',
        COTSDEVICE = <any> 'COTS_DEVICE',
        VERIFONEP400 = <any> 'VERIFONE_P400',
        WISEPAD3 = <any> 'WISEPAD_3',
        WISEPOSE = <any> 'WISEPOS_E'
    }
    export enum StatusEnum {
        NotConnected = <any> 'Not_Connected',
        Connecting = <any> 'Connecting',
        Connected = <any> 'Connected',
        Online = <any> 'Online',
        Offline = <any> 'Offline'
    }
}
/**
* 
*/
export class BusinessHoursOverride {
    /**
    * Unique identifier
    */
    'BusinessHoursOverrideId'?: number;
    /**
    * Delivery or Pickup
    */
    'DeliveryType'?: BusinessHoursOverride.DeliveryTypeEnum;
    /**
    * Date and time in ISO 8601 format.
    */
    'StartTime': Date;
    /**
    * Date and time in ISO 8601 format.
    */
    'EndTime': Date;
    /**
    * Open, Closed or ClosedAllowPreOrders
    */
    'Type'?: BusinessHoursOverride.TypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "BusinessHoursOverrideId",
            "baseName": "BusinessHoursOverrideId",
            "type": "number"
        },
        {
            "name": "DeliveryType",
            "baseName": "DeliveryType",
            "type": "BusinessHoursOverride.DeliveryTypeEnum"
        },
        {
            "name": "StartTime",
            "baseName": "StartTime",
            "type": "Date"
        },
        {
            "name": "EndTime",
            "baseName": "EndTime",
            "type": "Date"
        },
        {
            "name": "Type",
            "baseName": "Type",
            "type": "BusinessHoursOverride.TypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return BusinessHoursOverride.attributeTypeMap;
    }
}

export namespace BusinessHoursOverride {
    export enum DeliveryTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
    export enum TypeEnum {
        Open = <any> 'Open',
        Closed = <any> 'Closed',
        ClosedAllowPreOrders = <any> 'ClosedAllowPreOrders'
    }
}
/**
* 
*/
export class BusinessHoursOverrideBase {
    /**
    * Delivery or Pickup
    */
    'DeliveryType'?: BusinessHoursOverrideBase.DeliveryTypeEnum;
    /**
    * Date and time in ISO 8601 format.
    */
    'StartTime': Date;
    /**
    * Date and time in ISO 8601 format.
    */
    'EndTime': Date;
    /**
    * Open, Closed or ClosedAllowPreOrders
    */
    'Type'?: BusinessHoursOverrideBase.TypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeliveryType",
            "baseName": "DeliveryType",
            "type": "BusinessHoursOverrideBase.DeliveryTypeEnum"
        },
        {
            "name": "StartTime",
            "baseName": "StartTime",
            "type": "Date"
        },
        {
            "name": "EndTime",
            "baseName": "EndTime",
            "type": "Date"
        },
        {
            "name": "Type",
            "baseName": "Type",
            "type": "BusinessHoursOverrideBase.TypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return BusinessHoursOverrideBase.attributeTypeMap;
    }
}

export namespace BusinessHoursOverrideBase {
    export enum DeliveryTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
    export enum TypeEnum {
        Open = <any> 'Open',
        Closed = <any> 'Closed',
        ClosedAllowPreOrders = <any> 'ClosedAllowPreOrders'
    }
}
/**
* Business hours period
*/
export class BusinessHoursPeriod {
    /**
    * Early
    */
    'Early'?: Range;
    /**
    * Late
    */
    'Late'?: Range;
    /**
    * Ranges
    */
    'Ranges'?: Array<Range>;
    /**
    * Day of week
    */
    'DayOfWeek'?: BusinessHoursPeriod.DayOfWeekEnum;
    /**
    * Start time
    */
    'StartTime'?: string;
    /**
    * Period
    */
    'Period'?: string;
    /**
    * Start time early
    */
    'StartTimeEarly'?: string;
    /**
    * Period early
    */
    'PeriodEarly'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Early",
            "baseName": "Early",
            "type": "Range"
        },
        {
            "name": "Late",
            "baseName": "Late",
            "type": "Range"
        },
        {
            "name": "Ranges",
            "baseName": "Ranges",
            "type": "Array<Range>"
        },
        {
            "name": "DayOfWeek",
            "baseName": "DayOfWeek",
            "type": "BusinessHoursPeriod.DayOfWeekEnum"
        },
        {
            "name": "StartTime",
            "baseName": "StartTime",
            "type": "string"
        },
        {
            "name": "Period",
            "baseName": "Period",
            "type": "string"
        },
        {
            "name": "StartTimeEarly",
            "baseName": "StartTimeEarly",
            "type": "string"
        },
        {
            "name": "PeriodEarly",
            "baseName": "PeriodEarly",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BusinessHoursPeriod.attributeTypeMap;
    }
}

export namespace BusinessHoursPeriod {
    export enum DayOfWeekEnum {
        Sunday = <any> 'Sunday',
        Monday = <any> 'Monday',
        Tuesday = <any> 'Tuesday',
        Wednesday = <any> 'Wednesday',
        Thursday = <any> 'Thursday',
        Friday = <any> 'Friday',
        Saturday = <any> 'Saturday'
    }
}
/**
* Business hours period
*/
export class BusinessHoursPeriodBase {
    /**
    * Day of week
    */
    'DayOfWeek'?: BusinessHoursPeriodBase.DayOfWeekEnum;
    /**
    * Start time
    */
    'StartTime'?: string;
    /**
    * Period
    */
    'Period'?: string;
    /**
    * Start time early
    */
    'StartTimeEarly'?: string;
    /**
    * Period early
    */
    'PeriodEarly'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DayOfWeek",
            "baseName": "DayOfWeek",
            "type": "BusinessHoursPeriodBase.DayOfWeekEnum"
        },
        {
            "name": "StartTime",
            "baseName": "StartTime",
            "type": "string"
        },
        {
            "name": "Period",
            "baseName": "Period",
            "type": "string"
        },
        {
            "name": "StartTimeEarly",
            "baseName": "StartTimeEarly",
            "type": "string"
        },
        {
            "name": "PeriodEarly",
            "baseName": "PeriodEarly",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BusinessHoursPeriodBase.attributeTypeMap;
    }
}

export namespace BusinessHoursPeriodBase {
    export enum DayOfWeekEnum {
        Sunday = <any> 'Sunday',
        Monday = <any> 'Monday',
        Tuesday = <any> 'Tuesday',
        Wednesday = <any> 'Wednesday',
        Thursday = <any> 'Thursday',
        Friday = <any> 'Friday',
        Saturday = <any> 'Saturday'
    }
}
/**
* Campaign statistics
*/
export class CampaignStatistics {
    /**
    * Deprecated. Number of issued vouchers.  This field is always zero.
    */
    'VouchersIssued'?: number;
    /**
    * Deprecated. Number of redeemed vouchers. This field is always zero.  This field is always zero.
    */
    'VouchersRedeemed'?: number;
    /**
    * Deprecated. Conversion of campaign (VouchersIssued / VouchersRedeemed).  This field is always zero.
    */
    'Conversion'?: number;
    /**
    * Deprecated.  Sales generated by campaign (TotalAmount - FeeChargedToCustomer ie. the discounted sale value).  This field is always zero.
    */
    'SalesGenerated'?: number;
    /**
    * Deprecated.  Return of investment of campaign (TotalAmount / DiscountAmount).  This field is always zero.
    */
    'ReturnOfInvestment'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "VouchersIssued",
            "baseName": "VouchersIssued",
            "type": "number"
        },
        {
            "name": "VouchersRedeemed",
            "baseName": "VouchersRedeemed",
            "type": "number"
        },
        {
            "name": "Conversion",
            "baseName": "Conversion",
            "type": "number"
        },
        {
            "name": "SalesGenerated",
            "baseName": "SalesGenerated",
            "type": "number"
        },
        {
            "name": "ReturnOfInvestment",
            "baseName": "ReturnOfInvestment",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CampaignStatistics.attributeTypeMap;
    }
}

export class CancellationToken {
    'IsCancellationRequested'?: boolean;
    'CanBeCanceled'?: boolean;
    'WaitHandle'?: WaitHandle;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IsCancellationRequested",
            "baseName": "IsCancellationRequested",
            "type": "boolean"
        },
        {
            "name": "CanBeCanceled",
            "baseName": "CanBeCanceled",
            "type": "boolean"
        },
        {
            "name": "WaitHandle",
            "baseName": "WaitHandle",
            "type": "WaitHandle"
        }    ];

    static getAttributeTypeMap() {
        return CancellationToken.attributeTypeMap;
    }
}

/**
* Card reader
*/
export class CardReader {
    /**
    * Stripe reader id
    */
    'Id'?: string;
    /**
    * Software version
    */
    'DeviceSoftwareVersion'?: string;
    /**
    * Device serial number
    */
    'SerialNumber'?: string;
    /**
    * Device status online or offline
    */
    'Status'?: string;
    /**
    * Registration code
    */
    'RegistrationCode'?: string;
    /**
    * Device type
    */
    'DeviceType'?: string;
    /**
    * Indicates that the reader is deleted or not
    */
    'Deleted'?: boolean;
    /**
    * Action status
    */
    'Action'?: ReaderActionStateInfo;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "string"
        },
        {
            "name": "DeviceSoftwareVersion",
            "baseName": "DeviceSoftwareVersion",
            "type": "string"
        },
        {
            "name": "SerialNumber",
            "baseName": "SerialNumber",
            "type": "string"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "string"
        },
        {
            "name": "RegistrationCode",
            "baseName": "RegistrationCode",
            "type": "string"
        },
        {
            "name": "DeviceType",
            "baseName": "DeviceType",
            "type": "string"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "boolean"
        },
        {
            "name": "Action",
            "baseName": "Action",
            "type": "ReaderActionStateInfo"
        }    ];

    static getAttributeTypeMap() {
        return CardReader.attributeTypeMap;
    }
}

/**
* Card reader registration request
*/
export class CardReaderRegistrationRequest {
    /**
    * The reader registration code
    */
    'RegistrationCode': string;
    /**
    * The kiosk device id
    */
    'KioskDeviceId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "RegistrationCode",
            "baseName": "RegistrationCode",
            "type": "string"
        },
        {
            "name": "KioskDeviceId",
            "baseName": "KioskDeviceId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CardReaderRegistrationRequest.attributeTypeMap;
    }
}

/**
* Defines the cart
*/
export class Cart {
    /**
    * Line items from the cart
    */
    'LineItems'?: Array<LineItem>;
    /**
    * Total cart price
    */
    'CartAmount'?: Price;
    /**
    * Total tip amount
    */
    'Tip'?: Price;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LineItems",
            "baseName": "LineItems",
            "type": "Array<LineItem>"
        },
        {
            "name": "CartAmount",
            "baseName": "CartAmount",
            "type": "Price"
        },
        {
            "name": "Tip",
            "baseName": "Tip",
            "type": "Price"
        }    ];

    static getAttributeTypeMap() {
        return Cart.attributeTypeMap;
    }
}

/**
* 
*/
export class CatalogGroupArchivedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the group
    */
    'User'?: UserEventInfo;
    /**
    * Catalog group created
    */
    'Group'?: Group;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Group",
            "baseName": "Group",
            "type": "Group"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CatalogGroupArchivedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class CatalogGroupCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the group
    */
    'User'?: UserEventInfo;
    /**
    * Catalog group created
    */
    'Group'?: Group;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Group",
            "baseName": "Group",
            "type": "Group"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CatalogGroupCreatedEvent.attributeTypeMap;
    }
}

/**
* Reference to an existing {Flipdish.Menus.PublicModels.V1.Catalog.Groups.Group}
*/
export class CatalogGroupReference {
    /**
    * Details of the referenced {Flipdish.Menus.PublicModels.V1.Catalog.Items.CatalogItem}
    */
    'Group'?: Group;
    /**
    * Identifier of the ProductId to use as SubProduct
    */
    'CatalogGroupId': string;
    /**
    * Identifier of the ProductId to use as SubProduct
    */
    'CatalogItemId'?: string;
    /**
    * Type of the SupProduct
    */
    'GroupType': CatalogGroupReference.GroupTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Group",
            "baseName": "Group",
            "type": "Group"
        },
        {
            "name": "CatalogGroupId",
            "baseName": "CatalogGroupId",
            "type": "string"
        },
        {
            "name": "CatalogItemId",
            "baseName": "CatalogItemId",
            "type": "string"
        },
        {
            "name": "GroupType",
            "baseName": "GroupType",
            "type": "CatalogGroupReference.GroupTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return CatalogGroupReference.attributeTypeMap;
    }
}

export namespace CatalogGroupReference {
    export enum GroupTypeEnum {
        ModifierGroup = <any> 'ModifierGroup'
    }
}
/**
* 
*/
export class CatalogGroupUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the group
    */
    'User'?: UserEventInfo;
    /**
    * Catalog group created
    */
    'Group'?: Group;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Group",
            "baseName": "Group",
            "type": "Group"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CatalogGroupUpdatedEvent.attributeTypeMap;
    }
}

/**
* Catalog Image
*/
export class CatalogImage {
    /**
    * Unique catalog Item id
    */
    'ImageUri'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ImageUri",
            "baseName": "ImageUri",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CatalogImage.attributeTypeMap;
    }
}

/**
* CatalogItem
*/
export class CatalogItem {
    /**
    * Unique catalog Item id
    */
    'CatalogItemId'?: string;
    /**
    * Returns true if the item is archived
    */
    'IsArchived'?: boolean;
    /**
    * Collection of groups associated with this item
    */
    'Groups'?: Array<CatalogGroupReference>;
    /**
    * Collection of metafields
    */
    'Metafields'?: Array<Metafield>;
    /**
    * Type of item (Product, Modifier, etc)
    */
    'ItemType': CatalogItem.ItemTypeEnum;
    /**
    * Stock Keeping Unit (SKU)
    */
    'Sku': string;
    /**
    * Item name
    */
    'Name': string;
    /**
    * Item description
    */
    'Description'?: string;
    /**
    * Item price
    */
    'Price': number;
    /**
    * Image File Name
    */
    'ImageFileName'?: string;
    /**
    * item contains alcohol
    */
    'Alcohol'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CatalogItemId",
            "baseName": "CatalogItemId",
            "type": "string"
        },
        {
            "name": "IsArchived",
            "baseName": "IsArchived",
            "type": "boolean"
        },
        {
            "name": "Groups",
            "baseName": "Groups",
            "type": "Array<CatalogGroupReference>"
        },
        {
            "name": "Metafields",
            "baseName": "Metafields",
            "type": "Array<Metafield>"
        },
        {
            "name": "ItemType",
            "baseName": "ItemType",
            "type": "CatalogItem.ItemTypeEnum"
        },
        {
            "name": "Sku",
            "baseName": "Sku",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "ImageFileName",
            "baseName": "ImageFileName",
            "type": "string"
        },
        {
            "name": "Alcohol",
            "baseName": "Alcohol",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CatalogItem.attributeTypeMap;
    }
}

export namespace CatalogItem {
    export enum ItemTypeEnum {
        Product = <any> 'Product',
        Modifier = <any> 'Modifier'
    }
}
/**
* 
*/
export class CatalogItemArchivedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the item
    */
    'User'?: UserEventInfo;
    /**
    * Catalog item created
    */
    'CatalogItem'?: CatalogItem;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "CatalogItem",
            "baseName": "CatalogItem",
            "type": "CatalogItem"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CatalogItemArchivedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class CatalogItemCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the item
    */
    'User'?: UserEventInfo;
    /**
    * Catalog item created
    */
    'CatalogItem'?: CatalogItem;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "CatalogItem",
            "baseName": "CatalogItem",
            "type": "CatalogItem"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CatalogItemCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class CatalogItemUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the item
    */
    'User'?: UserEventInfo;
    /**
    * Catalog item created
    */
    'CatalogItem'?: CatalogItem;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "CatalogItem",
            "baseName": "CatalogItem",
            "type": "CatalogItem"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CatalogItemUpdatedEvent.attributeTypeMap;
    }
}

/**
* The DNS for the Hostname verified
*/
export class CertificateCreatedEvent {
    /**
    * Description
    */
    'Hostname'?: string;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Hostname",
            "baseName": "Hostname",
            "type": "string"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CertificateCreatedEvent.attributeTypeMap;
    }
}

/**
* The DNS for the Hostname verified
*/
export class CertificateRenewedEvent {
    /**
    * Description
    */
    'Hostname'?: string;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Hostname",
            "baseName": "Hostname",
            "type": "string"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CertificateRenewedEvent.attributeTypeMap;
    }
}

/**
* Change password model
*/
export class ChangePasswordModel {
    /**
    * Old password
    */
    'OldPassword': string;
    /**
    * New password
    */
    'NewPassword': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OldPassword",
            "baseName": "OldPassword",
            "type": "string"
        },
        {
            "name": "NewPassword",
            "baseName": "NewPassword",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ChangePasswordModel.attributeTypeMap;
    }
}

export class Channel {
    /**
    * Channel Id
    */
    'ChannelId'?: number;
    /**
    * Channel TranslationKey
    */
    'TranslationKey'?: string;
    /**
    * Channel Source
    */
    'Source'?: Channel.SourceEnum;
    /**
    * Channel Logo URl
    */
    'LogoUri'?: string;
    /**
    * Channel is Available or not
    */
    'Available'?: boolean;
    /**
    * Channel is Maintained Externally or not
    */
    'MaintainedExternally'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ChannelId",
            "baseName": "ChannelId",
            "type": "number"
        },
        {
            "name": "TranslationKey",
            "baseName": "TranslationKey",
            "type": "string"
        },
        {
            "name": "Source",
            "baseName": "Source",
            "type": "Channel.SourceEnum"
        },
        {
            "name": "LogoUri",
            "baseName": "LogoUri",
            "type": "string"
        },
        {
            "name": "Available",
            "baseName": "Available",
            "type": "boolean"
        },
        {
            "name": "MaintainedExternally",
            "baseName": "MaintainedExternally",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Channel.attributeTypeMap;
    }
}

export namespace Channel {
    export enum SourceEnum {
        Internal = <any> 'Internal',
        External = <any> 'External'
    }
}
/**
* Describes a channel store mapping
*/
export class ChannelStoreMapping {
    'StoreId'?: number;
    'ChannelStoreId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "ChannelStoreId",
            "baseName": "ChannelStoreId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ChannelStoreMapping.attributeTypeMap;
    }
}

/**
* Channel Stores Updated Event
*/
export class ChannelStoresUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * ID of the channel
    */
    'ChannelId'?: number;
    /**
    * List of store ids
    */
    'StoreIds'?: Array<number>;
    /**
    * User info
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "ChannelId",
            "baseName": "ChannelId",
            "type": "number"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ChannelStoresUpdatedEvent.attributeTypeMap;
    }
}

/**
* Chargebacks breakdown
*/
export class ChargebackDetails {
    /**
    * Chargeback amount
    */
    'ChargebackAmount'?: number;
    /**
    * POS Chargeback amount
    */
    'PosSalesChargebackAmount'?: number;
    /**
    * Chargeback refunded feeds
    */
    'ChargebackRefundedFees'?: number;
    /**
    * Number of chargebacks
    */
    'ChargebacksCount'?: number;
    /**
    * Total amount
    */
    'TotalChargebackCost'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ChargebackAmount",
            "baseName": "ChargebackAmount",
            "type": "number"
        },
        {
            "name": "PosSalesChargebackAmount",
            "baseName": "PosSalesChargebackAmount",
            "type": "number"
        },
        {
            "name": "ChargebackRefundedFees",
            "baseName": "ChargebackRefundedFees",
            "type": "number"
        },
        {
            "name": "ChargebacksCount",
            "baseName": "ChargebacksCount",
            "type": "number"
        },
        {
            "name": "TotalChargebackCost",
            "baseName": "TotalChargebackCost",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ChargebackDetails.attributeTypeMap;
    }
}

/**
* Client Device
*/
export class ClientDevice {
    /**
    * Device Model
    */
    'DeviceModel'?: string;
    /**
    * Device Id
    */
    'DeviceId'?: string;
    /**
    * Device Name
    */
    'DeviceName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeviceModel",
            "baseName": "DeviceModel",
            "type": "string"
        },
        {
            "name": "DeviceId",
            "baseName": "DeviceId",
            "type": "string"
        },
        {
            "name": "DeviceName",
            "baseName": "DeviceName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ClientDevice.attributeTypeMap;
    }
}

/**
* Assign enrolled device to AppId
*/
export class ClientDeviceAssignEnrolledDevice {
    /**
    * Device Model
    */
    'DeviceModel'?: string;
    /**
    * Pin Code
    */
    'PinCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeviceModel",
            "baseName": "DeviceModel",
            "type": "string"
        },
        {
            "name": "PinCode",
            "baseName": "PinCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ClientDeviceAssignEnrolledDevice.attributeTypeMap;
    }
}

/**
* Enroll a client device
*/
export class ClientDeviceEnroll {
    /**
    * Device model
    */
    'DeviceModel'?: string;
    /**
    * Device Id
    */
    'DeviceId'?: string;
    /**
    * Device Name
    */
    'DeviceName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeviceModel",
            "baseName": "DeviceModel",
            "type": "string"
        },
        {
            "name": "DeviceId",
            "baseName": "DeviceId",
            "type": "string"
        },
        {
            "name": "DeviceName",
            "baseName": "DeviceName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ClientDeviceEnroll.attributeTypeMap;
    }
}

/**
* Device enrollment result
*/
export class ClientDeviceEnrollmentResult {
    /**
    * PIN Code for assigning
    */
    'PinCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PinCode",
            "baseName": "PinCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ClientDeviceEnrollmentResult.attributeTypeMap;
    }
}

/**
* Client Device summary (header fields)
*/
export class ClientDeviceSummary {
    /**
    * Device Model
    */
    'DeviceModel'?: string;
    /**
    * Device Id
    */
    'DeviceId'?: string;
    /**
    * Device Name
    */
    'DeviceName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeviceModel",
            "baseName": "DeviceModel",
            "type": "string"
        },
        {
            "name": "DeviceId",
            "baseName": "DeviceId",
            "type": "string"
        },
        {
            "name": "DeviceName",
            "baseName": "DeviceName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ClientDeviceSummary.attributeTypeMap;
    }
}

export class ConfiguredStore {
    'StoreId'?: number;
    'Name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ConfiguredStore.attributeTypeMap;
    }
}

/**
* Contact information for the user
*/
export class Contact {
    /**
    * Email Address
    */
    'Email'?: string;
    /**
    * International format Phone Number
    */
    'PhoneNumber'?: string;
    /**
    * First Name
    */
    'FirstName'?: string;
    /**
    * Last Name
    */
    'LastName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "PhoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        },
        {
            "name": "FirstName",
            "baseName": "FirstName",
            "type": "string"
        },
        {
            "name": "LastName",
            "baseName": "LastName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Contact.attributeTypeMap;
    }
}

/**
* Coordinates
*/
export class Coordinates {
    /**
    * Latitude
    */
    'Latitude'?: number;
    /**
    * Longitude
    */
    'Longitude'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Latitude",
            "baseName": "Latitude",
            "type": "number"
        },
        {
            "name": "Longitude",
            "baseName": "Longitude",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Coordinates.attributeTypeMap;
    }
}

export class CoordinatesDm {
    'Latitude'?: number;
    'Longitude'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Latitude",
            "baseName": "Latitude",
            "type": "number"
        },
        {
            "name": "Longitude",
            "baseName": "Longitude",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CoordinatesDm.attributeTypeMap;
    }
}

/**
* Country
*/
export class CountryFormResponse {
    /**
    * ISO two letter code.
    */
    'Value'?: string;
    /**
    * Label
    */
    'Label'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Value",
            "baseName": "Value",
            "type": "string"
        },
        {
            "name": "Label",
            "baseName": "Label",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CountryFormResponse.attributeTypeMap;
    }
}

/**
* List of field definitions per country
*/
export class CountryWithAccountFieldsDefinitions {
    /**
    * Country 2-letter ISO code
    */
    'CountryCode'?: string;
    /**
    * Display name of the country
    */
    'DisplayName'?: string;
    /**
    * Country support type (supported-by-stripe-cc, supported-by-flipdish,not-supported)
    */
    'SupportType'?: string;
    /**
    * Bank Account field definitions
    */
    'FieldDefinitions'?: Array<AccountFieldDefinition>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CountryCode",
            "baseName": "CountryCode",
            "type": "string"
        },
        {
            "name": "DisplayName",
            "baseName": "DisplayName",
            "type": "string"
        },
        {
            "name": "SupportType",
            "baseName": "SupportType",
            "type": "string"
        },
        {
            "name": "FieldDefinitions",
            "baseName": "FieldDefinitions",
            "type": "Array<AccountFieldDefinition>"
        }    ];

    static getAttributeTypeMap() {
        return CountryWithAccountFieldsDefinitions.attributeTypeMap;
    }
}

/**
* Create account model
*/
export class CreateAccountModel {
    /**
    * Email address
    */
    'Email': string;
    /**
    * Store name
    */
    'StoreName': string;
    /**
    * LanguageId
    */
    'LanguageId'?: string;
    /**
    * Referral ID
    */
    'Rid'?: number;
    /**
    * Campaign ID
    */
    'Cid'?: string;
    /**
    * Google Recaptcha Token
    */
    'RecaptchaToken'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "StoreName",
            "baseName": "StoreName",
            "type": "string"
        },
        {
            "name": "LanguageId",
            "baseName": "LanguageId",
            "type": "string"
        },
        {
            "name": "Rid",
            "baseName": "Rid",
            "type": "number"
        },
        {
            "name": "Cid",
            "baseName": "Cid",
            "type": "string"
        },
        {
            "name": "RecaptchaToken",
            "baseName": "RecaptchaToken",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateAccountModel.attributeTypeMap;
    }
}

/**
* Create an App in an Organisation Request
*/
export class CreateAppInOrg {
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Country in ISO 3166-1 alpha-2 standard
    */
    'CountryId'?: string;
    /**
    * Main color for the different sales channels
    */
    'MainColor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "CountryId",
            "baseName": "CountryId",
            "type": "string"
        },
        {
            "name": "MainColor",
            "baseName": "MainColor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateAppInOrg.attributeTypeMap;
    }
}

/**
* The parameters required to create a new app.
*/
export class CreateAppParameters {
    /**
    * The name of the brand that this app/white-label represents.
    */
    'Name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateAppParameters.attributeTypeMap;
    }
}

export class CreateAppStoreApp {
    'Details': string;
    'ConfigurationType': CreateAppStoreApp.ConfigurationTypeEnum;
    'StoreSelectorType': CreateAppStoreApp.StoreSelectorTypeEnum;
    'FieldGroups'?: Array<FieldGroup>;
    'SetupInstructions'?: string;
    'ExternalSetupLink'?: string;
    'TeammateAppAccessLevel'?: CreateAppStoreApp.TeammateAppAccessLevelEnum;
    'PermissionsType': CreateAppStoreApp.PermissionsTypeEnum;
    'Support'?: AppStoreAppSupportInfo;
    'ExternalFunctionActionUrl'?: string;
    'ExternalFunctionSignatureKey'?: string;
    'IsPaid'?: boolean;
    'Name': string;
    'Description': string;
    'IsEnabled'?: boolean;
    'Categories': Array<CreateAppStoreApp.CategoriesEnum>;
    'Countries': Array<CreateAppStoreApp.CountriesEnum>;
    'DeveloperName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Details",
            "baseName": "Details",
            "type": "string"
        },
        {
            "name": "ConfigurationType",
            "baseName": "ConfigurationType",
            "type": "CreateAppStoreApp.ConfigurationTypeEnum"
        },
        {
            "name": "StoreSelectorType",
            "baseName": "StoreSelectorType",
            "type": "CreateAppStoreApp.StoreSelectorTypeEnum"
        },
        {
            "name": "FieldGroups",
            "baseName": "FieldGroups",
            "type": "Array<FieldGroup>"
        },
        {
            "name": "SetupInstructions",
            "baseName": "SetupInstructions",
            "type": "string"
        },
        {
            "name": "ExternalSetupLink",
            "baseName": "ExternalSetupLink",
            "type": "string"
        },
        {
            "name": "TeammateAppAccessLevel",
            "baseName": "TeammateAppAccessLevel",
            "type": "CreateAppStoreApp.TeammateAppAccessLevelEnum"
        },
        {
            "name": "PermissionsType",
            "baseName": "PermissionsType",
            "type": "CreateAppStoreApp.PermissionsTypeEnum"
        },
        {
            "name": "Support",
            "baseName": "Support",
            "type": "AppStoreAppSupportInfo"
        },
        {
            "name": "ExternalFunctionActionUrl",
            "baseName": "ExternalFunctionActionUrl",
            "type": "string"
        },
        {
            "name": "ExternalFunctionSignatureKey",
            "baseName": "ExternalFunctionSignatureKey",
            "type": "string"
        },
        {
            "name": "IsPaid",
            "baseName": "IsPaid",
            "type": "boolean"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "Categories",
            "baseName": "Categories",
            "type": "Array<CreateAppStoreApp.CategoriesEnum>"
        },
        {
            "name": "Countries",
            "baseName": "Countries",
            "type": "Array<CreateAppStoreApp.CountriesEnum>"
        },
        {
            "name": "DeveloperName",
            "baseName": "DeveloperName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateAppStoreApp.attributeTypeMap;
    }
}

export namespace CreateAppStoreApp {
    export enum ConfigurationTypeEnum {
        ExternalLink = <any> 'ExternalLink',
        FlipdishHosted = <any> 'FlipdishHosted'
    }
    export enum StoreSelectorTypeEnum {
        None = <any> 'None',
        Single = <any> 'Single',
        Multiple = <any> 'Multiple'
    }
    export enum TeammateAppAccessLevelEnum {
        Owner = <any> 'Owner',
        StoreOwner = <any> 'StoreOwner',
        ManagedOwner = <any> 'ManagedOwner',
        Integrator = <any> 'Integrator',
        StoreManager = <any> 'StoreManager',
        StoreStaff = <any> 'StoreStaff',
        StoreReadOnlyAccess = <any> 'StoreReadOnlyAccess',
        FinanceManger = <any> 'FinanceManger'
    }
    export enum PermissionsTypeEnum {
        Teammate = <any> 'Teammate'
    }
    export enum CategoriesEnum {
        PointOfSale = <any> 'PointOfSale',
        DeliveryAndLogistics = <any> 'DeliveryAndLogistics',
        CRM = <any> 'CRM',
        GiftCard = <any> 'GiftCard',
        Accounting = <any> 'Accounting',
        LoyaltyAndMarketing = <any> 'LoyaltyAndMarketing',
        Other = <any> 'Other'
    }
    export enum CountriesEnum {
        GB = <any> 'GB',
        IE = <any> 'IE',
        FR = <any> 'FR',
        ES = <any> 'ES',
        PT = <any> 'PT',
        IT = <any> 'IT',
        DE = <any> 'DE',
        PL = <any> 'PL',
        BE = <any> 'BE',
        LU = <any> 'LU',
        NL = <any> 'NL',
        US = <any> 'US',
        CA = <any> 'CA',
        BG = <any> 'BG',
        MX = <any> 'MX',
        AU = <any> 'AU',
        NZ = <any> 'NZ'
    }
}
/**
* Basic attributes for creating an account
*/
export class CreateBasicAccountModel {
    /**
    * Store name
    */
    'StoreName': string;
    /**
    * LanguageId
    */
    'LanguageId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreName",
            "baseName": "StoreName",
            "type": "string"
        },
        {
            "name": "LanguageId",
            "baseName": "LanguageId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateBasicAccountModel.attributeTypeMap;
    }
}

/**
* Information to create a reference to a {Flipdish.Menus.PublicModels.V1.Catalog.Groups.Group}
*/
export class CreateCatalogGroupReference {
    /**
    * Identifier of the ProductId to use as SubProduct
    */
    'CatalogGroupId': string;
    /**
    * Identifier of the ProductId to use as SubProduct
    */
    'CatalogItemId'?: string;
    /**
    * Type of the SupProduct
    */
    'GroupType': CreateCatalogGroupReference.GroupTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CatalogGroupId",
            "baseName": "CatalogGroupId",
            "type": "string"
        },
        {
            "name": "CatalogItemId",
            "baseName": "CatalogItemId",
            "type": "string"
        },
        {
            "name": "GroupType",
            "baseName": "GroupType",
            "type": "CreateCatalogGroupReference.GroupTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return CreateCatalogGroupReference.attributeTypeMap;
    }
}

export namespace CreateCatalogGroupReference {
    export enum GroupTypeEnum {
        ModifierGroup = <any> 'ModifierGroup'
    }
}
/**
* Create a Catalog Item
*/
export class CreateCatalogItem {
    /**
    * Collection of groups associated with this item
    */
    'Groups'?: Array<CreateCatalogGroupReference>;
    /**
    * Collection of metafields
    */
    'Metafields'?: Array<Metafield>;
    /**
    * Type of item (Product, Modifier, etc)
    */
    'ItemType': CreateCatalogItem.ItemTypeEnum;
    /**
    * Stock Keeping Unit (SKU)
    */
    'Sku': string;
    /**
    * Item name
    */
    'Name': string;
    /**
    * Item description
    */
    'Description'?: string;
    /**
    * Item price
    */
    'Price': number;
    /**
    * Image File Name
    */
    'ImageFileName'?: string;
    /**
    * item contains alcohol
    */
    'Alcohol'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Groups",
            "baseName": "Groups",
            "type": "Array<CreateCatalogGroupReference>"
        },
        {
            "name": "Metafields",
            "baseName": "Metafields",
            "type": "Array<Metafield>"
        },
        {
            "name": "ItemType",
            "baseName": "ItemType",
            "type": "CreateCatalogItem.ItemTypeEnum"
        },
        {
            "name": "Sku",
            "baseName": "Sku",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "ImageFileName",
            "baseName": "ImageFileName",
            "type": "string"
        },
        {
            "name": "Alcohol",
            "baseName": "Alcohol",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CreateCatalogItem.attributeTypeMap;
    }
}

export namespace CreateCatalogItem {
    export enum ItemTypeEnum {
        Product = <any> 'Product',
        Modifier = <any> 'Modifier'
    }
}
/**
* Create fulfillment states configuration
*/
export class CreateFulfillmentStatesConfiguration {
    /**
    * Stores id's
    */
    'StoreIds'?: Array<number>;
    /**
    * Store Selector Type
    */
    'StoreSelectorType'?: CreateFulfillmentStatesConfiguration.StoreSelectorTypeEnum;
    /**
    * Settings
    */
    'States'?: Array<FulfillmentStatusConfigurationItem>;
    /**
    * Enable automatic transitions
    */
    'AutomaticTransitionsEnabled'?: boolean;
    /**
    * Name
    */
    'Name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "StoreSelectorType",
            "baseName": "StoreSelectorType",
            "type": "CreateFulfillmentStatesConfiguration.StoreSelectorTypeEnum"
        },
        {
            "name": "States",
            "baseName": "States",
            "type": "Array<FulfillmentStatusConfigurationItem>"
        },
        {
            "name": "AutomaticTransitionsEnabled",
            "baseName": "AutomaticTransitionsEnabled",
            "type": "boolean"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateFulfillmentStatesConfiguration.attributeTypeMap;
    }
}

export namespace CreateFulfillmentStatesConfiguration {
    export enum StoreSelectorTypeEnum {
        None = <any> 'None',
        Single = <any> 'Single',
        Multiple = <any> 'Multiple'
    }
}
/**
* Create menu object
*/
export class CreateFullMenu {
    /**
    * Name of Menu, only shown in portal
    */
    'Name'?: string;
    /**
    * Image url
    */
    'ImageUrl'?: string;
    /**
    * Menu sections (starters, main etc)
    */
    'MenuSections'?: Array<CreateFullMenuSection>;
    /**
    * Menu tax rates
    */
    'TaxRates'?: Array<CreateMenuTaxRate>;
    /**
    * Display menu section link on UI
    */
    'DisplaySectionLinks'?: boolean;
    /**
    * Menu section behaviour
    */
    'MenuSectionBehaviour'?: CreateFullMenu.MenuSectionBehaviourEnum;
    /**
    * Tax type
    */
    'TaxType'?: CreateFullMenu.TaxTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        },
        {
            "name": "MenuSections",
            "baseName": "MenuSections",
            "type": "Array<CreateFullMenuSection>"
        },
        {
            "name": "TaxRates",
            "baseName": "TaxRates",
            "type": "Array<CreateMenuTaxRate>"
        },
        {
            "name": "DisplaySectionLinks",
            "baseName": "DisplaySectionLinks",
            "type": "boolean"
        },
        {
            "name": "MenuSectionBehaviour",
            "baseName": "MenuSectionBehaviour",
            "type": "CreateFullMenu.MenuSectionBehaviourEnum"
        },
        {
            "name": "TaxType",
            "baseName": "TaxType",
            "type": "CreateFullMenu.TaxTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return CreateFullMenu.attributeTypeMap;
    }
}

export namespace CreateFullMenu {
    export enum MenuSectionBehaviourEnum {
        ExpandSingle = <any> 'ExpandSingle',
        ExpandMultiple = <any> 'ExpandMultiple'
    }
    export enum TaxTypeEnum {
        IncludedInBasePrice = <any> 'IncludedInBasePrice',
        ExcludedFromBasePrice = <any> 'ExcludedFromBasePrice'
    }
}
/**
* Create menu item option set
*/
export class CreateFullMenuItemOptionSet {
    /**
    * Menu item option set identifier
    */
    'MenuItemOptionSetId'?: number;
    /**
    * Option set items
    */
    'MenuItemOptionSetItems'?: Array<CreateFullMenuItemOptionSetItem>;
    /**
    * Menu item option set name
    */
    'Name'?: string;
    /**
    * Is master option set. This can affect the layout of the options in the menu displayed to the customer. Usually it is true if the option could be considerd a standalone item as opposed to an addition (\"with ketchup\") or modifier (\"large\").
    */
    'IsMasterOptionSet'?: boolean;
    /**
    * Display order. Displayed in ascending order.
    */
    'DisplayOrder'?: number;
    /**
    * Minimum items must be selected
    */
    'MinSelectCount'?: number;
    /**
    * Maximum number of items can be selected
    */
    'MaxSelectCount'?: number;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: CreateFullMenuItemOptionSet.CellLayoutTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuItemOptionSetId",
            "baseName": "MenuItemOptionSetId",
            "type": "number"
        },
        {
            "name": "MenuItemOptionSetItems",
            "baseName": "MenuItemOptionSetItems",
            "type": "Array<CreateFullMenuItemOptionSetItem>"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "IsMasterOptionSet",
            "baseName": "IsMasterOptionSet",
            "type": "boolean"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "MinSelectCount",
            "baseName": "MinSelectCount",
            "type": "number"
        },
        {
            "name": "MaxSelectCount",
            "baseName": "MaxSelectCount",
            "type": "number"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "CreateFullMenuItemOptionSet.CellLayoutTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return CreateFullMenuItemOptionSet.attributeTypeMap;
    }
}

export namespace CreateFullMenuItemOptionSet {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* Create menu item option set item
*/
export class CreateFullMenuItemOptionSetItem {
    /**
    * Menu item option set item identifier
    */
    'MenuItemOptionSetItemId'?: number;
    /**
    * List of metadata
    */
    'Metadata'?: Array<CreateMetadata>;
    /**
    * Tax rate name
    */
    'TaxRateName'?: string;
    /**
    * if null, next option set is next. if -1, this is the final option set
    */
    'NextMenuItemOptionSetId'?: number;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Price
    */
    'Price'?: number;
    /**
    * An optional fee that can be added to the price of the item.
    */
    'DepositReturnFee'?: number;
    /**
    * Is available
    */
    'IsAvailable'?: boolean;
    /**
    * Display order. Displayed in ascending order.
    */
    'DisplayOrder'?: number;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: CreateFullMenuItemOptionSetItem.CellLayoutTypeEnum;
    /**
    * Image url
    */
    'ImageUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuItemOptionSetItemId",
            "baseName": "MenuItemOptionSetItemId",
            "type": "number"
        },
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "Array<CreateMetadata>"
        },
        {
            "name": "TaxRateName",
            "baseName": "TaxRateName",
            "type": "string"
        },
        {
            "name": "NextMenuItemOptionSetId",
            "baseName": "NextMenuItemOptionSetId",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "DepositReturnFee",
            "baseName": "DepositReturnFee",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "CreateFullMenuItemOptionSetItem.CellLayoutTypeEnum"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateFullMenuItemOptionSetItem.attributeTypeMap;
    }
}

export namespace CreateFullMenuItemOptionSetItem {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* Create menu section
*/
export class CreateFullMenuSection {
    /**
    * Menu section availability
    */
    'MenuSectionAvailability'?: MenuSectionAvailability;
    /**
    * Menu items
    */
    'MenuItems'?: Array<CreateFullMenuSectionItem>;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Display order
    */
    'DisplayOrder'?: number;
    /**
    * Is available
    */
    'IsAvailable'?: boolean;
    /**
    * Is hidden from customer. Perhaps when the item is out of stock.
    */
    'IsHiddenFromCustomers'?: boolean;
    /**
    * Image url
    */
    'ImageUrl'?: string;
    /**
    * Menu Section Id
    */
    'MenuSectionId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuSectionAvailability",
            "baseName": "MenuSectionAvailability",
            "type": "MenuSectionAvailability"
        },
        {
            "name": "MenuItems",
            "baseName": "MenuItems",
            "type": "Array<CreateFullMenuSectionItem>"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "IsHiddenFromCustomers",
            "baseName": "IsHiddenFromCustomers",
            "type": "boolean"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        },
        {
            "name": "MenuSectionId",
            "baseName": "MenuSectionId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CreateFullMenuSection.attributeTypeMap;
    }
}

/**
* Create menu section item
*/
export class CreateFullMenuSectionItem {
    /**
    * Menu item option sets
    */
    'MenuItemOptionSets'?: Array<CreateFullMenuItemOptionSet>;
    /**
    * List of metadata
    */
    'Metadata'?: Array<CreateMetadata>;
    /**
    * Tax rate name
    */
    'TaxRateName'?: string;
    /**
    * Menu item name (like \"Korma\")
    */
    'Name'?: string;
    /**
    * Description (like \"A lovely dish from the east\")
    */
    'Description'?: string;
    /**
    * Spiciness rating
    */
    'SpicinessRating'?: CreateFullMenuSectionItem.SpicinessRatingEnum;
    /**
    * Price - this is only used when there is no master option set and should be set to 0 if a master option set exists.
    */
    'Price'?: number;
    /**
    * An optional fee that can be added to the price of the item.
    */
    'DepositReturnFee'?: number;
    /**
    * Display order
    */
    'DisplayOrder'?: number;
    /**
    * To be set true if the item or an option of the item contains an alcoholic drink.
    */
    'Alcohol'?: boolean;
    /**
    * True if we accept orders for this item still
    */
    'IsAvailable'?: boolean;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: CreateFullMenuSectionItem.CellLayoutTypeEnum;
    /**
    * If true, then vouchers won't be applied for this item
    */
    'DisableVouchers'?: boolean;
    /**
    * Image url
    */
    'ImageName'?: string;
    /**
    * Image url
    */
    'ImageUrl'?: string;
    /**
    * Menu Item Id
    */
    'MenuItemId'?: number;
    /**
    * If true, the item is excluded from voucher discount calculations
    */
    'ExcludeFromVoucherDiscounting'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuItemOptionSets",
            "baseName": "MenuItemOptionSets",
            "type": "Array<CreateFullMenuItemOptionSet>"
        },
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "Array<CreateMetadata>"
        },
        {
            "name": "TaxRateName",
            "baseName": "TaxRateName",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "SpicinessRating",
            "baseName": "SpicinessRating",
            "type": "CreateFullMenuSectionItem.SpicinessRatingEnum"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "DepositReturnFee",
            "baseName": "DepositReturnFee",
            "type": "number"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "Alcohol",
            "baseName": "Alcohol",
            "type": "boolean"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "CreateFullMenuSectionItem.CellLayoutTypeEnum"
        },
        {
            "name": "DisableVouchers",
            "baseName": "DisableVouchers",
            "type": "boolean"
        },
        {
            "name": "ImageName",
            "baseName": "ImageName",
            "type": "string"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        },
        {
            "name": "MenuItemId",
            "baseName": "MenuItemId",
            "type": "number"
        },
        {
            "name": "ExcludeFromVoucherDiscounting",
            "baseName": "ExcludeFromVoucherDiscounting",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CreateFullMenuSectionItem.attributeTypeMap;
    }
}

export namespace CreateFullMenuSectionItem {
    export enum SpicinessRatingEnum {
        NotRated = <any> 'NotRated',
        Mild = <any> 'Mild',
        Medium = <any> 'Medium',
        Hot = <any> 'Hot'
    }
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* Create a Catalog Group
*/
export class CreateGroup {
    /**
    * Minimum number of items that the user has to select
    */
    'MinSelectCount'?: number;
    /**
    * Maximum number of items that the user has to select
    */
    'MaxSelectCount'?: number;
    /**
    * Collection of items associated with this group
    */
    'Products'?: Array<CreateProductReference>;
    /**
    * Collection of metafields
    */
    'Metafields'?: Array<Metafield>;
    /**
    * Type of group (ModifierGroup, etc)
    */
    'GroupType': CreateGroup.GroupTypeEnum;
    /**
    * Stock Keeping Unit (SKU)
    */
    'Sku': string;
    /**
    * Group name
    */
    'Name': string;
    /**
    * Autogenerate display text in ordering applications
    */
    'AutogenerateDisplayText'?: boolean;
    /**
    * Image File Name
    */
    'ImageFileName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MinSelectCount",
            "baseName": "MinSelectCount",
            "type": "number"
        },
        {
            "name": "MaxSelectCount",
            "baseName": "MaxSelectCount",
            "type": "number"
        },
        {
            "name": "Products",
            "baseName": "Products",
            "type": "Array<CreateProductReference>"
        },
        {
            "name": "Metafields",
            "baseName": "Metafields",
            "type": "Array<Metafield>"
        },
        {
            "name": "GroupType",
            "baseName": "GroupType",
            "type": "CreateGroup.GroupTypeEnum"
        },
        {
            "name": "Sku",
            "baseName": "Sku",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "AutogenerateDisplayText",
            "baseName": "AutogenerateDisplayText",
            "type": "boolean"
        },
        {
            "name": "ImageFileName",
            "baseName": "ImageFileName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateGroup.attributeTypeMap;
    }
}

export namespace CreateGroup {
    export enum GroupTypeEnum {
        ModifierGroup = <any> 'ModifierGroup'
    }
}
/**
* Information to create a reference to a {System.Text.RegularExpressions.Group}
*/
export class CreateGroupReference {
    /**
    * Identifier of the ProductId to use as SubProduct
    */
    'CatalogItemId': string;
    /**
    * Type of the SupProduct
    */
    'GroupType': CreateGroupReference.GroupTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CatalogItemId",
            "baseName": "CatalogItemId",
            "type": "string"
        },
        {
            "name": "GroupType",
            "baseName": "GroupType",
            "type": "CreateGroupReference.GroupTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return CreateGroupReference.attributeTypeMap;
    }
}

export namespace CreateGroupReference {
    export enum GroupTypeEnum {
        ModifierGroup = <any> 'ModifierGroup'
    }
}
/**
* Input model for creating a Location
*/
export class CreateLocation {
    /**
    * Location Id
    */
    'LocationId'?: number;
    /**
    * Descriptive LocationArea name
    */
    'LocationName'?: string;
    /**
    * The order that the Location should be displayed on the screen
    */
    'DisplayOrder'?: number;
    /**
    * Id of the Location on an external system
    */
    'ExternalLocationId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LocationId",
            "baseName": "LocationId",
            "type": "number"
        },
        {
            "name": "LocationName",
            "baseName": "LocationName",
            "type": "string"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "ExternalLocationId",
            "baseName": "ExternalLocationId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateLocation.attributeTypeMap;
    }
}

/**
* Input model for creating a LocationArea
*/
export class CreateLocationArea {
    /**
    * Descriptive LocationArea name
    */
    'LocationAreaName': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LocationAreaName",
            "baseName": "LocationAreaName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateLocationArea.attributeTypeMap;
    }
}

/**
* Add CatalogItems to a Menu
*/
export class CreateMenuSectionItemFromCatalogItems {
    /**
    * List of CatalogItems to add to the section
    */
    'MenuCatalogItems': Array<MenuCatalogItem>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuCatalogItems",
            "baseName": "MenuCatalogItems",
            "type": "Array<MenuCatalogItem>"
        }    ];

    static getAttributeTypeMap() {
        return CreateMenuSectionItemFromCatalogItems.attributeTypeMap;
    }
}

/**
* Tax Rates Associated with a Menu
*/
export class CreateMenuTaxRate {
    /**
    * Name of Tax Rate
    */
    'Name'?: string;
    /**
    * In Percentage
    */
    'Rate'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Rate",
            "baseName": "Rate",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CreateMenuTaxRate.attributeTypeMap;
    }
}

/**
* Create metadata
*/
export class CreateMetadata {
    /**
    * Store identifier
    */
    'StoreId'?: number;
    /**
    * Metadata key (Unique identifier)
    */
    'Key'?: string;
    /**
    * Metadata value
    */
    'Value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "Key",
            "baseName": "Key",
            "type": "string"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateMetadata.attributeTypeMap;
    }
}

/**
* Information to create a {Flipdish.Metafields.PublicModels.V1.MetafieldDefinition}
*/
export class CreateMetafieldDefinition {
    /**
    * Indicates if a definition can be edited or not
    */
    'IsReadOnly'?: boolean;
    /**
    * The Metafield will extend the specified {Flipdish.Metafields.PublicModels.V1.MetafieldDefinitionBase.OwnerEntity}
    */
    'OwnerEntity'?: CreateMetafieldDefinition.OwnerEntityEnum;
    /**
    * Key of the metafield.  The key must have two parts, separated by a dot. The first part acts as a category, for organizational purposes.  The parts can be composed of lowercase letters, numbers, hyphen and underscore
    */
    'Key': string;
    /**
    * The excepted type for the Value field
    */
    'ValueType'?: CreateMetafieldDefinition.ValueTypeEnum;
    /**
    * Field Name
    */
    'Name': string;
    /**
    * Field Description
    */
    'Description'?: string;
    /**
    * Enable Metafield Behaviors
    */
    'Behaviors'?: Array<CreateMetafieldDefinition.BehaviorsEnum>;
    /**
    * Metafield Recommendation Id
    */
    'MetafieldDefinitionRecommendationId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IsReadOnly",
            "baseName": "IsReadOnly",
            "type": "boolean"
        },
        {
            "name": "OwnerEntity",
            "baseName": "OwnerEntity",
            "type": "CreateMetafieldDefinition.OwnerEntityEnum"
        },
        {
            "name": "Key",
            "baseName": "Key",
            "type": "string"
        },
        {
            "name": "ValueType",
            "baseName": "ValueType",
            "type": "CreateMetafieldDefinition.ValueTypeEnum"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Behaviors",
            "baseName": "Behaviors",
            "type": "Array<CreateMetafieldDefinition.BehaviorsEnum>"
        },
        {
            "name": "MetafieldDefinitionRecommendationId",
            "baseName": "MetafieldDefinitionRecommendationId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CreateMetafieldDefinition.attributeTypeMap;
    }
}

export namespace CreateMetafieldDefinition {
    export enum OwnerEntityEnum {
        CatalogItem = <any> 'CatalogItem',
        CatalogGroup = <any> 'CatalogGroup',
        Menu = <any> 'Menu'
    }
    export enum ValueTypeEnum {
        Boolean = <any> 'Boolean',
        Json = <any> 'Json',
        SingleLineString = <any> 'SingleLineString',
        MultiLineString = <any> 'MultiLineString'
    }
    export enum BehaviorsEnum {
        SendToOrder = <any> 'SendToOrder',
        SendToMenu = <any> 'SendToMenu'
    }
}
export class CreateOrderRequest {
    'LegacyOrderDm'?: OrderDm;
    'PhoneNumber'?: string;
    'CustomerName'?: string;
    'DeliveryLocation'?: DeliveryLocation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LegacyOrderDm",
            "baseName": "LegacyOrderDm",
            "type": "OrderDm"
        },
        {
            "name": "PhoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        },
        {
            "name": "CustomerName",
            "baseName": "CustomerName",
            "type": "string"
        },
        {
            "name": "DeliveryLocation",
            "baseName": "DeliveryLocation",
            "type": "DeliveryLocation"
        }    ];

    static getAttributeTypeMap() {
        return CreateOrderRequest.attributeTypeMap;
    }
}

export class CreatePayGreenConfigurationRequest {
    'Name'?: string;
    'PayGreenId'?: string;
    'PayGreenPrivateKey'?: string;
    'AssignedStores'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "PayGreenId",
            "baseName": "PayGreenId",
            "type": "string"
        },
        {
            "name": "PayGreenPrivateKey",
            "baseName": "PayGreenPrivateKey",
            "type": "string"
        },
        {
            "name": "AssignedStores",
            "baseName": "AssignedStores",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return CreatePayGreenConfigurationRequest.attributeTypeMap;
    }
}

/**
* Create a Catalog Item
*/
export class CreateProduct {
    /**
    * Collection of groups associated with this item
    */
    'Groups'?: Array<CreateGroupReference>;
    /**
    * Collection of metafields
    */
    'Metafields'?: Array<Metafield>;
    /**
    * Type of item (Product, Modifier, etc)
    */
    'ProductType': CreateProduct.ProductTypeEnum;
    /**
    * Stock Keeping Unit (SKU)
    */
    'Sku': string;
    /**
    * Product name
    */
    'Name': string;
    /**
    * Product description
    */
    'Description'?: string;
    /**
    * Product price
    */
    'Price': number;
    /**
    * Image File Name
    */
    'ImageFileName'?: string;
    /**
    * Product contains alcohol
    */
    'Alcohol'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Groups",
            "baseName": "Groups",
            "type": "Array<CreateGroupReference>"
        },
        {
            "name": "Metafields",
            "baseName": "Metafields",
            "type": "Array<Metafield>"
        },
        {
            "name": "ProductType",
            "baseName": "ProductType",
            "type": "CreateProduct.ProductTypeEnum"
        },
        {
            "name": "Sku",
            "baseName": "Sku",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "ImageFileName",
            "baseName": "ImageFileName",
            "type": "string"
        },
        {
            "name": "Alcohol",
            "baseName": "Alcohol",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CreateProduct.attributeTypeMap;
    }
}

export namespace CreateProduct {
    export enum ProductTypeEnum {
        Product = <any> 'Product',
        Modifier = <any> 'Modifier'
    }
}
/**
* Information to create a reference to a {Flipdish.Menus.PublicModels.V1.Catalog.Product}
*/
export class CreateProductReference {
    /**
    * Identifier of the CatalogItemId to use as SubProduct
    */
    'CatalogItemId': string;
    /**
    * Type of the SupProduct
    */
    'ProductType': CreateProductReference.ProductTypeEnum;
    /**
    * Quantity of the modifier that will be set when the parent product is placed in the basket
    */
    'PreselectedQuantity'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CatalogItemId",
            "baseName": "CatalogItemId",
            "type": "string"
        },
        {
            "name": "ProductType",
            "baseName": "ProductType",
            "type": "CreateProductReference.ProductTypeEnum"
        },
        {
            "name": "PreselectedQuantity",
            "baseName": "PreselectedQuantity",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CreateProductReference.attributeTypeMap;
    }
}

export namespace CreateProductReference {
    export enum ProductTypeEnum {
        Product = <any> 'Product',
        Modifier = <any> 'Modifier'
    }
}
/**
* Create Promotion
*/
export class CreatePromotion {
    /**
    * Promotion Name
    */
    'Name'?: string;
    /**
    * Promotion Menu Item Awards
    */
    'MenuItemPublicIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "MenuItemPublicIds",
            "baseName": "MenuItemPublicIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CreatePromotion.attributeTypeMap;
    }
}

/**
* 
*/
export class CreateTeammate {
    /**
    * Email address
    */
    'Email'?: string;
    /**
    * App access level
    */
    'AppAccessLevel'?: CreateTeammate.AppAccessLevelEnum;
    /**
    * The user has access to all stores for the app (including new stores that added later)
    */
    'HasAccessToAllStores'?: boolean;
    /**
    * Store IDs the user has access to (if HasAccessToAllStores is false)
    */
    'StoreIds'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "AppAccessLevel",
            "baseName": "AppAccessLevel",
            "type": "CreateTeammate.AppAccessLevelEnum"
        },
        {
            "name": "HasAccessToAllStores",
            "baseName": "HasAccessToAllStores",
            "type": "boolean"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return CreateTeammate.attributeTypeMap;
    }
}

export namespace CreateTeammate {
    export enum AppAccessLevelEnum {
        None = <any> 'None',
        Owner = <any> 'Owner',
        StoreOwner = <any> 'StoreOwner',
        ManagedOwner = <any> 'ManagedOwner',
        Integrator = <any> 'Integrator',
        StoreManager = <any> 'StoreManager',
        StoreStaff = <any> 'StoreStaff',
        StoreReadOnlyAccess = <any> 'StoreReadOnlyAccess',
        FinanceManger = <any> 'FinanceManger',
        Onboarding = <any> 'Onboarding',
        Support = <any> 'Support'
    }
}
/**
* Create Voucher
*/
export class CreateVoucher {
    /**
    * Voucher Type
    */
    'VoucherType'?: CreateVoucher.VoucherTypeEnum;
    /**
    * Create Promotion details
    */
    'Promotion'?: CreatePromotion;
    /**
    * Credit note details
    */
    'CreditNoteDetails'?: CreditNoteDetails;
    /**
    * Lump discount details
    */
    'LumpDiscountDetails'?: LumpDiscountDetails;
    /**
    * Percent discount details
    */
    'PercentDiscountDetails'?: PercentDiscountDetails;
    /**
    * Voucher Code
    */
    'Code'?: string;
    /**
    * Voucher Description (Visible on printout)
    */
    'Description'?: string;
    /**
    * Stores that this voucher applies to
    */
    'Stores'?: Array<number>;
    /**
    * Valid on orders on or above
    */
    'ValidOnOrdersOver'?: number;
    /**
    * Takes priority
    */
    'TakesPriority'?: boolean;
    /**
    * Is voucher enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Is voucher automatically applied
    */
    'IsAutomaticallyApplied'?: boolean;
    /**
    * Include delivery fees
    */
    'IncludeDeliveryFee'?: boolean;
    /**
    * Valid for delivery orders
    */
    'IsValidForDeliveryOrders'?: boolean;
    /**
    * Valid for pickup orders
    */
    'IsValidForPickupOrders'?: boolean;
    /**
    * Valid for orders payed online
    */
    'IsValidForOrdersPayedOnline'?: boolean;
    /**
    * Valid for orders payed in cash
    */
    'IsValidForOrdersPayedByCash'?: boolean;
    /**
    * Valid only on the first order by the customer
    */
    'IsValidForFirstOrderOnly'?: boolean;
    /**
    * Valid once per customer
    */
    'IsValidOncePerCustomer'?: boolean;
    /**
    * Valid only once, by any customer (once used cannot be used again by any other customer)
    */
    'IsValidOnlyOnce'?: boolean;
    /**
    * Voucher Starts On (Time in UTC)
    */
    'StartDate'?: Date;
    /**
    * Voucher Expires On (Time in UTC)
    */
    'ExpiryDate'?: Date;
    /**
    * Limit the channels this voucher can be used on
    */
    'ChannelRestrictions'?: Array<CreateVoucher.ChannelRestrictionsEnum>;
    /**
    * Periods in which the voucher is valid.  An empty list means the voucher is valid at all times.  When updating the voucher, if this is set to null, the validity periods won't be updated.
    */
    'ValidityPeriods'?: Array<ValidityPeriod>;
    /**
    * Voucher Subtype
    */
    'VoucherSubType'?: CreateVoucher.VoucherSubTypeEnum;
    /**
    * Customer UserID
    */
    'CustomerId'?: number;
    /**
    * Maximum number of times the voucher can be redeemed (used)
    */
    'MaxRedemptions'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "VoucherType",
            "baseName": "VoucherType",
            "type": "CreateVoucher.VoucherTypeEnum"
        },
        {
            "name": "Promotion",
            "baseName": "Promotion",
            "type": "CreatePromotion"
        },
        {
            "name": "CreditNoteDetails",
            "baseName": "CreditNoteDetails",
            "type": "CreditNoteDetails"
        },
        {
            "name": "LumpDiscountDetails",
            "baseName": "LumpDiscountDetails",
            "type": "LumpDiscountDetails"
        },
        {
            "name": "PercentDiscountDetails",
            "baseName": "PercentDiscountDetails",
            "type": "PercentDiscountDetails"
        },
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Stores",
            "baseName": "Stores",
            "type": "Array<number>"
        },
        {
            "name": "ValidOnOrdersOver",
            "baseName": "ValidOnOrdersOver",
            "type": "number"
        },
        {
            "name": "TakesPriority",
            "baseName": "TakesPriority",
            "type": "boolean"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "IsAutomaticallyApplied",
            "baseName": "IsAutomaticallyApplied",
            "type": "boolean"
        },
        {
            "name": "IncludeDeliveryFee",
            "baseName": "IncludeDeliveryFee",
            "type": "boolean"
        },
        {
            "name": "IsValidForDeliveryOrders",
            "baseName": "IsValidForDeliveryOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForPickupOrders",
            "baseName": "IsValidForPickupOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedOnline",
            "baseName": "IsValidForOrdersPayedOnline",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedByCash",
            "baseName": "IsValidForOrdersPayedByCash",
            "type": "boolean"
        },
        {
            "name": "IsValidForFirstOrderOnly",
            "baseName": "IsValidForFirstOrderOnly",
            "type": "boolean"
        },
        {
            "name": "IsValidOncePerCustomer",
            "baseName": "IsValidOncePerCustomer",
            "type": "boolean"
        },
        {
            "name": "IsValidOnlyOnce",
            "baseName": "IsValidOnlyOnce",
            "type": "boolean"
        },
        {
            "name": "StartDate",
            "baseName": "StartDate",
            "type": "Date"
        },
        {
            "name": "ExpiryDate",
            "baseName": "ExpiryDate",
            "type": "Date"
        },
        {
            "name": "ChannelRestrictions",
            "baseName": "ChannelRestrictions",
            "type": "Array<CreateVoucher.ChannelRestrictionsEnum>"
        },
        {
            "name": "ValidityPeriods",
            "baseName": "ValidityPeriods",
            "type": "Array<ValidityPeriod>"
        },
        {
            "name": "VoucherSubType",
            "baseName": "VoucherSubType",
            "type": "CreateVoucher.VoucherSubTypeEnum"
        },
        {
            "name": "CustomerId",
            "baseName": "CustomerId",
            "type": "number"
        },
        {
            "name": "MaxRedemptions",
            "baseName": "MaxRedemptions",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CreateVoucher.attributeTypeMap;
    }
}

export namespace CreateVoucher {
    export enum VoucherTypeEnum {
        PercentageDiscount = <any> 'PercentageDiscount',
        LumpDiscount = <any> 'LumpDiscount',
        AddItem = <any> 'AddItem',
        CreditNote = <any> 'CreditNote',
        FreeDelivery = <any> 'FreeDelivery'
    }
    export enum ChannelRestrictionsEnum {
        Ios = <any> 'Ios',
        Android = <any> 'Android',
        Web = <any> 'Web',
        Kiosk = <any> 'Kiosk',
        Pos = <any> 'Pos',
        Google = <any> 'Google'
    }
    export enum VoucherSubTypeEnum {
        None = <any> 'None',
        SignUp = <any> 'SignUp',
        Loyalty = <any> 'Loyalty',
        Loyalty25 = <any> 'Loyalty25',
        Retention = <any> 'Retention',
        SecondaryRetention = <any> 'SecondaryRetention',
        Custom = <any> 'Custom'
    }
}
/**
* Response for the creation of multiple Menu Section Items
*/
export class CreatedMenuSectionItems {
    /**
    * Created Menu Section Items
    */
    'MenuSectionItems'?: Array<MenuSectionItem>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuSectionItems",
            "baseName": "MenuSectionItems",
            "type": "Array<MenuSectionItem>"
        }    ];

    static getAttributeTypeMap() {
        return CreatedMenuSectionItems.attributeTypeMap;
    }
}

/**
* Credit note details
*/
export class CreditNoteDetails {
    /**
    * Remaining credit
    */
    'RemainingCredit'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "RemainingCredit",
            "baseName": "RemainingCredit",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CreditNoteDetails.attributeTypeMap;
    }
}

/**
* Menu Items for Cross-Sell
*/
export class CrossSellMenuItems {
    /**
    * Menu Item Id's
    */
    'MenuItemIds'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuItemIds",
            "baseName": "MenuItemIds",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return CrossSellMenuItems.attributeTypeMap;
    }
}

export class CspReport {
    'Document_uri'?: string;
    'Referrer'?: string;
    'Violated_directive'?: string;
    'Effective_directive'?: string;
    'Original_policy'?: string;
    'Blocked_uri'?: string;
    'Status_code'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Document_uri",
            "baseName": "Document-uri",
            "type": "string"
        },
        {
            "name": "Referrer",
            "baseName": "Referrer",
            "type": "string"
        },
        {
            "name": "Violated_directive",
            "baseName": "Violated-directive",
            "type": "string"
        },
        {
            "name": "Effective_directive",
            "baseName": "Effective-directive",
            "type": "string"
        },
        {
            "name": "Original_policy",
            "baseName": "Original-policy",
            "type": "string"
        },
        {
            "name": "Blocked_uri",
            "baseName": "Blocked-uri",
            "type": "string"
        },
        {
            "name": "Status_code",
            "baseName": "Status-code",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CspReport.attributeTypeMap;
    }
}

export class CspReportRequest {
    'Csp_report'?: CspReport;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Csp_report",
            "baseName": "Csp-report",
            "type": "CspReport"
        }    ];

    static getAttributeTypeMap() {
        return CspReportRequest.attributeTypeMap;
    }
}

/**
* A single currency data piece, with no date
*/
export class CurrencyData {
    /**
    * Currency
    */
    'Currency'?: CurrencyData.CurrencyEnum;
    /**
    * Value
    */
    'Value'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "CurrencyData.CurrencyEnum"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CurrencyData.attributeTypeMap;
    }
}

export namespace CurrencyData {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Defines a customer
*/
export class Customer {
    /**
    * Id of the customer
    */
    'CustomerId'?: number;
    /**
    * Customer registration date
    */
    'RegistrationDate'?: Date;
    /**
    * Phone Number in international format
    */
    'PhoneNumber'?: string;
    /**
    * Customer can place cash orders
    */
    'CashOrdersEnabled'?: boolean;
    /**
    * Customer can place card orders
    */
    'CardOrdersEnabled'?: boolean;
    /**
    * Customer can receive marketing
    */
    'MarketingEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CustomerId",
            "baseName": "CustomerId",
            "type": "number"
        },
        {
            "name": "RegistrationDate",
            "baseName": "RegistrationDate",
            "type": "Date"
        },
        {
            "name": "PhoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        },
        {
            "name": "CashOrdersEnabled",
            "baseName": "CashOrdersEnabled",
            "type": "boolean"
        },
        {
            "name": "CardOrdersEnabled",
            "baseName": "CardOrdersEnabled",
            "type": "boolean"
        },
        {
            "name": "MarketingEnabled",
            "baseName": "MarketingEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Customer.attributeTypeMap;
    }
}

/**
* Customer consent updated
*/
export class CustomerConsentUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Enabled
    */
    'Enabled'?: boolean;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Customer User info
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Enabled",
            "baseName": "Enabled",
            "type": "boolean"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomerConsentUpdatedEvent.attributeTypeMap;
    }
}

/**
* Defines a customer create model
*/
export class CustomerCreateModel {
    /**
    * Customer Phone Number
    */
    'PhoneNumber'?: string;
    /**
    * Customer AppType
    */
    'AppType'?: CustomerCreateModel.AppTypeEnum;
    /**
    * Customer Name
    */
    'Name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PhoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        },
        {
            "name": "AppType",
            "baseName": "AppType",
            "type": "CustomerCreateModel.AppTypeEnum"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomerCreateModel.attributeTypeMap;
    }
}

export namespace CustomerCreateModel {
    export enum AppTypeEnum {
        Unknown = <any> 'Unknown',
        Ios = <any> 'Ios',
        Android = <any> 'Android',
        Web = <any> 'Web',
        Kiosk = <any> 'Kiosk',
        Pos = <any> 'Pos',
        TelephoneCall = <any> 'TelephoneCall',
        Sms = <any> 'Sms',
        PwaAndroid = <any> 'PwaAndroid',
        PwaIos = <any> 'PwaIos',
        Google = <any> 'Google'
    }
}
/**
* Customer created event
*/
export class CustomerCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Customer User info
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomerCreatedEvent.attributeTypeMap;
    }
}

/**
* Defines the order data required for customer driver tracking
*/
export class CustomerDeliveryTrackingOrder {
    /**
    * Order Id
    */
    'OrderId'?: number;
    /**
    * Pretified address string in country format
    */
    'Address'?: string;
    /**
    * Delivery Notes
    */
    'DeliveryNotes'?: string;
    /**
    * Phone number of the store
    */
    'StorePhoneNumber'?: string;
    /**
    * App Icon of the store
    */
    'AppIconUrl'?: string;
    /**
    * Order Tracking Code
    */
    'OrderTrackingCode'?: string;
    /**
    * Payment method description i.e Cash/Card/iDeal/Paypal
    */
    'PaymentMethodDescription'?: string;
    /**
    * Last 4 digits of the card if applicable otherwise null
    */
    'LastFourDigits'?: string;
    /**
    * Order lines of the order
    */
    'OrderLines'?: Array<CustomerDeliveryTrackingOrderLine>;
    /**
    * Total amount for the order including tax
    */
    'TotalAmount'?: number;
    /**
    * Currency
    */
    'Currency'?: CustomerDeliveryTrackingOrder.CurrencyEnum;
    /**
    * Customer Location Latitude
    */
    'Latitude'?: number;
    /**
    * Customer Location Longitude
    */
    'Longitude'?: number;
    /**
    * Order placed time
    */
    'Placed'?: Date;
    /**
    * Order requested for
    */
    'RequestedFor'?: Date;
    /**
    * Driver Id
    */
    'DriverId'?: number;
    /**
    * Driver Name
    */
    'DriverName'?: string;
    /**
    * Driver Image
    */
    'DriverImage'?: string;
    /**
    * 
    */
    'EstimatedMinutesForDelivery'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "Address",
            "baseName": "Address",
            "type": "string"
        },
        {
            "name": "DeliveryNotes",
            "baseName": "DeliveryNotes",
            "type": "string"
        },
        {
            "name": "StorePhoneNumber",
            "baseName": "StorePhoneNumber",
            "type": "string"
        },
        {
            "name": "AppIconUrl",
            "baseName": "AppIconUrl",
            "type": "string"
        },
        {
            "name": "OrderTrackingCode",
            "baseName": "OrderTrackingCode",
            "type": "string"
        },
        {
            "name": "PaymentMethodDescription",
            "baseName": "PaymentMethodDescription",
            "type": "string"
        },
        {
            "name": "LastFourDigits",
            "baseName": "LastFourDigits",
            "type": "string"
        },
        {
            "name": "OrderLines",
            "baseName": "OrderLines",
            "type": "Array<CustomerDeliveryTrackingOrderLine>"
        },
        {
            "name": "TotalAmount",
            "baseName": "TotalAmount",
            "type": "number"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "CustomerDeliveryTrackingOrder.CurrencyEnum"
        },
        {
            "name": "Latitude",
            "baseName": "Latitude",
            "type": "number"
        },
        {
            "name": "Longitude",
            "baseName": "Longitude",
            "type": "number"
        },
        {
            "name": "Placed",
            "baseName": "Placed",
            "type": "Date"
        },
        {
            "name": "RequestedFor",
            "baseName": "RequestedFor",
            "type": "Date"
        },
        {
            "name": "DriverId",
            "baseName": "DriverId",
            "type": "number"
        },
        {
            "name": "DriverName",
            "baseName": "DriverName",
            "type": "string"
        },
        {
            "name": "DriverImage",
            "baseName": "DriverImage",
            "type": "string"
        },
        {
            "name": "EstimatedMinutesForDelivery",
            "baseName": "EstimatedMinutesForDelivery",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CustomerDeliveryTrackingOrder.attributeTypeMap;
    }
}

export namespace CustomerDeliveryTrackingOrder {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Defines an order line for driver tracking
*/
export class CustomerDeliveryTrackingOrderLine {
    /**
    * Item name from the order
    */
    'ItemName'?: string;
    /**
    * Selected option names
    */
    'SelectedOptions'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ItemName",
            "baseName": "ItemName",
            "type": "string"
        },
        {
            "name": "SelectedOptions",
            "baseName": "SelectedOptions",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CustomerDeliveryTrackingOrderLine.attributeTypeMap;
    }
}

/**
* Customer summary
*/
export class CustomerSummary {
    /**
    * Customer identifier
    */
    'Id'?: number;
    /**
    * Customer name
    */
    'Name'?: string;
    /**
    * Customer email address
    */
    'EmailAddress'?: string;
    /**
    * Customer local phone number
    */
    'PhoneNumberLocalFormat'?: string;
    /**
    * Customer phone number
    */
    'PhoneNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "EmailAddress",
            "baseName": "EmailAddress",
            "type": "string"
        },
        {
            "name": "PhoneNumberLocalFormat",
            "baseName": "PhoneNumberLocalFormat",
            "type": "string"
        },
        {
            "name": "PhoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomerSummary.attributeTypeMap;
    }
}

/**
* Defines a customer update model
*/
export class CustomerUpdateModel {
    /**
    * Customer can place cash orders
    */
    'CashOrdersEnabled'?: boolean;
    /**
    * Customer can place card orders
    */
    'CardOrdersEnabled'?: boolean;
    /**
    * Customer can receive marketing
    */
    'MarketingEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CashOrdersEnabled",
            "baseName": "CashOrdersEnabled",
            "type": "boolean"
        },
        {
            "name": "CardOrdersEnabled",
            "baseName": "CardOrdersEnabled",
            "type": "boolean"
        },
        {
            "name": "MarketingEnabled",
            "baseName": "MarketingEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CustomerUpdateModel.attributeTypeMap;
    }
}

/**
* Customer updated event
*/
export class CustomerUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Customer User info
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomerUpdatedEvent.attributeTypeMap;
    }
}

/**
* SSO Embed URL Information
*/
export class DashboardEmbed {
    /**
    * SSO URL generated by Flipdish to embed Looker dashboard
    */
    'EmbedUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EmbedUrl",
            "baseName": "EmbedUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DashboardEmbed.attributeTypeMap;
    }
}

/**
* Delivery location
*/
export class DeliveryLocation {
    /**
    * Geo cordinate
    */
    'Coordinates'?: Coordinates;
    /**
    * Building
    */
    'Building'?: string;
    /**
    * Street
    */
    'Street'?: string;
    /**
    * Town
    */
    'Town'?: string;
    /**
    * Post code
    */
    'PostCode'?: string;
    /**
    * Delivery instructions
    */
    'DeliveryInstructions'?: string;
    /**
    * Formatted, pretty address string
    */
    'PrettyAddressString'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Coordinates",
            "baseName": "Coordinates",
            "type": "Coordinates"
        },
        {
            "name": "Building",
            "baseName": "Building",
            "type": "string"
        },
        {
            "name": "Street",
            "baseName": "Street",
            "type": "string"
        },
        {
            "name": "Town",
            "baseName": "Town",
            "type": "string"
        },
        {
            "name": "PostCode",
            "baseName": "PostCode",
            "type": "string"
        },
        {
            "name": "DeliveryInstructions",
            "baseName": "DeliveryInstructions",
            "type": "string"
        },
        {
            "name": "PrettyAddressString",
            "baseName": "PrettyAddressString",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeliveryLocation.attributeTypeMap;
    }
}

/**
* Delivery Zone
*/
export class DeliveryZone {
    /**
    * Delivery Fee Area Id
    */
    'Id'?: number;
    /**
    * Delivery Fee charged to store
    */
    'FeeChargedToStore'?: number;
    /**
    * Delivery fee (will not be set below 0)
    */
    'DeliveryFee'?: number;
    /**
    * Minimum delivery order amount (will not be set below 0)
    */
    'MinimumDeliveryOrderAmount'?: number;
    /**
    * Spatial data in Well Known Text format  We also support CIRCLE((0 0, 200)) - (centerLong centerLat, radius in m)
    */
    'WellKnownText'?: string;
    /**
    * Is delivery zone enabled
    */
    'IsEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "FeeChargedToStore",
            "baseName": "FeeChargedToStore",
            "type": "number"
        },
        {
            "name": "DeliveryFee",
            "baseName": "DeliveryFee",
            "type": "number"
        },
        {
            "name": "MinimumDeliveryOrderAmount",
            "baseName": "MinimumDeliveryOrderAmount",
            "type": "number"
        },
        {
            "name": "WellKnownText",
            "baseName": "WellKnownText",
            "type": "string"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return DeliveryZone.attributeTypeMap;
    }
}

/**
* Delivery Zone Base
*/
export class DeliveryZoneBase {
    /**
    * Delivery fee (will not be set below 0)
    */
    'DeliveryFee'?: number;
    /**
    * Minimum delivery order amount (will not be set below 0)
    */
    'MinimumDeliveryOrderAmount'?: number;
    /**
    * Spatial data in Well Known Text format  We also support CIRCLE((0 0, 200)) - (centerLong centerLat, radius in m)
    */
    'WellKnownText'?: string;
    /**
    * Is delivery zone enabled
    */
    'IsEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeliveryFee",
            "baseName": "DeliveryFee",
            "type": "number"
        },
        {
            "name": "MinimumDeliveryOrderAmount",
            "baseName": "MinimumDeliveryOrderAmount",
            "type": "number"
        },
        {
            "name": "WellKnownText",
            "baseName": "WellKnownText",
            "type": "string"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return DeliveryZoneBase.attributeTypeMap;
    }
}

/**
* Delivery Zone Created Event
*/
export class DeliveryZoneCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which created delivery zone for this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Created Delivery Zone
    */
    'DeliveryZone'?: DeliveryZone;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "DeliveryZone",
            "baseName": "DeliveryZone",
            "type": "DeliveryZone"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeliveryZoneCreatedEvent.attributeTypeMap;
    }
}

/**
* Delivery Zone Deleted Event
*/
export class DeliveryZoneDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which deleted delivery zone for this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Deleted Delivery Zone
    */
    'DeliveryZone'?: DeliveryZone;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "DeliveryZone",
            "baseName": "DeliveryZone",
            "type": "DeliveryZone"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeliveryZoneDeletedEvent.attributeTypeMap;
    }
}

/**
* Delivery Zone Updated Event
*/
export class DeliveryZoneUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which updated delivery zone for this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Updated Delivery Zone
    */
    'DeliveryZone'?: DeliveryZone;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "DeliveryZone",
            "baseName": "DeliveryZone",
            "type": "DeliveryZone"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeliveryZoneUpdatedEvent.attributeTypeMap;
    }
}

export class DepositReturnFeesSummary {
    'Count'?: number;
    'Fee'?: number;
    'Total'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Count",
            "baseName": "Count",
            "type": "number"
        },
        {
            "name": "Fee",
            "baseName": "Fee",
            "type": "number"
        },
        {
            "name": "Total",
            "baseName": "Total",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return DepositReturnFeesSummary.attributeTypeMap;
    }
}

/**
* Device settings for Hydra
*/
export class DeviceSettings {
    /**
    * Gets or sets the device volume
    */
    'Volume': number;
    /**
    * Gets or sets the font size used on the device
    */
    'FontSize': number;
    /**
    * Gets or sets the display brightness on the device
    */
    'Brightness': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Volume",
            "baseName": "Volume",
            "type": "number"
        },
        {
            "name": "FontSize",
            "baseName": "FontSize",
            "type": "number"
        },
        {
            "name": "Brightness",
            "baseName": "Brightness",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return DeviceSettings.attributeTypeMap;
    }
}

/**
* Holds the information for the A and CNAME Records of a domain.
*/
export class DnsRecordInformation {
    /**
    * indicates whether the CNAME record is ready or not.
    */
    'IsCNameReady'?: boolean;
    /**
    * indicates whether the A record is ready or not.
    */
    'IsAReady'?: boolean;
    /**
    * indicates whether the API CNAME record is ready or not.
    */
    'IsApiCNameReady'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IsCNameReady",
            "baseName": "IsCNameReady",
            "type": "boolean"
        },
        {
            "name": "IsAReady",
            "baseName": "IsAReady",
            "type": "boolean"
        },
        {
            "name": "IsApiCNameReady",
            "baseName": "IsApiCNameReady",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return DnsRecordInformation.attributeTypeMap;
    }
}

/**
* The DNS for the Hostname verified
*/
export class DnsVerifiedEvent {
    /**
    * Description
    */
    'Hostname'?: string;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Hostname",
            "baseName": "Hostname",
            "type": "string"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DnsVerifiedEvent.attributeTypeMap;
    }
}

/**
* Driver Login model
*/
export class DriverLoginModel {
    /**
    * Phone number
    */
    'PhoneNumber': string;
    /**
    * Code
    */
    'Code': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PhoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        },
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DriverLoginModel.attributeTypeMap;
    }
}

/**
* Driver Request Login Pin model
*/
export class DriverRequestLoginPinModel {
    /**
    * Email address
    */
    'PhoneNumber': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PhoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DriverRequestLoginPinModel.attributeTypeMap;
    }
}

export class DuringOrderPromotionOptionsDm {
    'DuringOrderPromotionType'?: DuringOrderPromotionOptionsDm.DuringOrderPromotionTypeEnum;
    'MinSmsShareCount'?: number;
    'FreeCokeCount'?: number;
    'PromotionPeriodSeconds'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DuringOrderPromotionType",
            "baseName": "DuringOrderPromotionType",
            "type": "DuringOrderPromotionOptionsDm.DuringOrderPromotionTypeEnum"
        },
        {
            "name": "MinSmsShareCount",
            "baseName": "MinSmsShareCount",
            "type": "number"
        },
        {
            "name": "FreeCokeCount",
            "baseName": "FreeCokeCount",
            "type": "number"
        },
        {
            "name": "PromotionPeriodSeconds",
            "baseName": "PromotionPeriodSeconds",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return DuringOrderPromotionOptionsDm.attributeTypeMap;
    }
}

export namespace DuringOrderPromotionOptionsDm {
    export enum DuringOrderPromotionTypeEnum {
        None = <any> 'None',
        BumpFreeChocolate = <any> 'BumpFreeChocolate',
        BumpFreeCoke = <any> 'BumpFreeCoke',
        SmsInviteFreeChocolate = <any> 'SmsInviteFreeChocolate',
        SmsInviteFreeCoke = <any> 'SmsInviteFreeCoke'
    }
}
export class DynamicFormField {
    'Identifier'?: string;
    'Label'?: string;
    'Placeholder'?: string;
    'Rules'?: DynamicFormRules;
    'Mapping'?: { [key: string]: string; };
    'Modifiers'?: Array<string>;
    'Value'?: any;
    'Scopes'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Identifier",
            "baseName": "Identifier",
            "type": "string"
        },
        {
            "name": "Label",
            "baseName": "Label",
            "type": "string"
        },
        {
            "name": "Placeholder",
            "baseName": "Placeholder",
            "type": "string"
        },
        {
            "name": "Rules",
            "baseName": "Rules",
            "type": "DynamicFormRules"
        },
        {
            "name": "Mapping",
            "baseName": "Mapping",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "Modifiers",
            "baseName": "Modifiers",
            "type": "Array<string>"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "any"
        },
        {
            "name": "Scopes",
            "baseName": "Scopes",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DynamicFormField.attributeTypeMap;
    }
}

export class DynamicFormFieldOption {
    'Display'?: string;
    'Value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Display",
            "baseName": "Display",
            "type": "string"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DynamicFormFieldOption.attributeTypeMap;
    }
}

export class DynamicFormRule {
    'Value'?: any;
    'Message'?: string;
    'Scopes'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Value",
            "baseName": "Value",
            "type": "any"
        },
        {
            "name": "Message",
            "baseName": "Message",
            "type": "string"
        },
        {
            "name": "Scopes",
            "baseName": "Scopes",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DynamicFormRule.attributeTypeMap;
    }
}

export class DynamicFormRules {
    'MaxLength'?: DynamicFormRule;
    'MinLength'?: DynamicFormRule;
    'Required'?: DynamicFormRule;
    'Pattern'?: DynamicFormRule;
    'Predefined'?: Array<DynamicFormFieldOption>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MaxLength",
            "baseName": "MaxLength",
            "type": "DynamicFormRule"
        },
        {
            "name": "MinLength",
            "baseName": "MinLength",
            "type": "DynamicFormRule"
        },
        {
            "name": "Required",
            "baseName": "Required",
            "type": "DynamicFormRule"
        },
        {
            "name": "Pattern",
            "baseName": "Pattern",
            "type": "DynamicFormRule"
        },
        {
            "name": "Predefined",
            "baseName": "Predefined",
            "type": "Array<DynamicFormFieldOption>"
        }    ];

    static getAttributeTypeMap() {
        return DynamicFormRules.attributeTypeMap;
    }
}

/**
* Order Terminal Notification
*/
export class EmvNotificationEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Notification Sent
    */
    'Notification'?: string;
    /**
    * Order
    */
    'Order'?: Order;
    /**
    * TerminalId
    */
    'TerminalId'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Expirey Date
    */
    'ExpDate'?: string;
    /**
    * Card Type
    */
    'CardType'?: string;
    /**
    * Payment Method
    */
    'PaymentMethod'?: string;
    /**
    * Masked Account Number
    */
    'AccountNumber'?: string;
    /**
    * Auth Code
    */
    'AuthCode'?: string;
    /**
    * Payment Provider Message
    */
    'ProviderMessage'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Notification",
            "baseName": "Notification",
            "type": "string"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "Order"
        },
        {
            "name": "TerminalId",
            "baseName": "TerminalId",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "ExpDate",
            "baseName": "ExpDate",
            "type": "string"
        },
        {
            "name": "CardType",
            "baseName": "CardType",
            "type": "string"
        },
        {
            "name": "PaymentMethod",
            "baseName": "PaymentMethod",
            "type": "string"
        },
        {
            "name": "AccountNumber",
            "baseName": "AccountNumber",
            "type": "string"
        },
        {
            "name": "AuthCode",
            "baseName": "AuthCode",
            "type": "string"
        },
        {
            "name": "ProviderMessage",
            "baseName": "ProviderMessage",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EmvNotificationEvent.attributeTypeMap;
    }
}

/**
* EMV Payment Terminal
*/
export class EmvTerminal {
    /**
    * Flipdish Identifier of Terminal
    */
    'EmvTerminalId'?: number;
    /**
    * External Identifier of Terminal
    */
    'TerminalId'?: string;
    /**
    * URL at which terminal can be accessed
    */
    'Url'?: string;
    /**
    * TOKEN required to access terminal
    */
    'Token'?: string;
    /**
    * Identifies us to Provider
    */
    'SoftwareHouseId'?: string;
    /**
    * Identifies installer of terminal
    */
    'InstallerId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EmvTerminalId",
            "baseName": "EmvTerminalId",
            "type": "number"
        },
        {
            "name": "TerminalId",
            "baseName": "TerminalId",
            "type": "string"
        },
        {
            "name": "Url",
            "baseName": "Url",
            "type": "string"
        },
        {
            "name": "Token",
            "baseName": "Token",
            "type": "string"
        },
        {
            "name": "SoftwareHouseId",
            "baseName": "SoftwareHouseId",
            "type": "string"
        },
        {
            "name": "InstallerId",
            "baseName": "InstallerId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EmvTerminal.attributeTypeMap;
    }
}

/**
* EMV Payment Terminal
*/
export class EmvTerminalWithAssignments {
    /**
    * Flipdish Internal identifier of the Terminal
    */
    'EmvTerminalId'?: string;
    /**
    * External Identifier of the Terminal
    */
    'TerminalId'?: string;
    /**
    * true if the terminal is assigned to a hydra device (e.g. a kiosk)
    */
    'IsAssignedToHydraDevice'?: boolean;
    /**
    * hydra device id (null if the terminal is not assigned to any hydra device)
    */
    'HydraConfigId'?: number;
    /**
    * external hydra device id (null if the terminal is not assigned to any hydra device)
    */
    'HydraDeviceId'?: string;
    /**
    * hydra device name (null if the terminal is not assigned to any hydra device)
    */
    'HydraName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EmvTerminalId",
            "baseName": "EmvTerminalId",
            "type": "string"
        },
        {
            "name": "TerminalId",
            "baseName": "TerminalId",
            "type": "string"
        },
        {
            "name": "IsAssignedToHydraDevice",
            "baseName": "IsAssignedToHydraDevice",
            "type": "boolean"
        },
        {
            "name": "HydraConfigId",
            "baseName": "HydraConfigId",
            "type": "number"
        },
        {
            "name": "HydraDeviceId",
            "baseName": "HydraDeviceId",
            "type": "string"
        },
        {
            "name": "HydraName",
            "baseName": "HydraName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EmvTerminalWithAssignments.attributeTypeMap;
    }
}

/**
* 
*/
export class EventSearchResult {
    /**
    * App Created Event
    */
    'AppCreatedEvent'?: Array<AppCreatedEvent>;
    /**
    * App Updated Event
    */
    'AppUpdatedEvent'?: Array<AppUpdatedEvent>;
    /**
    * Client Analytics events
    */
    'AnalyticsClientEvent'?: Array<AnalyticsClientEvent>;
    /**
    * Order accepted events
    */
    'OrderAcceptedEvent'?: Array<OrderAcceptedEvent>;
    /**
    * Order dispatched events
    */
    'OrderDispatchedEvent'?: Array<OrderDispatchedEvent>;
    /**
    * Order delivery tracking created events
    */
    'OrderCustomerTrackingCreatedEvent'?: Array<OrderCustomerTrackingCreatedEvent>;
    /**
    * Order delivery tracking updated events
    */
    'OrderDeliveryTrackingStatusUpdatedEvent'?: Array<OrderDeliveryTrackingStatusUpdatedEvent>;
    /**
    * Order Batch published event
    */
    'OrderBatchPublishedEvent'?: Array<OrderBatchPublishedEvent>;
    /**
    * Order created events
    */
    'OrderCreatedEvent'?: Array<OrderCreatedEvent>;
    /**
    * Order rating updated events
    */
    'OrderRatingUpdatedEvent'?: Array<OrderRatingUpdatedEvent>;
    /**
    * Order refunded events
    */
    'OrderRefundedEvent'?: Array<OrderRefundedEvent>;
    /**
    * Order rejected events
    */
    'OrderRejectedEvent'?: Array<OrderRejectedEvent>;
    /**
    * Order tip updated events
    */
    'OrderTipUpdatedEvent'?: Array<OrderTipUpdatedEvent>;
    /**
    * Order Terminal Notification events
    */
    'OrderTerminalNotifications'?: Array<EmvNotificationEvent>;
    /**
    * Store created events
    */
    'StoreCreatedEvent'?: Array<StoreCreatedEvent>;
    /**
    * Store deleted events
    */
    'StoreDeletedEvent'?: Array<StoreDeletedEvent>;
    /**
    * Store address updated events
    */
    'StoreAddressUpdatedEvent'?: Array<StoreAddressUpdatedEvent>;
    /**
    * Store kiosk setting updated events
    */
    'StoreKioskSettingUpdatedEvent'?: Array<StoreKioskSettingUpdatedEvent>;
    /**
    * Store delivery zone created events
    */
    'DeliveryZoneCreatedEvent'?: Array<DeliveryZoneCreatedEvent>;
    /**
    * Store delivery zone updated events
    */
    'DeliveryZoneUpdatedEvent'?: Array<DeliveryZoneUpdatedEvent>;
    /**
    * Store delivery zone deleted events
    */
    'DeliveryZoneDeletedEvent'?: Array<DeliveryZoneDeletedEvent>;
    /**
    * Store opening hours updated events
    */
    'StoreOpeningHoursUpdatedEvent'?: Array<StoreOpeningHoursUpdatedEvent>;
    /**
    * Store opening hours updated events
    */
    'StoreMenuAssignedEvent'?: Array<StoreMenuAssignedEvent>;
    /**
    * Store business hours override created events
    */
    'StoreBusinessHoursOverrideCreatedEvent'?: Array<StoreBusinessHoursOverrideCreatedEvent>;
    /**
    * Store business hours override deleted events
    */
    'StoreBusinessHoursOverrideDeletedEvent'?: Array<StoreBusinessHoursOverrideDeletedEvent>;
    /**
    * Store archived events
    */
    'StoreArchivedEvent'?: Array<StoreArchivedEvent>;
    /**
    * Store unarchived events
    */
    'StoreUnarchivedEvent'?: Array<StoreUnarchivedEvent>;
    /**
    * Store published events
    */
    'StorePublishedEvent'?: Array<StorePublishedEvent>;
    /**
    * Store unpublished events
    */
    'StoreUnpublishedEvent'?: Array<StoreUnpublishedEvent>;
    /**
    * Store updated events
    */
    'StoreUpdatedEvent'?: Array<StoreUpdatedEvent>;
    /**
    * Store updated events
    */
    'StorePreOrderConfigUpdatedEvent'?: Array<StorePreOrderConfigUpdatedEvent>;
    /**
    * Store logo created events
    */
    'StoreLogoCreatedEvent'?: Array<StoreLogoCreatedEvent>;
    /**
    * Store logo updated events
    */
    'StoreLogoUpdatedEvent'?: Array<StoreLogoUpdatedEvent>;
    /**
    * Store logo deleted events
    */
    'StoreLogoDeletedEvent'?: Array<StoreLogoDeletedEvent>;
    /**
    * Menu created events
    */
    'MenuCreatedEvent'?: Array<MenuCreatedEvent>;
    /**
    * Menu async creation completed events
    */
    'MenuAsyncCreationCompletedEvent'?: Array<MenuAsyncCreationCompletedEvent>;
    /**
    * Menu updated events
    */
    'MenuUpdatedEvent'?: Array<MenuUpdatedEvent>;
    /**
    * Menu uploaded events
    */
    'MenuUploadedEvent'?: Array<MenuUploadedEvent>;
    /**
    * Menu bulk events
    */
    'MenuBulkEditEvent'?: Array<MenuBulkEditEvent>;
    /**
    * Menu section created events
    */
    'MenuSectionCreatedEvent'?: Array<MenuSectionCreatedEvent>;
    /**
    * Menu section updated events
    */
    'MenuSectionUpdatedEvent'?: Array<MenuSectionUpdatedEvent>;
    /**
    * Menu section deleted events
    */
    'MenuSectionDeletedEvent'?: Array<MenuSectionDeletedEvent>;
    /**
    * Menu section item created events
    */
    'MenuSectionItemCreatedEvent'?: Array<MenuSectionItemCreatedEvent>;
    /**
    * Menu section item updated events
    */
    'MenuSectionItemUpdatedEvent'?: Array<MenuSectionItemUpdatedEvent>;
    /**
    * Menu section item deleted events
    */
    'MenuSectionItemDeletedEvent'?: Array<MenuSectionItemDeletedEvent>;
    /**
    * Menu item option set created events
    */
    'MenuItemOptionSetCreatedEvent'?: Array<MenuItemOptionSetCreatedEvent>;
    /**
    * Menu item option set  updated events
    */
    'MenuItemOptionSetUpdatedEvent'?: Array<MenuItemOptionSetUpdatedEvent>;
    /**
    * Menu item option set deleted events
    */
    'MenuItemOptionSetDeletedEvent'?: Array<MenuItemOptionSetDeletedEvent>;
    /**
    * Menu item option set item created events
    */
    'MenuItemOptionSetItemCreatedEvent'?: Array<MenuItemOptionSetItemCreatedEvent>;
    /**
    * Menu item option set item updated events
    */
    'MenuItemOptionSetItemUpdatedEvent'?: Array<MenuItemOptionSetItemUpdatedEvent>;
    /**
    * Menu item option set item deleted events
    */
    'MenuItemOptionSetItemDeletedEvent'?: Array<MenuItemOptionSetItemDeletedEvent>;
    /**
    * Menu checkpoint created event
    */
    'MenuCheckpointCreatedEvent'?: Array<MenuCheckpointCreatedEvent>;
    /**
    * Store group created events
    */
    'StoreGroupCreatedEvent'?: Array<StoreGroupCreatedEvent>;
    /**
    * Store group updated events
    */
    'StoreGroupUpdatedEvent'?: Array<StoreGroupUpdatedEvent>;
    /**
    * Store group deleted events
    */
    'StoreGroupDeletedEvent'?: Array<StoreGroupDeletedEvent>;
    /**
    * Customer created events
    */
    'CustomerCreatedEvent'?: Array<CustomerCreatedEvent>;
    /**
    * Customer updated events
    */
    'CustomerUpdatedEvent'?: Array<CustomerUpdatedEvent>;
    /**
    * Customer consent updated events
    */
    'CustomerConsentUpdatedEvent'?: Array<CustomerConsentUpdatedEvent>;
    /**
    * Webhook subscription created events
    */
    'WebhookSubscriptionCreatedEvent'?: Array<WebhookSubscriptionCreatedEvent>;
    /**
    * Webhook subscription updated events
    */
    'WebhookSubscriptionUpdatedEvent'?: Array<WebhookSubscriptionUpdatedEvent>;
    /**
    * Webhook subscription deleted events
    */
    'WebhookSubscriptionDeletedEvent'?: Array<WebhookSubscriptionDeletedEvent>;
    /**
    * Printer turned ON event
    */
    'PrinterTurnedOnEvent'?: Array<PrinterTurnedOnEvent>;
    /**
    * Printer turned OFF event
    */
    'PrinterTurnedOffEvent'?: Array<PrinterTurnedOffEvent>;
    /**
    * Printer assigned to store event
    */
    'PrinterAssignedToStoreEvent'?: Array<PrinterAssignedToStoreEvent>;
    /**
    * Printer unassigned from store event
    */
    'PrinterUnassignedFromStoreEvent'?: Array<PrinterUnassignedFromStoreEvent>;
    /**
    * Phone call started event
    */
    'PhoneCallStartedEvent'?: Array<PhoneCallStartedEvent>;
    /**
    * Phone call ended event
    */
    'PhoneCallEndedEvent'?: Array<PhoneCallEndedEvent>;
    /**
    * Telephony config updated event
    */
    'TelephonyConfigUpdatedEvent'?: Array<TelephonyConfigUpdatedEvent>;
    /**
    * Channel stores updated event
    */
    'ChannelStoresUpdatedEvent'?: Array<ChannelStoresUpdatedEvent>;
    /**
    * Loyalty campaign created event
    */
    'LoyaltyCampaignCreatedEvent'?: Array<LoyaltyCampaignCreatedEvent>;
    /**
    * Loyalty campaign deleted event
    */
    'LoyaltyCampaignDeletedEvent'?: Array<LoyaltyCampaignDeletedEvent>;
    /**
    * Loyalty campaign updated event
    */
    'LoyaltyCampaignUpdatedEvent'?: Array<LoyaltyCampaignUpdatedEvent>;
    /**
    * Retention campaign created event
    */
    'RetentionCampaignCreatedEvent'?: Array<RetentionCampaignCreatedEvent>;
    /**
    * Retention campaign deleted event
    */
    'RetentionCampaignDeletedEvent'?: Array<RetentionCampaignDeletedEvent>;
    /**
    * Retention campaign updated event
    */
    'RetentionCampaignUpdatedEvent'?: Array<RetentionCampaignUpdatedEvent>;
    /**
    * Sms received event
    */
    'SmsReceivedEvent'?: Array<SmsReceivedEvent>;
    /**
    * User login event
    */
    'UserLoginEvent'?: Array<UserLoginEvent>;
    /**
    * User created event
    */
    'UserCreatedEvent'?: Array<UserCreatedEvent>;
    /**
    * User updated event
    */
    'UserUpdatedEvent'?: Array<UserUpdatedEvent>;
    /**
    * User deleted event
    */
    'UserDeletedEvent'?: Array<UserDeletedEvent>;
    /**
    * User password created event
    */
    'UserCreatedPasswordEvent'?: Array<UserPasswordCreatedEvent>;
    /**
    * User answered signup questions event
    */
    'UserAnsweredSignupQuestionsEvent'?: Array<UserAnsweredSignupQuestionsEvent>;
    /**
    * Voucher created event
    */
    'VoucherCreatedEvent'?: Array<VoucherCreatedEvent>;
    /**
    * Voucher updated event
    */
    'VoucherUpdatedEvent'?: Array<VoucherUpdatedEvent>;
    /**
    * Voucher deleted event
    */
    'VoucherDeletedEvent'?: Array<VoucherDeletedEvent>;
    /**
    * Teammate invite sent event
    */
    'TeammateInviteSentEvent'?: Array<TeammateInviteSentEvent>;
    /**
    * Teammate invite accepted event
    */
    'TeammateInviteAcceptedEvent'?: Array<TeammateInviteAcceptedEvent>;
    /**
    * Teammate updated event
    */
    'TeammateUpdatedEvent'?: Array<TeammateUpdatedEvent>;
    /**
    * Teammate deleted event
    */
    'TeammateDeletedEvent'?: Array<TeammateDeletedEvent>;
    /**
    * Bank account created event
    */
    'BankAccountCreatedEvent'?: Array<BankAccountCreatedEvent>;
    /**
    * Bank account updated event
    */
    'BankAccountUpdatedEvent'?: Array<BankAccountUpdatedEvent>;
    /**
    * Bank account updated event
    */
    'BankAccountDeletedEvent'?: Array<BankAccountDeletedEvent>;
    /**
    * Bank account assigned event
    */
    'BankAccountAssignedEvent'?: Array<BankAccountAssignedEvent>;
    /**
    * Hydra assigned event
    */
    'HydraAssignedEvent'?: Array<HydraAssignedEvent>;
    /**
    * Hydra reset requested event
    */
    'HydraRequestResetEvent'?: Array<HydraRequestResetEvent>;
    /**
    * Hydra store assigned event
    */
    'HydraStoreAssignedEvent'?: Array<HydraStoreAssignedEvent>;
    /**
    * Hydra store unassigned
    */
    'HydraStoreUnassignedEvent'?: Array<HydraStoreUnassignedEvent>;
    /**
    * Hydra settings changed event
    */
    'HydraSettingChangedEvent'?: Array<HydraSettingChangedEvent>;
    /**
    * Hydra un-assigned event
    */
    'HydraUnAssignedEvent'?: Array<HydraUnAssignedEvent>;
    /**
    * Hydra connection state change
    */
    'HydraConnectionStatusChangedEvent'?: Array<HydraConnectionStatusChangedEvent>;
    /**
    * Bluetooth Pairing Mode initiated
    */
    'KioskBluetoothPairingModeEvent'?: Array<KioskBluetoothPairingModeEvent>;
    /**
    * Bluetooth Unpairing Mode initiated
    */
    'KioskBluetoothUnpairingModeEvent'?: Array<KioskBluetoothUnpairingModeEvent>;
    /**
    * Bluetooth Terminal Unpaired with Kiosk
    */
    'KioskBluetoothTerminalUnpairedEvent'?: Array<KioskBluetoothTerminalUnpairedEvent>;
    /**
    * Terminal actionstate change
    */
    'KioskTerminalActionStateChangedEvent'?: Array<KioskTerminalActionStateChangedEvent>;
    /**
    * Bluetooth Terminal Updated
    */
    'KioskBluetoothTerminalUpdatedEvent'?: Array<KioskBluetoothTerminalUpdatedEvent>;
    /**
    * Trigger bluetooth payment terminal update checker
    */
    'KioskBluetoothTerminalInitiateUpdateCheckEvent'?: Array<KioskBluetoothTerminalInitiateUpdateCheckEvent>;
    /**
    * Bluetooth Terminal Initiate Update
    */
    'KioskBluetoothInstallUpdateInitiateEvent'?: Array<KioskBluetoothInstallUpdateInitiateEvent>;
    /**
    * Bluetooth Terminal Cancel Update Install
    */
    'KioskBluetoothTerminalCancelUpdateEvent'?: Array<KioskBluetoothTerminalCancelUpdateEvent>;
    /**
    * Bluetooth Payment Terminal Firmware Version Status Info
    */
    'KioskBluetoothTerminalFirmwareVersionStatusEvent'?: Array<KioskBluetoothTerminalFirmwareVersionStatusEvent>;
    /**
    * Bluetooth Terminal Update Installation Status
    */
    'KioskBluetoothTerminalInstallationStatusEvent'?: Array<KioskBluetoothTerminalInstallationStatusEvent>;
    /**
    * Push notification scheduled event
    */
    'PushNotificationScheduledEvent'?: Array<PushNotificationScheduledEvent>;
    /**
    * Push notification sent event
    */
    'PushNotificationSentEvent'?: Array<PushNotificationSentEvent>;
    /**
    * Push notification deleted event
    */
    'PushNotificationDeletedEvent'?: Array<PushNotificationDeletedEvent>;
    /**
    * DNS Verified
    */
    'DnsVerifiedEvent'?: Array<DnsVerifiedEvent>;
    /**
    * Certificate created
    */
    'CertificateCreatedEvent'?: Array<CertificateCreatedEvent>;
    /**
    * Certificate renewed
    */
    'CertificateRenewedEvent'?: Array<CertificateRenewedEvent>;
    /**
    * Panacea vanity url updated
    */
    'WebsiteVanityUrlUpdatedEvent'?: Array<WebsiteVanityUrlUpdatedEvent>;
    /**
    * Website updated
    */
    'WebsiteUpdatedEvent'?: Array<WebsiteUpdatedEvent>;
    /**
    * Order capacity config updated
    */
    'OrderCapacityUpdatedEvent'?: Array<OrderCapacityConfigUpdatedEvent>;
    /**
    * External event
    */
    'ExternalStoreEvent'?: Array<ExternalStoreEvent>;
    /**
    * Fulfillment status updated event
    */
    'OrderFulfillmentStatusUpdatedEvent'?: Array<OrderFulfillmentStatusUpdatedEvent>;
    /**
    * App Store Config Created
    */
    'AppStoreConfigCreatedEvent'?: Array<AppStoreConfigCreatedEvent>;
    /**
    * App Store Config Updated
    */
    'AppStoreConfigUpdatedEvent'?: Array<AppStoreConfigUpdatedEvent>;
    /**
    * App Store Config Deleted
    */
    'AppStoreConfigDeletedEvent'?: Array<AppStoreConfigDeletedEvent>;
    /**
    * App Store Subscription Change Job Updated
    */
    'AppStoreSubscriptionChangeJobUpdatedEvent'?: Array<AppStoreSubscriptionChangeJobUpdatedEvent>;
    /**
    * Catalog Item Created
    */
    'CatalogItemCreatedEvent'?: Array<CatalogItemCreatedEvent>;
    /**
    * Catalog Item Updated
    */
    'CatalogItemUpdatedEvent'?: Array<CatalogItemUpdatedEvent>;
    /**
    * Catalog Item Archived
    */
    'CatalogItemArchivedEvent'?: Array<CatalogItemArchivedEvent>;
    /**
    * Catalog Group Created
    */
    'CatalogGroupCreatedEvent'?: Array<CatalogGroupCreatedEvent>;
    /**
    * Catalog Group Updated
    */
    'CatalogGroupUpdatedEvent'?: Array<CatalogGroupUpdatedEvent>;
    /**
    * Catalog Group Archived
    */
    'CatalogGroupArchivedEvent'?: Array<CatalogGroupArchivedEvent>;
    /**
    * Store Tip Updated Event
    */
    'StoreTipUpdatedEvent'?: Array<StoreTipUpdatedEvent>;
    /**
    * LocationArea created event
    */
    'LocationAreaCreatedEvent'?: Array<LocationAreaCreatedEvent>;
    /**
    * LocationArea updated event
    */
    'LocationAreaUpdatedEvent'?: Array<LocationAreaUpdatedEvent>;
    /**
    * Location created event
    */
    'LocationCreatedEvent'?: Array<LocationCreatedEvent>;
    /**
    * Location deleted event
    */
    'LocationDeletedEvent'?: Array<LocationDeletedEvent>;
    /**
    * Service Charge Updated Event
    */
    'StoreServiceChargeUpdatedEvent'?: Array<StoreServiceChargeUpdatedEvent>;
    /**
    * Mobile Submission Status Updated Event
    */
    'MobileAppsSubmissionStatusUpdatedEvent'?: Array<MobileAppsSubmissionStatusUpdatedEvent>;
    /**
    * Mobile Submission Updated Event
    */
    'MobileAppsSubmissionUpdatedEvent'?: Array<MobileAppsSubmissionUpdatedEvent>;
    /**
    * Store Fee Config Updated Event
    */
    'StoreFeeConfigUpdatedEvent'?: Array<StoreFeeConfigUpdatedEvent>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AppCreatedEvent",
            "baseName": "AppCreatedEvent",
            "type": "Array<AppCreatedEvent>"
        },
        {
            "name": "AppUpdatedEvent",
            "baseName": "AppUpdatedEvent",
            "type": "Array<AppUpdatedEvent>"
        },
        {
            "name": "AnalyticsClientEvent",
            "baseName": "AnalyticsClientEvent",
            "type": "Array<AnalyticsClientEvent>"
        },
        {
            "name": "OrderAcceptedEvent",
            "baseName": "OrderAcceptedEvent",
            "type": "Array<OrderAcceptedEvent>"
        },
        {
            "name": "OrderDispatchedEvent",
            "baseName": "OrderDispatchedEvent",
            "type": "Array<OrderDispatchedEvent>"
        },
        {
            "name": "OrderCustomerTrackingCreatedEvent",
            "baseName": "OrderCustomerTrackingCreatedEvent",
            "type": "Array<OrderCustomerTrackingCreatedEvent>"
        },
        {
            "name": "OrderDeliveryTrackingStatusUpdatedEvent",
            "baseName": "OrderDeliveryTrackingStatusUpdatedEvent",
            "type": "Array<OrderDeliveryTrackingStatusUpdatedEvent>"
        },
        {
            "name": "OrderBatchPublishedEvent",
            "baseName": "OrderBatchPublishedEvent",
            "type": "Array<OrderBatchPublishedEvent>"
        },
        {
            "name": "OrderCreatedEvent",
            "baseName": "OrderCreatedEvent",
            "type": "Array<OrderCreatedEvent>"
        },
        {
            "name": "OrderRatingUpdatedEvent",
            "baseName": "OrderRatingUpdatedEvent",
            "type": "Array<OrderRatingUpdatedEvent>"
        },
        {
            "name": "OrderRefundedEvent",
            "baseName": "OrderRefundedEvent",
            "type": "Array<OrderRefundedEvent>"
        },
        {
            "name": "OrderRejectedEvent",
            "baseName": "OrderRejectedEvent",
            "type": "Array<OrderRejectedEvent>"
        },
        {
            "name": "OrderTipUpdatedEvent",
            "baseName": "OrderTipUpdatedEvent",
            "type": "Array<OrderTipUpdatedEvent>"
        },
        {
            "name": "OrderTerminalNotifications",
            "baseName": "OrderTerminalNotifications",
            "type": "Array<EmvNotificationEvent>"
        },
        {
            "name": "StoreCreatedEvent",
            "baseName": "StoreCreatedEvent",
            "type": "Array<StoreCreatedEvent>"
        },
        {
            "name": "StoreDeletedEvent",
            "baseName": "StoreDeletedEvent",
            "type": "Array<StoreDeletedEvent>"
        },
        {
            "name": "StoreAddressUpdatedEvent",
            "baseName": "StoreAddressUpdatedEvent",
            "type": "Array<StoreAddressUpdatedEvent>"
        },
        {
            "name": "StoreKioskSettingUpdatedEvent",
            "baseName": "StoreKioskSettingUpdatedEvent",
            "type": "Array<StoreKioskSettingUpdatedEvent>"
        },
        {
            "name": "DeliveryZoneCreatedEvent",
            "baseName": "DeliveryZoneCreatedEvent",
            "type": "Array<DeliveryZoneCreatedEvent>"
        },
        {
            "name": "DeliveryZoneUpdatedEvent",
            "baseName": "DeliveryZoneUpdatedEvent",
            "type": "Array<DeliveryZoneUpdatedEvent>"
        },
        {
            "name": "DeliveryZoneDeletedEvent",
            "baseName": "DeliveryZoneDeletedEvent",
            "type": "Array<DeliveryZoneDeletedEvent>"
        },
        {
            "name": "StoreOpeningHoursUpdatedEvent",
            "baseName": "StoreOpeningHoursUpdatedEvent",
            "type": "Array<StoreOpeningHoursUpdatedEvent>"
        },
        {
            "name": "StoreMenuAssignedEvent",
            "baseName": "StoreMenuAssignedEvent",
            "type": "Array<StoreMenuAssignedEvent>"
        },
        {
            "name": "StoreBusinessHoursOverrideCreatedEvent",
            "baseName": "StoreBusinessHoursOverrideCreatedEvent",
            "type": "Array<StoreBusinessHoursOverrideCreatedEvent>"
        },
        {
            "name": "StoreBusinessHoursOverrideDeletedEvent",
            "baseName": "StoreBusinessHoursOverrideDeletedEvent",
            "type": "Array<StoreBusinessHoursOverrideDeletedEvent>"
        },
        {
            "name": "StoreArchivedEvent",
            "baseName": "StoreArchivedEvent",
            "type": "Array<StoreArchivedEvent>"
        },
        {
            "name": "StoreUnarchivedEvent",
            "baseName": "StoreUnarchivedEvent",
            "type": "Array<StoreUnarchivedEvent>"
        },
        {
            "name": "StorePublishedEvent",
            "baseName": "StorePublishedEvent",
            "type": "Array<StorePublishedEvent>"
        },
        {
            "name": "StoreUnpublishedEvent",
            "baseName": "StoreUnpublishedEvent",
            "type": "Array<StoreUnpublishedEvent>"
        },
        {
            "name": "StoreUpdatedEvent",
            "baseName": "StoreUpdatedEvent",
            "type": "Array<StoreUpdatedEvent>"
        },
        {
            "name": "StorePreOrderConfigUpdatedEvent",
            "baseName": "StorePreOrderConfigUpdatedEvent",
            "type": "Array<StorePreOrderConfigUpdatedEvent>"
        },
        {
            "name": "StoreLogoCreatedEvent",
            "baseName": "StoreLogoCreatedEvent",
            "type": "Array<StoreLogoCreatedEvent>"
        },
        {
            "name": "StoreLogoUpdatedEvent",
            "baseName": "StoreLogoUpdatedEvent",
            "type": "Array<StoreLogoUpdatedEvent>"
        },
        {
            "name": "StoreLogoDeletedEvent",
            "baseName": "StoreLogoDeletedEvent",
            "type": "Array<StoreLogoDeletedEvent>"
        },
        {
            "name": "MenuCreatedEvent",
            "baseName": "MenuCreatedEvent",
            "type": "Array<MenuCreatedEvent>"
        },
        {
            "name": "MenuAsyncCreationCompletedEvent",
            "baseName": "MenuAsyncCreationCompletedEvent",
            "type": "Array<MenuAsyncCreationCompletedEvent>"
        },
        {
            "name": "MenuUpdatedEvent",
            "baseName": "MenuUpdatedEvent",
            "type": "Array<MenuUpdatedEvent>"
        },
        {
            "name": "MenuUploadedEvent",
            "baseName": "MenuUploadedEvent",
            "type": "Array<MenuUploadedEvent>"
        },
        {
            "name": "MenuBulkEditEvent",
            "baseName": "MenuBulkEditEvent",
            "type": "Array<MenuBulkEditEvent>"
        },
        {
            "name": "MenuSectionCreatedEvent",
            "baseName": "MenuSectionCreatedEvent",
            "type": "Array<MenuSectionCreatedEvent>"
        },
        {
            "name": "MenuSectionUpdatedEvent",
            "baseName": "MenuSectionUpdatedEvent",
            "type": "Array<MenuSectionUpdatedEvent>"
        },
        {
            "name": "MenuSectionDeletedEvent",
            "baseName": "MenuSectionDeletedEvent",
            "type": "Array<MenuSectionDeletedEvent>"
        },
        {
            "name": "MenuSectionItemCreatedEvent",
            "baseName": "MenuSectionItemCreatedEvent",
            "type": "Array<MenuSectionItemCreatedEvent>"
        },
        {
            "name": "MenuSectionItemUpdatedEvent",
            "baseName": "MenuSectionItemUpdatedEvent",
            "type": "Array<MenuSectionItemUpdatedEvent>"
        },
        {
            "name": "MenuSectionItemDeletedEvent",
            "baseName": "MenuSectionItemDeletedEvent",
            "type": "Array<MenuSectionItemDeletedEvent>"
        },
        {
            "name": "MenuItemOptionSetCreatedEvent",
            "baseName": "MenuItemOptionSetCreatedEvent",
            "type": "Array<MenuItemOptionSetCreatedEvent>"
        },
        {
            "name": "MenuItemOptionSetUpdatedEvent",
            "baseName": "MenuItemOptionSetUpdatedEvent",
            "type": "Array<MenuItemOptionSetUpdatedEvent>"
        },
        {
            "name": "MenuItemOptionSetDeletedEvent",
            "baseName": "MenuItemOptionSetDeletedEvent",
            "type": "Array<MenuItemOptionSetDeletedEvent>"
        },
        {
            "name": "MenuItemOptionSetItemCreatedEvent",
            "baseName": "MenuItemOptionSetItemCreatedEvent",
            "type": "Array<MenuItemOptionSetItemCreatedEvent>"
        },
        {
            "name": "MenuItemOptionSetItemUpdatedEvent",
            "baseName": "MenuItemOptionSetItemUpdatedEvent",
            "type": "Array<MenuItemOptionSetItemUpdatedEvent>"
        },
        {
            "name": "MenuItemOptionSetItemDeletedEvent",
            "baseName": "MenuItemOptionSetItemDeletedEvent",
            "type": "Array<MenuItemOptionSetItemDeletedEvent>"
        },
        {
            "name": "MenuCheckpointCreatedEvent",
            "baseName": "MenuCheckpointCreatedEvent",
            "type": "Array<MenuCheckpointCreatedEvent>"
        },
        {
            "name": "StoreGroupCreatedEvent",
            "baseName": "StoreGroupCreatedEvent",
            "type": "Array<StoreGroupCreatedEvent>"
        },
        {
            "name": "StoreGroupUpdatedEvent",
            "baseName": "StoreGroupUpdatedEvent",
            "type": "Array<StoreGroupUpdatedEvent>"
        },
        {
            "name": "StoreGroupDeletedEvent",
            "baseName": "StoreGroupDeletedEvent",
            "type": "Array<StoreGroupDeletedEvent>"
        },
        {
            "name": "CustomerCreatedEvent",
            "baseName": "CustomerCreatedEvent",
            "type": "Array<CustomerCreatedEvent>"
        },
        {
            "name": "CustomerUpdatedEvent",
            "baseName": "CustomerUpdatedEvent",
            "type": "Array<CustomerUpdatedEvent>"
        },
        {
            "name": "CustomerConsentUpdatedEvent",
            "baseName": "CustomerConsentUpdatedEvent",
            "type": "Array<CustomerConsentUpdatedEvent>"
        },
        {
            "name": "WebhookSubscriptionCreatedEvent",
            "baseName": "WebhookSubscriptionCreatedEvent",
            "type": "Array<WebhookSubscriptionCreatedEvent>"
        },
        {
            "name": "WebhookSubscriptionUpdatedEvent",
            "baseName": "WebhookSubscriptionUpdatedEvent",
            "type": "Array<WebhookSubscriptionUpdatedEvent>"
        },
        {
            "name": "WebhookSubscriptionDeletedEvent",
            "baseName": "WebhookSubscriptionDeletedEvent",
            "type": "Array<WebhookSubscriptionDeletedEvent>"
        },
        {
            "name": "PrinterTurnedOnEvent",
            "baseName": "PrinterTurnedOnEvent",
            "type": "Array<PrinterTurnedOnEvent>"
        },
        {
            "name": "PrinterTurnedOffEvent",
            "baseName": "PrinterTurnedOffEvent",
            "type": "Array<PrinterTurnedOffEvent>"
        },
        {
            "name": "PrinterAssignedToStoreEvent",
            "baseName": "PrinterAssignedToStoreEvent",
            "type": "Array<PrinterAssignedToStoreEvent>"
        },
        {
            "name": "PrinterUnassignedFromStoreEvent",
            "baseName": "PrinterUnassignedFromStoreEvent",
            "type": "Array<PrinterUnassignedFromStoreEvent>"
        },
        {
            "name": "PhoneCallStartedEvent",
            "baseName": "PhoneCallStartedEvent",
            "type": "Array<PhoneCallStartedEvent>"
        },
        {
            "name": "PhoneCallEndedEvent",
            "baseName": "PhoneCallEndedEvent",
            "type": "Array<PhoneCallEndedEvent>"
        },
        {
            "name": "TelephonyConfigUpdatedEvent",
            "baseName": "TelephonyConfigUpdatedEvent",
            "type": "Array<TelephonyConfigUpdatedEvent>"
        },
        {
            "name": "ChannelStoresUpdatedEvent",
            "baseName": "ChannelStoresUpdatedEvent",
            "type": "Array<ChannelStoresUpdatedEvent>"
        },
        {
            "name": "LoyaltyCampaignCreatedEvent",
            "baseName": "LoyaltyCampaignCreatedEvent",
            "type": "Array<LoyaltyCampaignCreatedEvent>"
        },
        {
            "name": "LoyaltyCampaignDeletedEvent",
            "baseName": "LoyaltyCampaignDeletedEvent",
            "type": "Array<LoyaltyCampaignDeletedEvent>"
        },
        {
            "name": "LoyaltyCampaignUpdatedEvent",
            "baseName": "LoyaltyCampaignUpdatedEvent",
            "type": "Array<LoyaltyCampaignUpdatedEvent>"
        },
        {
            "name": "RetentionCampaignCreatedEvent",
            "baseName": "RetentionCampaignCreatedEvent",
            "type": "Array<RetentionCampaignCreatedEvent>"
        },
        {
            "name": "RetentionCampaignDeletedEvent",
            "baseName": "RetentionCampaignDeletedEvent",
            "type": "Array<RetentionCampaignDeletedEvent>"
        },
        {
            "name": "RetentionCampaignUpdatedEvent",
            "baseName": "RetentionCampaignUpdatedEvent",
            "type": "Array<RetentionCampaignUpdatedEvent>"
        },
        {
            "name": "SmsReceivedEvent",
            "baseName": "SmsReceivedEvent",
            "type": "Array<SmsReceivedEvent>"
        },
        {
            "name": "UserLoginEvent",
            "baseName": "UserLoginEvent",
            "type": "Array<UserLoginEvent>"
        },
        {
            "name": "UserCreatedEvent",
            "baseName": "UserCreatedEvent",
            "type": "Array<UserCreatedEvent>"
        },
        {
            "name": "UserUpdatedEvent",
            "baseName": "UserUpdatedEvent",
            "type": "Array<UserUpdatedEvent>"
        },
        {
            "name": "UserDeletedEvent",
            "baseName": "UserDeletedEvent",
            "type": "Array<UserDeletedEvent>"
        },
        {
            "name": "UserCreatedPasswordEvent",
            "baseName": "UserCreatedPasswordEvent",
            "type": "Array<UserPasswordCreatedEvent>"
        },
        {
            "name": "UserAnsweredSignupQuestionsEvent",
            "baseName": "UserAnsweredSignupQuestionsEvent",
            "type": "Array<UserAnsweredSignupQuestionsEvent>"
        },
        {
            "name": "VoucherCreatedEvent",
            "baseName": "VoucherCreatedEvent",
            "type": "Array<VoucherCreatedEvent>"
        },
        {
            "name": "VoucherUpdatedEvent",
            "baseName": "VoucherUpdatedEvent",
            "type": "Array<VoucherUpdatedEvent>"
        },
        {
            "name": "VoucherDeletedEvent",
            "baseName": "VoucherDeletedEvent",
            "type": "Array<VoucherDeletedEvent>"
        },
        {
            "name": "TeammateInviteSentEvent",
            "baseName": "TeammateInviteSentEvent",
            "type": "Array<TeammateInviteSentEvent>"
        },
        {
            "name": "TeammateInviteAcceptedEvent",
            "baseName": "TeammateInviteAcceptedEvent",
            "type": "Array<TeammateInviteAcceptedEvent>"
        },
        {
            "name": "TeammateUpdatedEvent",
            "baseName": "TeammateUpdatedEvent",
            "type": "Array<TeammateUpdatedEvent>"
        },
        {
            "name": "TeammateDeletedEvent",
            "baseName": "TeammateDeletedEvent",
            "type": "Array<TeammateDeletedEvent>"
        },
        {
            "name": "BankAccountCreatedEvent",
            "baseName": "BankAccountCreatedEvent",
            "type": "Array<BankAccountCreatedEvent>"
        },
        {
            "name": "BankAccountUpdatedEvent",
            "baseName": "BankAccountUpdatedEvent",
            "type": "Array<BankAccountUpdatedEvent>"
        },
        {
            "name": "BankAccountDeletedEvent",
            "baseName": "BankAccountDeletedEvent",
            "type": "Array<BankAccountDeletedEvent>"
        },
        {
            "name": "BankAccountAssignedEvent",
            "baseName": "BankAccountAssignedEvent",
            "type": "Array<BankAccountAssignedEvent>"
        },
        {
            "name": "HydraAssignedEvent",
            "baseName": "HydraAssignedEvent",
            "type": "Array<HydraAssignedEvent>"
        },
        {
            "name": "HydraRequestResetEvent",
            "baseName": "HydraRequestResetEvent",
            "type": "Array<HydraRequestResetEvent>"
        },
        {
            "name": "HydraStoreAssignedEvent",
            "baseName": "HydraStoreAssignedEvent",
            "type": "Array<HydraStoreAssignedEvent>"
        },
        {
            "name": "HydraStoreUnassignedEvent",
            "baseName": "HydraStoreUnassignedEvent",
            "type": "Array<HydraStoreUnassignedEvent>"
        },
        {
            "name": "HydraSettingChangedEvent",
            "baseName": "HydraSettingChangedEvent",
            "type": "Array<HydraSettingChangedEvent>"
        },
        {
            "name": "HydraUnAssignedEvent",
            "baseName": "HydraUnAssignedEvent",
            "type": "Array<HydraUnAssignedEvent>"
        },
        {
            "name": "HydraConnectionStatusChangedEvent",
            "baseName": "HydraConnectionStatusChangedEvent",
            "type": "Array<HydraConnectionStatusChangedEvent>"
        },
        {
            "name": "KioskBluetoothPairingModeEvent",
            "baseName": "KioskBluetoothPairingModeEvent",
            "type": "Array<KioskBluetoothPairingModeEvent>"
        },
        {
            "name": "KioskBluetoothUnpairingModeEvent",
            "baseName": "KioskBluetoothUnpairingModeEvent",
            "type": "Array<KioskBluetoothUnpairingModeEvent>"
        },
        {
            "name": "KioskBluetoothTerminalUnpairedEvent",
            "baseName": "KioskBluetoothTerminalUnpairedEvent",
            "type": "Array<KioskBluetoothTerminalUnpairedEvent>"
        },
        {
            "name": "KioskTerminalActionStateChangedEvent",
            "baseName": "KioskTerminalActionStateChangedEvent",
            "type": "Array<KioskTerminalActionStateChangedEvent>"
        },
        {
            "name": "KioskBluetoothTerminalUpdatedEvent",
            "baseName": "KioskBluetoothTerminalUpdatedEvent",
            "type": "Array<KioskBluetoothTerminalUpdatedEvent>"
        },
        {
            "name": "KioskBluetoothTerminalInitiateUpdateCheckEvent",
            "baseName": "KioskBluetoothTerminalInitiateUpdateCheckEvent",
            "type": "Array<KioskBluetoothTerminalInitiateUpdateCheckEvent>"
        },
        {
            "name": "KioskBluetoothInstallUpdateInitiateEvent",
            "baseName": "KioskBluetoothInstallUpdateInitiateEvent",
            "type": "Array<KioskBluetoothInstallUpdateInitiateEvent>"
        },
        {
            "name": "KioskBluetoothTerminalCancelUpdateEvent",
            "baseName": "KioskBluetoothTerminalCancelUpdateEvent",
            "type": "Array<KioskBluetoothTerminalCancelUpdateEvent>"
        },
        {
            "name": "KioskBluetoothTerminalFirmwareVersionStatusEvent",
            "baseName": "KioskBluetoothTerminalFirmwareVersionStatusEvent",
            "type": "Array<KioskBluetoothTerminalFirmwareVersionStatusEvent>"
        },
        {
            "name": "KioskBluetoothTerminalInstallationStatusEvent",
            "baseName": "KioskBluetoothTerminalInstallationStatusEvent",
            "type": "Array<KioskBluetoothTerminalInstallationStatusEvent>"
        },
        {
            "name": "PushNotificationScheduledEvent",
            "baseName": "PushNotificationScheduledEvent",
            "type": "Array<PushNotificationScheduledEvent>"
        },
        {
            "name": "PushNotificationSentEvent",
            "baseName": "PushNotificationSentEvent",
            "type": "Array<PushNotificationSentEvent>"
        },
        {
            "name": "PushNotificationDeletedEvent",
            "baseName": "PushNotificationDeletedEvent",
            "type": "Array<PushNotificationDeletedEvent>"
        },
        {
            "name": "DnsVerifiedEvent",
            "baseName": "DnsVerifiedEvent",
            "type": "Array<DnsVerifiedEvent>"
        },
        {
            "name": "CertificateCreatedEvent",
            "baseName": "CertificateCreatedEvent",
            "type": "Array<CertificateCreatedEvent>"
        },
        {
            "name": "CertificateRenewedEvent",
            "baseName": "CertificateRenewedEvent",
            "type": "Array<CertificateRenewedEvent>"
        },
        {
            "name": "WebsiteVanityUrlUpdatedEvent",
            "baseName": "WebsiteVanityUrlUpdatedEvent",
            "type": "Array<WebsiteVanityUrlUpdatedEvent>"
        },
        {
            "name": "WebsiteUpdatedEvent",
            "baseName": "WebsiteUpdatedEvent",
            "type": "Array<WebsiteUpdatedEvent>"
        },
        {
            "name": "OrderCapacityUpdatedEvent",
            "baseName": "OrderCapacityUpdatedEvent",
            "type": "Array<OrderCapacityConfigUpdatedEvent>"
        },
        {
            "name": "ExternalStoreEvent",
            "baseName": "ExternalStoreEvent",
            "type": "Array<ExternalStoreEvent>"
        },
        {
            "name": "OrderFulfillmentStatusUpdatedEvent",
            "baseName": "OrderFulfillmentStatusUpdatedEvent",
            "type": "Array<OrderFulfillmentStatusUpdatedEvent>"
        },
        {
            "name": "AppStoreConfigCreatedEvent",
            "baseName": "AppStoreConfigCreatedEvent",
            "type": "Array<AppStoreConfigCreatedEvent>"
        },
        {
            "name": "AppStoreConfigUpdatedEvent",
            "baseName": "AppStoreConfigUpdatedEvent",
            "type": "Array<AppStoreConfigUpdatedEvent>"
        },
        {
            "name": "AppStoreConfigDeletedEvent",
            "baseName": "AppStoreConfigDeletedEvent",
            "type": "Array<AppStoreConfigDeletedEvent>"
        },
        {
            "name": "AppStoreSubscriptionChangeJobUpdatedEvent",
            "baseName": "AppStoreSubscriptionChangeJobUpdatedEvent",
            "type": "Array<AppStoreSubscriptionChangeJobUpdatedEvent>"
        },
        {
            "name": "CatalogItemCreatedEvent",
            "baseName": "CatalogItemCreatedEvent",
            "type": "Array<CatalogItemCreatedEvent>"
        },
        {
            "name": "CatalogItemUpdatedEvent",
            "baseName": "CatalogItemUpdatedEvent",
            "type": "Array<CatalogItemUpdatedEvent>"
        },
        {
            "name": "CatalogItemArchivedEvent",
            "baseName": "CatalogItemArchivedEvent",
            "type": "Array<CatalogItemArchivedEvent>"
        },
        {
            "name": "CatalogGroupCreatedEvent",
            "baseName": "CatalogGroupCreatedEvent",
            "type": "Array<CatalogGroupCreatedEvent>"
        },
        {
            "name": "CatalogGroupUpdatedEvent",
            "baseName": "CatalogGroupUpdatedEvent",
            "type": "Array<CatalogGroupUpdatedEvent>"
        },
        {
            "name": "CatalogGroupArchivedEvent",
            "baseName": "CatalogGroupArchivedEvent",
            "type": "Array<CatalogGroupArchivedEvent>"
        },
        {
            "name": "StoreTipUpdatedEvent",
            "baseName": "StoreTipUpdatedEvent",
            "type": "Array<StoreTipUpdatedEvent>"
        },
        {
            "name": "LocationAreaCreatedEvent",
            "baseName": "LocationAreaCreatedEvent",
            "type": "Array<LocationAreaCreatedEvent>"
        },
        {
            "name": "LocationAreaUpdatedEvent",
            "baseName": "LocationAreaUpdatedEvent",
            "type": "Array<LocationAreaUpdatedEvent>"
        },
        {
            "name": "LocationCreatedEvent",
            "baseName": "LocationCreatedEvent",
            "type": "Array<LocationCreatedEvent>"
        },
        {
            "name": "LocationDeletedEvent",
            "baseName": "LocationDeletedEvent",
            "type": "Array<LocationDeletedEvent>"
        },
        {
            "name": "StoreServiceChargeUpdatedEvent",
            "baseName": "StoreServiceChargeUpdatedEvent",
            "type": "Array<StoreServiceChargeUpdatedEvent>"
        },
        {
            "name": "MobileAppsSubmissionStatusUpdatedEvent",
            "baseName": "MobileAppsSubmissionStatusUpdatedEvent",
            "type": "Array<MobileAppsSubmissionStatusUpdatedEvent>"
        },
        {
            "name": "MobileAppsSubmissionUpdatedEvent",
            "baseName": "MobileAppsSubmissionUpdatedEvent",
            "type": "Array<MobileAppsSubmissionUpdatedEvent>"
        },
        {
            "name": "StoreFeeConfigUpdatedEvent",
            "baseName": "StoreFeeConfigUpdatedEvent",
            "type": "Array<StoreFeeConfigUpdatedEvent>"
        }    ];

    static getAttributeTypeMap() {
        return EventSearchResult.attributeTypeMap;
    }
}

export class ExecuteConfigurationActionRequest {
    'Key'?: string;
    'Action'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Key",
            "baseName": "Key",
            "type": "string"
        },
        {
            "name": "Action",
            "baseName": "Action",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ExecuteConfigurationActionRequest.attributeTypeMap;
    }
}

export class ExecuteConfigurationActionResult {
    'ErrorMessage'?: string;
    'InfoMessage'?: string;
    'RedirectUrl'?: string;
    'RedirectTarget'?: ExecuteConfigurationActionResult.RedirectTargetEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ErrorMessage",
            "baseName": "ErrorMessage",
            "type": "string"
        },
        {
            "name": "InfoMessage",
            "baseName": "InfoMessage",
            "type": "string"
        },
        {
            "name": "RedirectUrl",
            "baseName": "RedirectUrl",
            "type": "string"
        },
        {
            "name": "RedirectTarget",
            "baseName": "RedirectTarget",
            "type": "ExecuteConfigurationActionResult.RedirectTargetEnum"
        }    ];

    static getAttributeTypeMap() {
        return ExecuteConfigurationActionResult.attributeTypeMap;
    }
}

export namespace ExecuteConfigurationActionResult {
    export enum RedirectTargetEnum {
        Default = <any> 'Default',
        NewWindow = <any> 'NewWindow',
        Popup = <any> 'Popup'
    }
}
/**
* External event
*/
export class ExternalStoreAuditLog {
    /**
    * The time of creation of the event
    */
    'ExternalCreateTime'?: Date;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Identifies the source of the log
    */
    'Source'?: string;
    /**
    * Identifies the version of the {Flipdish.PublicModels.V1.AuditLogs.ExternalStoreAuditLog.Source}
    */
    'Version'?: string;
    /**
    * Description with format placeholders
    */
    'DescriptionFormat'?: string;
    /**
    * Description with format placeholders
    */
    'DescriptionFields'?: string;
    /**
    * Description
    */
    'DescriptionId'?: string;
    /**
    * Ref (reference field)
    */
    'Ref1'?: string;
    /**
    * Ref2 (reference field)
    */
    'Ref2'?: string;
    /**
    * Ref3 (reference field)
    */
    'Ref3'?: string;
    /**
    * Ref4 (reference field)
    */
    'Ref4'?: string;
    /**
    * Order Id
    */
    'OrderId'?: number;
    /**
    * Tags
    */
    'Tags'?: Array<string>;
    /**
    * Field changes list
    */
    'FieldChanges'?: Array<AuditLogFieldChangeInformation>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ExternalCreateTime",
            "baseName": "ExternalCreateTime",
            "type": "Date"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Source",
            "baseName": "Source",
            "type": "string"
        },
        {
            "name": "Version",
            "baseName": "Version",
            "type": "string"
        },
        {
            "name": "DescriptionFormat",
            "baseName": "DescriptionFormat",
            "type": "string"
        },
        {
            "name": "DescriptionFields",
            "baseName": "DescriptionFields",
            "type": "string"
        },
        {
            "name": "DescriptionId",
            "baseName": "DescriptionId",
            "type": "string"
        },
        {
            "name": "Ref1",
            "baseName": "Ref1",
            "type": "string"
        },
        {
            "name": "Ref2",
            "baseName": "Ref2",
            "type": "string"
        },
        {
            "name": "Ref3",
            "baseName": "Ref3",
            "type": "string"
        },
        {
            "name": "Ref4",
            "baseName": "Ref4",
            "type": "string"
        },
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "Tags",
            "baseName": "Tags",
            "type": "Array<string>"
        },
        {
            "name": "FieldChanges",
            "baseName": "FieldChanges",
            "type": "Array<AuditLogFieldChangeInformation>"
        }    ];

    static getAttributeTypeMap() {
        return ExternalStoreAuditLog.attributeTypeMap;
    }
}

/**
* External event
*/
export class ExternalStoreEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * User which did the action
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Description with format placeholders
    */
    'DescriptionFormat'?: string;
    /**
    * Description with format placeholders
    */
    'DescriptionFields'?: string;
    /**
    * Description
    */
    'DescriptionId'?: string;
    /**
    * Ref (reference field)
    */
    'Ref1'?: string;
    /**
    * Ref2 (reference field)
    */
    'Ref2'?: string;
    /**
    * Ref3 (reference field)
    */
    'Ref3'?: string;
    /**
    * Ref4 (reference field)
    */
    'Ref4'?: string;
    /**
    * Order Id
    */
    'OrderId'?: number;
    /**
    * Tags
    */
    'Tags'?: Array<string>;
    /**
    * Field changes list
    */
    'FieldChanges'?: Array<FieldChangeInformation>;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "DescriptionFormat",
            "baseName": "DescriptionFormat",
            "type": "string"
        },
        {
            "name": "DescriptionFields",
            "baseName": "DescriptionFields",
            "type": "string"
        },
        {
            "name": "DescriptionId",
            "baseName": "DescriptionId",
            "type": "string"
        },
        {
            "name": "Ref1",
            "baseName": "Ref1",
            "type": "string"
        },
        {
            "name": "Ref2",
            "baseName": "Ref2",
            "type": "string"
        },
        {
            "name": "Ref3",
            "baseName": "Ref3",
            "type": "string"
        },
        {
            "name": "Ref4",
            "baseName": "Ref4",
            "type": "string"
        },
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "Tags",
            "baseName": "Tags",
            "type": "Array<string>"
        },
        {
            "name": "FieldChanges",
            "baseName": "FieldChanges",
            "type": "Array<FieldChangeInformation>"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ExternalStoreEvent.attributeTypeMap;
    }
}

/**
* Fee Summary
*/
export class FeeSummary {
    /**
    * Fee amount
    */
    'FeeAmount'?: number;
    /**
    * Percentage rate
    */
    'PercentageRate'?: number;
    /**
    * Per transaction fee
    */
    'PerTransactionFee'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "FeeAmount",
            "baseName": "FeeAmount",
            "type": "number"
        },
        {
            "name": "PercentageRate",
            "baseName": "PercentageRate",
            "type": "number"
        },
        {
            "name": "PerTransactionFee",
            "baseName": "PerTransactionFee",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FeeSummary.attributeTypeMap;
    }
}

export class Field {
    'Name': string;
    'Description': string;
    'Key': string;
    'Tooltip'?: string;
    'Position': number;
    'DefaultValue'?: string;
    'ValidValues'?: Array<ValidValue>;
    'ValidationRegex'?: string;
    'FieldType': Field.FieldTypeEnum;
    'IsFlipdishRestricted'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Key",
            "baseName": "Key",
            "type": "string"
        },
        {
            "name": "Tooltip",
            "baseName": "Tooltip",
            "type": "string"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "DefaultValue",
            "baseName": "DefaultValue",
            "type": "string"
        },
        {
            "name": "ValidValues",
            "baseName": "ValidValues",
            "type": "Array<ValidValue>"
        },
        {
            "name": "ValidationRegex",
            "baseName": "ValidationRegex",
            "type": "string"
        },
        {
            "name": "FieldType",
            "baseName": "FieldType",
            "type": "Field.FieldTypeEnum"
        },
        {
            "name": "IsFlipdishRestricted",
            "baseName": "IsFlipdishRestricted",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Field.attributeTypeMap;
    }
}

export namespace Field {
    export enum FieldTypeEnum {
        Text = <any> 'Text',
        TextArea = <any> 'TextArea',
        Integer = <any> 'Integer',
        Decimal = <any> 'Decimal',
        Date = <any> 'Date',
        DateTime = <any> 'DateTime',
        Time = <any> 'Time',
        Select = <any> 'Select',
        Boolean = <any> 'Boolean',
        ActionButton = <any> 'ActionButton'
    }
}
/**
* Change information for a field
*/
export class FieldChangeInformation {
    /**
    * Path (hierarchy)
    */
    'Path'?: string;
    /**
    * Name of field
    */
    'Name'?: string;
    /**
    * Key (code) of field
    */
    'Key'?: string;
    /**
    * Old value
    */
    'OldValue'?: string;
    /**
    * New value
    */
    'NewValue'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Path",
            "baseName": "Path",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Key",
            "baseName": "Key",
            "type": "string"
        },
        {
            "name": "OldValue",
            "baseName": "OldValue",
            "type": "string"
        },
        {
            "name": "NewValue",
            "baseName": "NewValue",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FieldChangeInformation.attributeTypeMap;
    }
}

export class FieldGroup {
    'Name': string;
    'Description'?: string;
    'Tooltip'?: string;
    'Position': number;
    'Fields'?: Array<Field>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Tooltip",
            "baseName": "Tooltip",
            "type": "string"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "Fields",
            "baseName": "Fields",
            "type": "Array<Field>"
        }    ];

    static getAttributeTypeMap() {
        return FieldGroup.attributeTypeMap;
    }
}

export class FileCreationResult {
    'FileId'?: string;
    'Location'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "FileId",
            "baseName": "FileId",
            "type": "string"
        },
        {
            "name": "Location",
            "baseName": "Location",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FileCreationResult.attributeTypeMap;
    }
}

/**
* File Download Result
*/
export class FileDownloadResult {
    /**
    * URL of the file
    */
    'FileUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "FileUrl",
            "baseName": "FileUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FileDownloadResult.attributeTypeMap;
    }
}

export class FirebaseApp {
    'WhitelabelId'?: number;
    'PackageId'?: string;
    'FirebaseAppId'?: string;
    'FirebaseProjectId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "WhitelabelId",
            "baseName": "WhitelabelId",
            "type": "number"
        },
        {
            "name": "PackageId",
            "baseName": "PackageId",
            "type": "string"
        },
        {
            "name": "FirebaseAppId",
            "baseName": "FirebaseAppId",
            "type": "string"
        },
        {
            "name": "FirebaseProjectId",
            "baseName": "FirebaseProjectId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FirebaseApp.attributeTypeMap;
    }
}

/**
* Base Event
*/
export class FlipdishEventBase {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishEventBase.attributeTypeMap;
    }
}

/**
* Fees breakdown
*/
export class FlipdishFeesDetails {
    /**
    * Fees on online sales
    */
    'OnlineSalesFees'?: number;
    /**
    * Fees on cash sales
    */
    'CashSalesFees'?: number;
    /**
    * Fees of POS sales
    */
    'PosSalesFees'?: number;
    /**
    * Total online and cash sales
    */
    'TotalSalesFees'?: number;
    /**
    * Fees on refunds for online sales
    */
    'OnlineSalesRefundedFees'?: number;
    /**
    * Fees on refunds for cash sales
    */
    'CashSalesRefundedFees'?: number;
    /**
    * Fees on refunds for POS sales
    */
    'PosSalesRefundedFees'?: number;
    /**
    * VAT on sales fees
    */
    'SalesFeesVat'?: number;
    /**
    * Total fees
    */
    'TotalFees'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OnlineSalesFees",
            "baseName": "OnlineSalesFees",
            "type": "number"
        },
        {
            "name": "CashSalesFees",
            "baseName": "CashSalesFees",
            "type": "number"
        },
        {
            "name": "PosSalesFees",
            "baseName": "PosSalesFees",
            "type": "number"
        },
        {
            "name": "TotalSalesFees",
            "baseName": "TotalSalesFees",
            "type": "number"
        },
        {
            "name": "OnlineSalesRefundedFees",
            "baseName": "OnlineSalesRefundedFees",
            "type": "number"
        },
        {
            "name": "CashSalesRefundedFees",
            "baseName": "CashSalesRefundedFees",
            "type": "number"
        },
        {
            "name": "PosSalesRefundedFees",
            "baseName": "PosSalesRefundedFees",
            "type": "number"
        },
        {
            "name": "SalesFeesVat",
            "baseName": "SalesFeesVat",
            "type": "number"
        },
        {
            "name": "TotalFees",
            "baseName": "TotalFees",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FlipdishFeesDetails.attributeTypeMap;
    }
}

/**
* Action item for next fulfillment status selector
*/
export class FulfillentStatusActionItem {
    /**
    * Status Id
    */
    'Id'?: string;
    /**
    * Status Name
    */
    'Name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FulfillentStatusActionItem.attributeTypeMap;
    }
}

/**
* Fulfillment information (required for all orders)
*/
export class FulfillmentInfo {
    /**
    * [Required] Dispatch Type (i.e Pickup / Delivery)
    */
    'DispatchType'?: FulfillmentInfo.DispatchTypeEnum;
    /**
    * [Required] Time the order is requested for
    */
    'RequestedForUtc'?: Date;
    /**
    * Location the order is to be delivered to  [Required] Delivery  [Not Required] Pickup
    */
    'Location'?: Location;
    /**
    * Price of the dispatch, normally 0 for collection and a value for delivery  [Required] Delivery  [Not Required] Pickup
    */
    'DispatchAmount'?: Price;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DispatchType",
            "baseName": "DispatchType",
            "type": "FulfillmentInfo.DispatchTypeEnum"
        },
        {
            "name": "RequestedForUtc",
            "baseName": "RequestedForUtc",
            "type": "Date"
        },
        {
            "name": "Location",
            "baseName": "Location",
            "type": "Location"
        },
        {
            "name": "DispatchAmount",
            "baseName": "DispatchAmount",
            "type": "Price"
        }    ];

    static getAttributeTypeMap() {
        return FulfillmentInfo.attributeTypeMap;
    }
}

export namespace FulfillmentInfo {
    export enum DispatchTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
}
/**
* Fulfillment States Configuration
*/
export class FulfillmentStatesConfiguration {
    /**
    * States
    */
    'States'?: Array<FulfillmentStatusConfigurationItem>;
    /**
    * Enable automatic transitions
    */
    'AutomaticTransitionsEnabled'?: boolean;
    /**
    * AppId
    */
    'AppId'?: string;
    /**
    * Configuration Uid
    */
    'ConfigurationUid'?: string;
    /**
    * Store Selector Type
    */
    'StoreSelectorType'?: FulfillmentStatesConfiguration.StoreSelectorTypeEnum;
    /**
    * Store Ids
    */
    'StoreIds'?: Array<number>;
    /**
    * Name
    */
    'Name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "States",
            "baseName": "States",
            "type": "Array<FulfillmentStatusConfigurationItem>"
        },
        {
            "name": "AutomaticTransitionsEnabled",
            "baseName": "AutomaticTransitionsEnabled",
            "type": "boolean"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "ConfigurationUid",
            "baseName": "ConfigurationUid",
            "type": "string"
        },
        {
            "name": "StoreSelectorType",
            "baseName": "StoreSelectorType",
            "type": "FulfillmentStatesConfiguration.StoreSelectorTypeEnum"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FulfillmentStatesConfiguration.attributeTypeMap;
    }
}

export namespace FulfillmentStatesConfiguration {
    export enum StoreSelectorTypeEnum {
        None = <any> 'None',
        Single = <any> 'Single',
        Multiple = <any> 'Multiple'
    }
}
/**
* Fulfillment configuration header information
*/
export class FulfillmentStatesConfigurationSummary {
    /**
    * AppId
    */
    'AppId': string;
    /**
    * Configuration Uid
    */
    'ConfigurationUid'?: string;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Store selector type
    */
    'StoreSelectorType'?: FulfillmentStatesConfigurationSummary.StoreSelectorTypeEnum;
    /**
    * Stores
    */
    'Stores'?: Array<FulfillmentStatesConfiguredStore>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "ConfigurationUid",
            "baseName": "ConfigurationUid",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "StoreSelectorType",
            "baseName": "StoreSelectorType",
            "type": "FulfillmentStatesConfigurationSummary.StoreSelectorTypeEnum"
        },
        {
            "name": "Stores",
            "baseName": "Stores",
            "type": "Array<FulfillmentStatesConfiguredStore>"
        }    ];

    static getAttributeTypeMap() {
        return FulfillmentStatesConfigurationSummary.attributeTypeMap;
    }
}

export namespace FulfillmentStatesConfigurationSummary {
    export enum StoreSelectorTypeEnum {
        None = <any> 'None',
        Single = <any> 'Single',
        Multiple = <any> 'Multiple'
    }
}
/**
* Configured stores
*/
export class FulfillmentStatesConfiguredStore {
    /**
    * Store id
    */
    'StoreId'?: number;
    /**
    * Name of store
    */
    'Name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FulfillmentStatesConfiguredStore.attributeTypeMap;
    }
}

/**
* Fulfillment Status Item
*/
export class FulfillmentStatusConfigurationItem {
    /**
    * Status Id (no whitespaces)
    */
    'StatusId'?: string;
    /**
    * Status name
    */
    'StatusName'?: string;
    /**
    * Is status enabled
    */
    'Enabled'?: boolean;
    /**
    * The short status string that is displayed to users in apps, portal. If empty then Order Status Name is displayed instead
    */
    'DisplayName'?: string;
    /**
    * Icon/Image that represents that status visual
    */
    'Icon'?: string;
    /**
    * A string which could be used in notification templates with a placeholder (SMS, email, push, web page with status)
    */
    'PublicDescription'?: string;
    /**
    * Is internal state (internal states not shown to customers)
    */
    'Internal'?: boolean;
    /**
    * list of statuses that this status can move to (can be back or forth)
    */
    'NextStatuses'?: Array<string>;
    /**
    * The default next status (on a dropdown or quick button on terminal or portal)
    */
    'DefaultNextStatus'?: Array<NextStatusWithOrderType>;
    /**
    * How will state change (manually or automated, including timed)
    */
    'ChangeType'?: FulfillmentStatusConfigurationItem.ChangeTypeEnum;
    /**
    * Include in reports
    */
    'IncludeInReports'?: boolean;
    /**
    * Is custom state. If not, then it's a system state
    */
    'IsCustom'?: boolean;
    /**
    * If empty then applies to all ordertypes, otherwise a list of order types this state applies to
    */
    'OrderTypes'?: Array<FulfillmentStatusConfigurationItem.OrderTypesEnum>;
    /**
    * Whether state should fire off a notification to the customer
    */
    'Communication'?: boolean;
    /**
    * Image (image filename, relative, not absolute URL)
    */
    'Image'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StatusId",
            "baseName": "StatusId",
            "type": "string"
        },
        {
            "name": "StatusName",
            "baseName": "StatusName",
            "type": "string"
        },
        {
            "name": "Enabled",
            "baseName": "Enabled",
            "type": "boolean"
        },
        {
            "name": "DisplayName",
            "baseName": "DisplayName",
            "type": "string"
        },
        {
            "name": "Icon",
            "baseName": "Icon",
            "type": "string"
        },
        {
            "name": "PublicDescription",
            "baseName": "PublicDescription",
            "type": "string"
        },
        {
            "name": "Internal",
            "baseName": "Internal",
            "type": "boolean"
        },
        {
            "name": "NextStatuses",
            "baseName": "NextStatuses",
            "type": "Array<string>"
        },
        {
            "name": "DefaultNextStatus",
            "baseName": "DefaultNextStatus",
            "type": "Array<NextStatusWithOrderType>"
        },
        {
            "name": "ChangeType",
            "baseName": "ChangeType",
            "type": "FulfillmentStatusConfigurationItem.ChangeTypeEnum"
        },
        {
            "name": "IncludeInReports",
            "baseName": "IncludeInReports",
            "type": "boolean"
        },
        {
            "name": "IsCustom",
            "baseName": "IsCustom",
            "type": "boolean"
        },
        {
            "name": "OrderTypes",
            "baseName": "OrderTypes",
            "type": "Array<FulfillmentStatusConfigurationItem.OrderTypesEnum>"
        },
        {
            "name": "Communication",
            "baseName": "Communication",
            "type": "boolean"
        },
        {
            "name": "Image",
            "baseName": "Image",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FulfillmentStatusConfigurationItem.attributeTypeMap;
    }
}

export namespace FulfillmentStatusConfigurationItem {
    export enum ChangeTypeEnum {
        Manual = <any> 'Manual',
        Automated = <any> 'Automated',
        Integrated = <any> 'Integrated'
    }
    export enum OrderTypesEnum {
        All = <any> 'All',
        Delivery = <any> 'Delivery',
        Collection = <any> 'Collection',
        DineIn = <any> 'DineIn'
    }
}
/**
* Terminal location request
*/
export class GeoPointRequest {
    /**
    * Kiosk device latitude
    */
    'Latitude'?: number;
    /**
    * Kiosk device longitude
    */
    'Longitude'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Latitude",
            "baseName": "Latitude",
            "type": "number"
        },
        {
            "name": "Longitude",
            "baseName": "Longitude",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GeoPointRequest.attributeTypeMap;
    }
}

export class GetReceiptByOrderIdQueryResponse {
    'PreviousOrder'?: PreviousOrder;
    'DepositReturnFeesSummary'?: Array<DepositReturnFeesSummary>;
    'TsRequestedForLocal'?: Date;
    'TsOrderPlacedLocal'?: Date;
    'LogoUrl'?: string;
    'Address'?: string;
    'VatNumber'?: string;
    'PaymentMethodDescription'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PreviousOrder",
            "baseName": "PreviousOrder",
            "type": "PreviousOrder"
        },
        {
            "name": "DepositReturnFeesSummary",
            "baseName": "DepositReturnFeesSummary",
            "type": "Array<DepositReturnFeesSummary>"
        },
        {
            "name": "TsRequestedForLocal",
            "baseName": "TsRequestedForLocal",
            "type": "Date"
        },
        {
            "name": "TsOrderPlacedLocal",
            "baseName": "TsOrderPlacedLocal",
            "type": "Date"
        },
        {
            "name": "LogoUrl",
            "baseName": "LogoUrl",
            "type": "string"
        },
        {
            "name": "Address",
            "baseName": "Address",
            "type": "string"
        },
        {
            "name": "VatNumber",
            "baseName": "VatNumber",
            "type": "string"
        },
        {
            "name": "PaymentMethodDescription",
            "baseName": "PaymentMethodDescription",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetReceiptByOrderIdQueryResponse.attributeTypeMap;
    }
}

export class GoogleAddress {
    'Results'?: Array<GoogleAddressResult>;
    'Result'?: GoogleAddressResult;
    'Status'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Results",
            "baseName": "Results",
            "type": "Array<GoogleAddressResult>"
        },
        {
            "name": "Result",
            "baseName": "Result",
            "type": "GoogleAddressResult"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GoogleAddress.attributeTypeMap;
    }
}

export class GoogleAddressComponent {
    'Long_name'?: string;
    'Short_name'?: string;
    'Types'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Long_name",
            "baseName": "Long_name",
            "type": "string"
        },
        {
            "name": "Short_name",
            "baseName": "Short_name",
            "type": "string"
        },
        {
            "name": "Types",
            "baseName": "Types",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return GoogleAddressComponent.attributeTypeMap;
    }
}

export class GoogleAddressResult {
    'Address_components'?: Array<GoogleAddressComponent>;
    'Formatted_address'?: string;
    'Geometry'?: GoogleGeometry;
    'Place_id'?: string;
    'Types'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Address_components",
            "baseName": "Address_components",
            "type": "Array<GoogleAddressComponent>"
        },
        {
            "name": "Formatted_address",
            "baseName": "Formatted_address",
            "type": "string"
        },
        {
            "name": "Geometry",
            "baseName": "Geometry",
            "type": "GoogleGeometry"
        },
        {
            "name": "Place_id",
            "baseName": "Place_id",
            "type": "string"
        },
        {
            "name": "Types",
            "baseName": "Types",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return GoogleAddressResult.attributeTypeMap;
    }
}

export class GoogleCoordinates {
    'Lat'?: number;
    'Lng'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Lat",
            "baseName": "Lat",
            "type": "number"
        },
        {
            "name": "Lng",
            "baseName": "Lng",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GoogleCoordinates.attributeTypeMap;
    }
}

export class GoogleGeometry {
    'Location'?: GoogleLocation;
    'Location_type'?: string;
    'Viewport'?: GoogleViewport;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Location",
            "baseName": "Location",
            "type": "GoogleLocation"
        },
        {
            "name": "Location_type",
            "baseName": "Location_type",
            "type": "string"
        },
        {
            "name": "Viewport",
            "baseName": "Viewport",
            "type": "GoogleViewport"
        }    ];

    static getAttributeTypeMap() {
        return GoogleGeometry.attributeTypeMap;
    }
}

export class GoogleLocation {
    'Lat'?: number;
    'Lng'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Lat",
            "baseName": "Lat",
            "type": "number"
        },
        {
            "name": "Lng",
            "baseName": "Lng",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GoogleLocation.attributeTypeMap;
    }
}

export class GoogleViewport {
    'Northeast'?: GoogleCoordinates;
    'Southwest'?: GoogleCoordinates;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Northeast",
            "baseName": "Northeast",
            "type": "GoogleCoordinates"
        },
        {
            "name": "Southwest",
            "baseName": "Southwest",
            "type": "GoogleCoordinates"
        }    ];

    static getAttributeTypeMap() {
        return GoogleViewport.attributeTypeMap;
    }
}

/**
* CatalogGroup
*/
export class Group {
    /**
    * Unique catalog group id
    */
    'CatalogGroupId'?: string;
    /**
    * Unique catalog item id
    */
    'CatalogItemId'?: string;
    /**
    * Returns true if the group is archived
    */
    'IsArchived'?: boolean;
    /**
    * Minimum number of items that the user has to select
    */
    'MinSelectCount'?: number;
    /**
    * Maximum number of items that the user has to select
    */
    'MaxSelectCount'?: number;
    /**
    * Collection of items associated with this product
    */
    'Products'?: Array<ProductReference>;
    /**
    * Collection of metafields
    */
    'Metafields'?: Array<Metafield>;
    /**
    * Type of group (ModifierGroup, etc)
    */
    'GroupType': Group.GroupTypeEnum;
    /**
    * Stock Keeping Unit (SKU)
    */
    'Sku': string;
    /**
    * Group name
    */
    'Name': string;
    /**
    * Autogenerate display text in ordering applications
    */
    'AutogenerateDisplayText'?: boolean;
    /**
    * Image File Name
    */
    'ImageFileName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CatalogGroupId",
            "baseName": "CatalogGroupId",
            "type": "string"
        },
        {
            "name": "CatalogItemId",
            "baseName": "CatalogItemId",
            "type": "string"
        },
        {
            "name": "IsArchived",
            "baseName": "IsArchived",
            "type": "boolean"
        },
        {
            "name": "MinSelectCount",
            "baseName": "MinSelectCount",
            "type": "number"
        },
        {
            "name": "MaxSelectCount",
            "baseName": "MaxSelectCount",
            "type": "number"
        },
        {
            "name": "Products",
            "baseName": "Products",
            "type": "Array<ProductReference>"
        },
        {
            "name": "Metafields",
            "baseName": "Metafields",
            "type": "Array<Metafield>"
        },
        {
            "name": "GroupType",
            "baseName": "GroupType",
            "type": "Group.GroupTypeEnum"
        },
        {
            "name": "Sku",
            "baseName": "Sku",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "AutogenerateDisplayText",
            "baseName": "AutogenerateDisplayText",
            "type": "boolean"
        },
        {
            "name": "ImageFileName",
            "baseName": "ImageFileName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Group.attributeTypeMap;
    }
}

export namespace Group {
    export enum GroupTypeEnum {
        ModifierGroup = <any> 'ModifierGroup'
    }
}
/**
* Reference to an existing {Flipdish.Menus.PublicModels.V1.Catalog.Groups.Group}
*/
export class GroupReference {
    /**
    * Details of the referenced {Flipdish.Menus.PublicModels.V1.Catalog.Products.GroupReference.Group}
    */
    'Group'?: Group;
    /**
    * Identifier of the ProductId to use as SubProduct
    */
    'CatalogItemId': string;
    /**
    * Type of the SupProduct
    */
    'GroupType': GroupReference.GroupTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Group",
            "baseName": "Group",
            "type": "Group"
        },
        {
            "name": "CatalogItemId",
            "baseName": "CatalogItemId",
            "type": "string"
        },
        {
            "name": "GroupType",
            "baseName": "GroupType",
            "type": "GroupReference.GroupTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return GroupReference.attributeTypeMap;
    }
}

export namespace GroupReference {
    export enum GroupTypeEnum {
        ModifierGroup = <any> 'ModifierGroup'
    }
}
/**
* Describes coordinates that have a group
*/
export class GroupedCoordinates {
    /**
    * Latitude of this coordinate
    */
    'Latitude'?: number;
    /**
    * Longitude of this coordinate
    */
    'Longitude'?: number;
    /**
    * Count of members in the group
    */
    'Count'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Latitude",
            "baseName": "Latitude",
            "type": "number"
        },
        {
            "name": "Longitude",
            "baseName": "Longitude",
            "type": "number"
        },
        {
            "name": "Count",
            "baseName": "Count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GroupedCoordinates.attributeTypeMap;
    }
}

/**
* Has Payment Method Response
*/
export class HasPaymentMethodResponse {
    /**
    * Has Payment Method
    */
    'HasPaymentMethod': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "HasPaymentMethod",
            "baseName": "HasPaymentMethod",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return HasPaymentMethodResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class HomeAction {
    /**
    * 
    */
    'HomeActionId'?: number;
    /**
    * Type of Action
    */
    'HomeActionType'?: HomeAction.HomeActionTypeEnum;
    /**
    * 
    */
    'Order'?: number;
    /**
    * 
    */
    'TitleKey'?: string;
    /**
    * 
    */
    'ActionKey'?: string;
    /**
    * 
    */
    'DescriptionKey'?: string;
    /**
    * 
    */
    'Action'?: string;
    /**
    * 
    */
    'Dismissible'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "HomeActionId",
            "baseName": "HomeActionId",
            "type": "number"
        },
        {
            "name": "HomeActionType",
            "baseName": "HomeActionType",
            "type": "HomeAction.HomeActionTypeEnum"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "number"
        },
        {
            "name": "TitleKey",
            "baseName": "TitleKey",
            "type": "string"
        },
        {
            "name": "ActionKey",
            "baseName": "ActionKey",
            "type": "string"
        },
        {
            "name": "DescriptionKey",
            "baseName": "DescriptionKey",
            "type": "string"
        },
        {
            "name": "Action",
            "baseName": "Action",
            "type": "string"
        },
        {
            "name": "Dismissible",
            "baseName": "Dismissible",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return HomeAction.attributeTypeMap;
    }
}

export namespace HomeAction {
    export enum HomeActionTypeEnum {
        Portal = <any> 'Portal',
        External = <any> 'External'
    }
}
/**
* Home statitstics
*/
export class HomeStatistics {
    /**
    * Money saved
    */
    'TotalMoneySaved'?: Array<CurrencyData>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TotalMoneySaved",
            "baseName": "TotalMoneySaved",
            "type": "Array<CurrencyData>"
        }    ];

    static getAttributeTypeMap() {
        return HomeStatistics.attributeTypeMap;
    }
}

export class HttpPostedFileBase {
    'ContentLength'?: number;
    'ContentType'?: string;
    'FileName'?: string;
    'InputStream'?: Stream;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ContentLength",
            "baseName": "ContentLength",
            "type": "number"
        },
        {
            "name": "ContentType",
            "baseName": "ContentType",
            "type": "string"
        },
        {
            "name": "FileName",
            "baseName": "FileName",
            "type": "string"
        },
        {
            "name": "InputStream",
            "baseName": "InputStream",
            "type": "Stream"
        }    ];

    static getAttributeTypeMap() {
        return HttpPostedFileBase.attributeTypeMap;
    }
}

/**
* Http Request and Response Log
*/
export class HttpRequestAndResponseLog {
    /**
    * Id of the log
    */
    'Guid'?: string;
    /**
    * Verb associated with the HTTP call.
    */
    'Verb'?: string;
    /**
    * Http request URI.
    */
    'RequestUri'?: string;
    /**
    * Http response status code.
    */
    'StatusCode'?: number;
    /**
    * Http response status line.
    */
    'ReasonPhrase'?: string;
    /**
    * Call duration representing the duration of the HTTP call in milliseconds.
    */
    'CallDurationInMilliseconds'?: number;
    /**
    * Identity of the caller.
    */
    'UserId'?: string;
    /**
    * Ip address of the caller
    */
    'IpAddress'?: string;
    /**
    * Timestamp at which the HTTP call took place.
    */
    'CreatedDateTime'?: string;
    /**
    * Http request headers.
    */
    'RequestHeaders'?: { [key: string]: string; };
    /**
    * Http request body, if any.
    */
    'RequestBody'?: string;
    /**
    * Http request content-length
    */
    'RequestLength'?: number;
    /**
    * Http response headers.
    */
    'ResponseHeaders'?: { [key: string]: string; };
    /**
    * Http response body.
    */
    'ResponseBody'?: string;
    /**
    * Http response content-length
    */
    'ResponseLength'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Guid",
            "baseName": "Guid",
            "type": "string"
        },
        {
            "name": "Verb",
            "baseName": "Verb",
            "type": "string"
        },
        {
            "name": "RequestUri",
            "baseName": "RequestUri",
            "type": "string"
        },
        {
            "name": "StatusCode",
            "baseName": "StatusCode",
            "type": "number"
        },
        {
            "name": "ReasonPhrase",
            "baseName": "ReasonPhrase",
            "type": "string"
        },
        {
            "name": "CallDurationInMilliseconds",
            "baseName": "CallDurationInMilliseconds",
            "type": "number"
        },
        {
            "name": "UserId",
            "baseName": "UserId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        },
        {
            "name": "CreatedDateTime",
            "baseName": "CreatedDateTime",
            "type": "string"
        },
        {
            "name": "RequestHeaders",
            "baseName": "RequestHeaders",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "RequestBody",
            "baseName": "RequestBody",
            "type": "string"
        },
        {
            "name": "RequestLength",
            "baseName": "RequestLength",
            "type": "number"
        },
        {
            "name": "ResponseHeaders",
            "baseName": "ResponseHeaders",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "ResponseBody",
            "baseName": "ResponseBody",
            "type": "string"
        },
        {
            "name": "ResponseLength",
            "baseName": "ResponseLength",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return HttpRequestAndResponseLog.attributeTypeMap;
    }
}

/**
* Hydra assigned event
*/
export class HydraAssignedEvent {
    /**
    * User who made the change
    */
    'User'?: UserEventInfo;
    /**
    * Status of Hydra
    */
    'HydraStatus'?: HydraStatus;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "HydraStatus",
            "baseName": "HydraStatus",
            "type": "HydraStatus"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HydraAssignedEvent.attributeTypeMap;
    }
}

/**
* Hydra configuration
*/
export class HydraConfig {
    /**
    * Minimum version
    */
    'MinimumVersion': string;
    /**
    * Payment options
    */
    'PaymentOptions': Array<HydraConfig.PaymentOptionsEnum>;
    /**
    * Device settings
    */
    'DeviceSettings': DeviceSettings;
    /**
    * Version of the device
    */
    'Version'?: string;
    /**
    * Build number of the device
    */
    'BuildNumber'?: string;
    /**
    * SHA of the commit
    */
    'GitSha'?: string;
    /**
    * Build branch
    */
    'GitBranch'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MinimumVersion",
            "baseName": "MinimumVersion",
            "type": "string"
        },
        {
            "name": "PaymentOptions",
            "baseName": "PaymentOptions",
            "type": "Array<HydraConfig.PaymentOptionsEnum>"
        },
        {
            "name": "DeviceSettings",
            "baseName": "DeviceSettings",
            "type": "DeviceSettings"
        },
        {
            "name": "Version",
            "baseName": "Version",
            "type": "string"
        },
        {
            "name": "BuildNumber",
            "baseName": "BuildNumber",
            "type": "string"
        },
        {
            "name": "GitSha",
            "baseName": "GitSha",
            "type": "string"
        },
        {
            "name": "GitBranch",
            "baseName": "GitBranch",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HydraConfig.attributeTypeMap;
    }
}

export namespace HydraConfig {
    export enum PaymentOptionsEnum {
        Online = <any> 'Online',
        Emv = <any> 'Emv',
        Counter = <any> 'Counter'
    }
}
/**
* Hydra Connection Status Changed Event
*/
export class HydraConnectionStatusChangedEvent {
    /**
    * Hydra Device Id
    */
    'DeviceId'?: string;
    /**
    * Hydra Device Status
    */
    'HydraDeviceStatus'?: HydraConnectionStatusChangedEvent.HydraDeviceStatusEnum;
    /**
    * Hydra Last Poll Time
    */
    'PollTime'?: Date;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeviceId",
            "baseName": "DeviceId",
            "type": "string"
        },
        {
            "name": "HydraDeviceStatus",
            "baseName": "HydraDeviceStatus",
            "type": "HydraConnectionStatusChangedEvent.HydraDeviceStatusEnum"
        },
        {
            "name": "PollTime",
            "baseName": "PollTime",
            "type": "Date"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HydraConnectionStatusChangedEvent.attributeTypeMap;
    }
}

export namespace HydraConnectionStatusChangedEvent {
    export enum HydraDeviceStatusEnum {
        Online = <any> 'Online',
        PossiblyOffline = <any> 'PossiblyOffline',
        Offline = <any> 'Offline'
    }
}
/**
* Hydra device details
*/
export class HydraDeviceDetails {
    /**
    * Flipdish internal device identifier
    */
    'HydraConfigId'?: number;
    /**
    * Device Id
    */
    'DeviceId'?: string;
    /**
    * Serial Number
    */
    'SerialNumber'?: string;
    /**
    * Type of the device
    */
    'DeviceType'?: HydraDeviceDetails.DeviceTypeEnum;
    /**
    * Status of the device
    */
    'Status'?: HydraDeviceDetails.StatusEnum;
    /**
    * Device Name
    */
    'DeviceName'?: string;
    /**
    * Store Names
    */
    'StoreNames'?: Array<HydraStoreData>;
    /**
    * Last poll time in UTC
    */
    'LastPollUtc'?: Date;
    /**
    * Version of the device
    */
    'Version'?: string;
    /**
    * Build number of the device
    */
    'BuildNumber'?: string;
    /**
    * SHA of the commit
    */
    'GitSha'?: string;
    /**
    * Build branch
    */
    'GitBranch'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "HydraConfigId",
            "baseName": "HydraConfigId",
            "type": "number"
        },
        {
            "name": "DeviceId",
            "baseName": "DeviceId",
            "type": "string"
        },
        {
            "name": "SerialNumber",
            "baseName": "SerialNumber",
            "type": "string"
        },
        {
            "name": "DeviceType",
            "baseName": "DeviceType",
            "type": "HydraDeviceDetails.DeviceTypeEnum"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "HydraDeviceDetails.StatusEnum"
        },
        {
            "name": "DeviceName",
            "baseName": "DeviceName",
            "type": "string"
        },
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<HydraStoreData>"
        },
        {
            "name": "LastPollUtc",
            "baseName": "LastPollUtc",
            "type": "Date"
        },
        {
            "name": "Version",
            "baseName": "Version",
            "type": "string"
        },
        {
            "name": "BuildNumber",
            "baseName": "BuildNumber",
            "type": "string"
        },
        {
            "name": "GitSha",
            "baseName": "GitSha",
            "type": "string"
        },
        {
            "name": "GitBranch",
            "baseName": "GitBranch",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HydraDeviceDetails.attributeTypeMap;
    }
}

export namespace HydraDeviceDetails {
    export enum DeviceTypeEnum {
        Kiosk = <any> 'Kiosk',
        Terminal = <any> 'Terminal',
        LegacyPrinter = <any> 'LegacyPrinter'
    }
    export enum StatusEnum {
        Online = <any> 'Online',
        PossiblyOffline = <any> 'PossiblyOffline',
        Offline = <any> 'Offline'
    }
}
/**
* Hydra registration result
*/
export class HydraRegistrationRequest {
    /**
    * Stores to assign the hydra
    */
    'StoreIds': Array<number>;
    /**
    * Hydra device name
    */
    'DeviceName': string;
    /**
    * 6 digit PIN code (not starting with zero).
    */
    'PinCode'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "DeviceName",
            "baseName": "DeviceName",
            "type": "string"
        },
        {
            "name": "PinCode",
            "baseName": "PinCode",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return HydraRegistrationRequest.attributeTypeMap;
    }
}

/**
* Hydra request reset event
*/
export class HydraRequestResetEvent {
    /**
    * User who initiated the change
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HydraRequestResetEvent.attributeTypeMap;
    }
}

/**
* Hydra settings changed
*/
export class HydraSettingChangedEvent {
    /**
    * User who made the change
    */
    'User'?: UserEventInfo;
    /**
    * Hydra configuration
    */
    'HydraConfig'?: HydraConfig;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "HydraConfig",
            "baseName": "HydraConfig",
            "type": "HydraConfig"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HydraSettingChangedEvent.attributeTypeMap;
    }
}

/**
* Hydra status
*/
export class HydraStatus {
    /**
    * 
    */
    'AppId': string;
    /**
    * Store to assign the hydra
    */
    'StoreIds'?: Array<number>;
    /**
    * The device has been already registered
    */
    'IsRegistered': boolean;
    /**
    * 6 digit PIN code (not starting with zero).
    */
    'PinCode'?: number;
    /**
    * Hydra images (covers)
    */
    'Images'?: Array<string>;
    /**
    * Hydra User Type
    */
    'UserType'?: HydraStatus.UserTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "IsRegistered",
            "baseName": "IsRegistered",
            "type": "boolean"
        },
        {
            "name": "PinCode",
            "baseName": "PinCode",
            "type": "number"
        },
        {
            "name": "Images",
            "baseName": "Images",
            "type": "Array<string>"
        },
        {
            "name": "UserType",
            "baseName": "UserType",
            "type": "HydraStatus.UserTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return HydraStatus.attributeTypeMap;
    }
}

export namespace HydraStatus {
    export enum UserTypeEnum {
        Kiosk = <any> 'Kiosk',
        Terminal = <any> 'Terminal',
        LegacyPrinter = <any> 'LegacyPrinter'
    }
}
/**
* Hydra store\\s assigned event
*/
export class HydraStoreAssignedEvent {
    /**
    * User who made the change
    */
    'User'?: UserEventInfo;
    /**
    * Store\\s to assign hydra to
    */
    'StoreIds'?: Array<number>;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HydraStoreAssignedEvent.attributeTypeMap;
    }
}

/**
* Store Data
*/
export class HydraStoreData {
    /**
    * Id of the store
    */
    'StoreId'?: number;
    /**
    * Name of the store
    */
    'StoreName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreName",
            "baseName": "StoreName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HydraStoreData.attributeTypeMap;
    }
}

/**
* Hydra store\\s unassigned event
*/
export class HydraStoreUnassignedEvent {
    /**
    * User who made the change
    */
    'User'?: UserEventInfo;
    /**
    * Store\\s to unassign hydra from
    */
    'StoreIds'?: Array<number>;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HydraStoreUnassignedEvent.attributeTypeMap;
    }
}

/**
* Hydra unassigned event
*/
export class HydraUnAssignedEvent {
    /**
    * User who made the change
    */
    'User'?: UserEventInfo;
    /**
    * Status of Hydra
    */
    'HydraStatus'?: HydraStatus;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "HydraStatus",
            "baseName": "HydraStatus",
            "type": "HydraStatus"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HydraUnAssignedEvent.attributeTypeMap;
    }
}

/**
* Index Page
*/
export class IndexPage {
    /**
    * Testimonials
    */
    'Testimonials'?: Array<WebsiteTestimonial>;
    /**
    * Images
    */
    'Images'?: Array<WebsiteImage>;
    /**
    * About section enabled
    */
    'AboutSectionEnabled'?: boolean;
    /**
    * About section title
    */
    'AboutSectionTitle'?: string;
    /**
    * About section sub-title
    */
    'AboutSectionSubtitle'?: string;
    /**
    * About section title left
    */
    'AboutSectionLeftTitle'?: string;
    /**
    * About section text left
    */
    'AboutSectionLeftBody'?: string;
    /**
    * About section title right
    */
    'AboutSectionRightTitle'?: string;
    /**
    * About section text right
    */
    'AboutSectionRightBody'?: string;
    /**
    * Opening hours section Enabled
    */
    'OpeningHoursEnabled'?: boolean;
    /**
    * Menu Preview section Enabled
    */
    'MenuPreviewEnabled'?: boolean;
    /**
    * Gallery section enabled
    */
    'GalleryEnabled'?: boolean;
    /**
    * Testimonials section Enabled
    */
    'TestimonialsEnabled'?: boolean;
    /**
    * Contact Form section Enabled
    */
    'ContactFormEnabled'?: boolean;
    /**
    * Contact Form Email
    */
    'ContactFormEmail'?: string;
    /**
    * Map section Enabled
    */
    'MapEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Testimonials",
            "baseName": "Testimonials",
            "type": "Array<WebsiteTestimonial>"
        },
        {
            "name": "Images",
            "baseName": "Images",
            "type": "Array<WebsiteImage>"
        },
        {
            "name": "AboutSectionEnabled",
            "baseName": "AboutSectionEnabled",
            "type": "boolean"
        },
        {
            "name": "AboutSectionTitle",
            "baseName": "AboutSectionTitle",
            "type": "string"
        },
        {
            "name": "AboutSectionSubtitle",
            "baseName": "AboutSectionSubtitle",
            "type": "string"
        },
        {
            "name": "AboutSectionLeftTitle",
            "baseName": "AboutSectionLeftTitle",
            "type": "string"
        },
        {
            "name": "AboutSectionLeftBody",
            "baseName": "AboutSectionLeftBody",
            "type": "string"
        },
        {
            "name": "AboutSectionRightTitle",
            "baseName": "AboutSectionRightTitle",
            "type": "string"
        },
        {
            "name": "AboutSectionRightBody",
            "baseName": "AboutSectionRightBody",
            "type": "string"
        },
        {
            "name": "OpeningHoursEnabled",
            "baseName": "OpeningHoursEnabled",
            "type": "boolean"
        },
        {
            "name": "MenuPreviewEnabled",
            "baseName": "MenuPreviewEnabled",
            "type": "boolean"
        },
        {
            "name": "GalleryEnabled",
            "baseName": "GalleryEnabled",
            "type": "boolean"
        },
        {
            "name": "TestimonialsEnabled",
            "baseName": "TestimonialsEnabled",
            "type": "boolean"
        },
        {
            "name": "ContactFormEnabled",
            "baseName": "ContactFormEnabled",
            "type": "boolean"
        },
        {
            "name": "ContactFormEmail",
            "baseName": "ContactFormEmail",
            "type": "string"
        },
        {
            "name": "MapEnabled",
            "baseName": "MapEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return IndexPage.attributeTypeMap;
    }
}

/**
* Base of Index Page
*/
export class IndexPageBase {
    /**
    * About section enabled
    */
    'AboutSectionEnabled'?: boolean;
    /**
    * About section title
    */
    'AboutSectionTitle'?: string;
    /**
    * About section sub-title
    */
    'AboutSectionSubtitle'?: string;
    /**
    * About section title left
    */
    'AboutSectionLeftTitle'?: string;
    /**
    * About section text left
    */
    'AboutSectionLeftBody'?: string;
    /**
    * About section title right
    */
    'AboutSectionRightTitle'?: string;
    /**
    * About section text right
    */
    'AboutSectionRightBody'?: string;
    /**
    * Opening hours section Enabled
    */
    'OpeningHoursEnabled'?: boolean;
    /**
    * Menu Preview section Enabled
    */
    'MenuPreviewEnabled'?: boolean;
    /**
    * Gallery section enabled
    */
    'GalleryEnabled'?: boolean;
    /**
    * Testimonials section Enabled
    */
    'TestimonialsEnabled'?: boolean;
    /**
    * Contact Form section Enabled
    */
    'ContactFormEnabled'?: boolean;
    /**
    * Contact Form Email
    */
    'ContactFormEmail'?: string;
    /**
    * Map section Enabled
    */
    'MapEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AboutSectionEnabled",
            "baseName": "AboutSectionEnabled",
            "type": "boolean"
        },
        {
            "name": "AboutSectionTitle",
            "baseName": "AboutSectionTitle",
            "type": "string"
        },
        {
            "name": "AboutSectionSubtitle",
            "baseName": "AboutSectionSubtitle",
            "type": "string"
        },
        {
            "name": "AboutSectionLeftTitle",
            "baseName": "AboutSectionLeftTitle",
            "type": "string"
        },
        {
            "name": "AboutSectionLeftBody",
            "baseName": "AboutSectionLeftBody",
            "type": "string"
        },
        {
            "name": "AboutSectionRightTitle",
            "baseName": "AboutSectionRightTitle",
            "type": "string"
        },
        {
            "name": "AboutSectionRightBody",
            "baseName": "AboutSectionRightBody",
            "type": "string"
        },
        {
            "name": "OpeningHoursEnabled",
            "baseName": "OpeningHoursEnabled",
            "type": "boolean"
        },
        {
            "name": "MenuPreviewEnabled",
            "baseName": "MenuPreviewEnabled",
            "type": "boolean"
        },
        {
            "name": "GalleryEnabled",
            "baseName": "GalleryEnabled",
            "type": "boolean"
        },
        {
            "name": "TestimonialsEnabled",
            "baseName": "TestimonialsEnabled",
            "type": "boolean"
        },
        {
            "name": "ContactFormEnabled",
            "baseName": "ContactFormEnabled",
            "type": "boolean"
        },
        {
            "name": "ContactFormEmail",
            "baseName": "ContactFormEmail",
            "type": "string"
        },
        {
            "name": "MapEnabled",
            "baseName": "MapEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return IndexPageBase.attributeTypeMap;
    }
}

/**
* Intercom user hash
*/
export class IntercomUserHash {
    /**
    * User hash
    */
    'UserHash'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "UserHash",
            "baseName": "UserHash",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IntercomUserHash.attributeTypeMap;
    }
}

/**
* Invoice
*/
export class Invoice {
    /**
    * The invoice identifier
    */
    'InvoiceId': string;
    /**
    * Invoice number
    */
    'Number': string;
    /**
    * Total
    */
    'Total'?: number;
    /**
    * Currency
    */
    'Currency': Invoice.CurrencyEnum;
    /**
    * Status
    */
    'Status': Invoice.StatusEnum;
    /**
    * The subscription identifier
    */
    'SubscriptionId'?: string;
    /**
    * Paid At
    */
    'PaidAt'?: Date;
    /**
    * Finalised At
    */
    'FinalisedAt'?: Date;
    /**
    * Pdf Link
    */
    'PdfLink': string;
    /**
    * Hosted Url
    */
    'HostedUrl': string;
    /**
    * Overdue
    */
    'Overdue': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "InvoiceId",
            "baseName": "InvoiceId",
            "type": "string"
        },
        {
            "name": "Number",
            "baseName": "Number",
            "type": "string"
        },
        {
            "name": "Total",
            "baseName": "Total",
            "type": "number"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "Invoice.CurrencyEnum"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "Invoice.StatusEnum"
        },
        {
            "name": "SubscriptionId",
            "baseName": "SubscriptionId",
            "type": "string"
        },
        {
            "name": "PaidAt",
            "baseName": "PaidAt",
            "type": "Date"
        },
        {
            "name": "FinalisedAt",
            "baseName": "FinalisedAt",
            "type": "Date"
        },
        {
            "name": "PdfLink",
            "baseName": "PdfLink",
            "type": "string"
        },
        {
            "name": "HostedUrl",
            "baseName": "HostedUrl",
            "type": "string"
        },
        {
            "name": "Overdue",
            "baseName": "Overdue",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Invoice.attributeTypeMap;
    }
}

export namespace Invoice {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
    export enum StatusEnum {
        Draft = <any> 'Draft',
        Open = <any> 'Open',
        Paid = <any> 'Paid',
        UnCollectible = <any> 'UnCollectible',
        Void = <any> 'Void'
    }
}
/**
* Invoice Discount
*/
export class InvoiceDiscount {
    /**
    * Name
    */
    'Name': string;
    /**
    * Amount
    */
    'Amount': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Amount",
            "baseName": "Amount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InvoiceDiscount.attributeTypeMap;
    }
}

/**
* Invoice Item
*/
export class InvoiceItem {
    /**
    * Description
    */
    'Description': string;
    /**
    * Quantity
    */
    'Quantity': number;
    /**
    * Unit Amount Excluding Tax
    */
    'UnitAmountExcludingTax': number;
    /**
    * Tax
    */
    'Tax': number;
    /**
    * Amount
    */
    'Amount': number;
    /**
    * Period
    */
    'Period': InvoicePeriod;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Quantity",
            "baseName": "Quantity",
            "type": "number"
        },
        {
            "name": "UnitAmountExcludingTax",
            "baseName": "UnitAmountExcludingTax",
            "type": "number"
        },
        {
            "name": "Tax",
            "baseName": "Tax",
            "type": "number"
        },
        {
            "name": "Amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "Period",
            "baseName": "Period",
            "type": "InvoicePeriod"
        }    ];

    static getAttributeTypeMap() {
        return InvoiceItem.attributeTypeMap;
    }
}

/**
* Invoice Period
*/
export class InvoicePeriod {
    /**
    * Start
    */
    'Start'?: Date;
    /**
    * End
    */
    'End'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Start",
            "baseName": "Start",
            "type": "Date"
        },
        {
            "name": "End",
            "baseName": "End",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return InvoicePeriod.attributeTypeMap;
    }
}

export class ItemNutritionInfoAddUpdateModel {
    'Labels'?: Array<NutritionInfoItemAddUpdateLabelModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Labels",
            "baseName": "Labels",
            "type": "Array<NutritionInfoItemAddUpdateLabelModel>"
        }    ];

    static getAttributeTypeMap() {
        return ItemNutritionInfoAddUpdateModel.attributeTypeMap;
    }
}

export class ItemNutritionInfoV2AddUpdateModel {
    'AllergenIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AllergenIds",
            "baseName": "AllergenIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return ItemNutritionInfoV2AddUpdateModel.attributeTypeMap;
    }
}

/**
* Job Address
*/
export class JobAddress {
    /**
    * Street
    */
    'Street'?: string;
    /**
    * Postcode
    */
    'Postcode'?: string;
    /**
    * City
    */
    'City'?: string;
    /**
    * Country
    */
    'Country'?: string;
    /**
    * Zone
    */
    'Zone'?: string;
    /**
    * Formatted Address
    */
    'FormattedAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Street",
            "baseName": "Street",
            "type": "string"
        },
        {
            "name": "Postcode",
            "baseName": "Postcode",
            "type": "string"
        },
        {
            "name": "City",
            "baseName": "City",
            "type": "string"
        },
        {
            "name": "Country",
            "baseName": "Country",
            "type": "string"
        },
        {
            "name": "Zone",
            "baseName": "Zone",
            "type": "string"
        },
        {
            "name": "FormattedAddress",
            "baseName": "FormattedAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return JobAddress.attributeTypeMap;
    }
}

/**
* Job Cancellation
*/
export class JobCancellation {
    /**
    * Canceled By
    */
    'CanceledBy'?: string;
    /**
    * Reason Key
    */
    'ReasonKey'?: string;
    /**
    * Comment
    */
    'Comment'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CanceledBy",
            "baseName": "CanceledBy",
            "type": "string"
        },
        {
            "name": "ReasonKey",
            "baseName": "ReasonKey",
            "type": "string"
        },
        {
            "name": "Comment",
            "baseName": "Comment",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return JobCancellation.attributeTypeMap;
    }
}

/**
* Job Contact
*/
export class JobContact {
    /**
    * Firstname
    */
    'Firstname'?: string;
    /**
    * Lastname
    */
    'Lastname'?: string;
    /**
    * Phone
    */
    'Phone'?: string;
    /**
    * Email
    */
    'Email'?: string;
    /**
    * Company
    */
    'Company'?: string;
    /**
    * Company Name
    */
    'CompanyName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Firstname",
            "baseName": "Firstname",
            "type": "string"
        },
        {
            "name": "Lastname",
            "baseName": "Lastname",
            "type": "string"
        },
        {
            "name": "Phone",
            "baseName": "Phone",
            "type": "string"
        },
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "Company",
            "baseName": "Company",
            "type": "string"
        },
        {
            "name": "CompanyName",
            "baseName": "CompanyName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return JobContact.attributeTypeMap;
    }
}

/**
* Job Delivery
*/
export class JobDelivery {
    /**
    * Id
    */
    'Id'?: number;
    /**
    * Status
    */
    'Status'?: string;
    /**
    * Picked At
    */
    'PickedAt'?: string;
    /**
    * Delivered At
    */
    'DeliveredAt'?: string;
    /**
    * Tracking Url
    */
    'TrackingUrl'?: string;
    /**
    * Client Reference
    */
    'ClientReference'?: string;
    /**
    * Package Description
    */
    'PackageDescription'?: string;
    /**
    * Package Type
    */
    'PackageType'?: string;
    /**
    * Pickup
    */
    'Pickup'?: JobDeliveryDetail;
    /**
    * Dropoff
    */
    'Dropoff'?: JobDeliveryDetail;
    /**
    * Eta
    */
    'Eta'?: JobEta;
    /**
    * Cancellation
    */
    'Cancellation'?: JobCancellation;
    /**
    * Proof
    */
    'Proof'?: JobProof;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "string"
        },
        {
            "name": "PickedAt",
            "baseName": "PickedAt",
            "type": "string"
        },
        {
            "name": "DeliveredAt",
            "baseName": "DeliveredAt",
            "type": "string"
        },
        {
            "name": "TrackingUrl",
            "baseName": "TrackingUrl",
            "type": "string"
        },
        {
            "name": "ClientReference",
            "baseName": "ClientReference",
            "type": "string"
        },
        {
            "name": "PackageDescription",
            "baseName": "PackageDescription",
            "type": "string"
        },
        {
            "name": "PackageType",
            "baseName": "PackageType",
            "type": "string"
        },
        {
            "name": "Pickup",
            "baseName": "Pickup",
            "type": "JobDeliveryDetail"
        },
        {
            "name": "Dropoff",
            "baseName": "Dropoff",
            "type": "JobDeliveryDetail"
        },
        {
            "name": "Eta",
            "baseName": "Eta",
            "type": "JobEta"
        },
        {
            "name": "Cancellation",
            "baseName": "Cancellation",
            "type": "JobCancellation"
        },
        {
            "name": "Proof",
            "baseName": "Proof",
            "type": "JobProof"
        }    ];

    static getAttributeTypeMap() {
        return JobDelivery.attributeTypeMap;
    }
}

/**
* Job Delivery Detail
*/
export class JobDeliveryDetail {
    /**
    * Id
    */
    'Id'?: number;
    /**
    * Latitude
    */
    'Latitude'?: number;
    /**
    * Longitude
    */
    'Longitude'?: number;
    /**
    * Comment
    */
    'Comment'?: string;
    /**
    * Address
    */
    'Address'?: JobAddress;
    /**
    * Contact
    */
    'Contact'?: JobContact;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "Latitude",
            "baseName": "Latitude",
            "type": "number"
        },
        {
            "name": "Longitude",
            "baseName": "Longitude",
            "type": "number"
        },
        {
            "name": "Comment",
            "baseName": "Comment",
            "type": "string"
        },
        {
            "name": "Address",
            "baseName": "Address",
            "type": "JobAddress"
        },
        {
            "name": "Contact",
            "baseName": "Contact",
            "type": "JobContact"
        }    ];

    static getAttributeTypeMap() {
        return JobDeliveryDetail.attributeTypeMap;
    }
}

/**
* Job Driver
*/
export class JobDriver {
    /**
    * Id
    */
    'Id'?: number;
    /**
    * Display Name
    */
    'DisplayName'?: string;
    /**
    * Phone
    */
    'Phone'?: string;
    /**
    * Picture Url
    */
    'PictureUrl'?: string;
    /**
    * Transport Type
    */
    'TransportType'?: string;
    /**
    * Latitude
    */
    'Latitude'?: number;
    /**
    * Longitude
    */
    'Longitude'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "DisplayName",
            "baseName": "DisplayName",
            "type": "string"
        },
        {
            "name": "Phone",
            "baseName": "Phone",
            "type": "string"
        },
        {
            "name": "PictureUrl",
            "baseName": "PictureUrl",
            "type": "string"
        },
        {
            "name": "TransportType",
            "baseName": "TransportType",
            "type": "string"
        },
        {
            "name": "Latitude",
            "baseName": "Latitude",
            "type": "number"
        },
        {
            "name": "Longitude",
            "baseName": "Longitude",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return JobDriver.attributeTypeMap;
    }
}

/**
* Job Eta
*/
export class JobEta {
    /**
    * Pickup
    */
    'Pickup'?: string;
    /**
    * Dropoff
    */
    'Dropoff'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Pickup",
            "baseName": "Pickup",
            "type": "string"
        },
        {
            "name": "Dropoff",
            "baseName": "Dropoff",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return JobEta.attributeTypeMap;
    }
}

/**
* Job Pricing
*/
export class JobPricing {
    /**
    * Currency
    */
    'Currency'?: string;
    /**
    * Tax Percentage
    */
    'TaxPercentage'?: number;
    /**
    * Price Tax Included
    */
    'PriceTaxIncluded'?: number;
    /**
    * Price Tax Excluded
    */
    'PriceTaxExcluded'?: number;
    /**
    * Tax Amount
    */
    'TaxAmount'?: number;
    /**
    * Invoice Url
    */
    'InvoiceUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "string"
        },
        {
            "name": "TaxPercentage",
            "baseName": "TaxPercentage",
            "type": "number"
        },
        {
            "name": "PriceTaxIncluded",
            "baseName": "PriceTaxIncluded",
            "type": "number"
        },
        {
            "name": "PriceTaxExcluded",
            "baseName": "PriceTaxExcluded",
            "type": "number"
        },
        {
            "name": "TaxAmount",
            "baseName": "TaxAmount",
            "type": "number"
        },
        {
            "name": "InvoiceUrl",
            "baseName": "InvoiceUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return JobPricing.attributeTypeMap;
    }
}

/**
* Job Proof
*/
export class JobProof {
    /**
    * Signature Url
    */
    'SignatureUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "SignatureUrl",
            "baseName": "SignatureUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return JobProof.attributeTypeMap;
    }
}

/**
* Job Response
*/
export class JobResponse {
    /**
    * Id
    */
    'Id'?: number;
    /**
    * Created At
    */
    'CreatedAt'?: Date;
    /**
    * Status
    */
    'Status'?: string;
    /**
    * Package Type
    */
    'PackageType'?: string;
    /**
    * Transport Type
    */
    'TransportType'?: string;
    /**
    * Assignment Code
    */
    'AssignmentCode'?: string;
    /**
    * Pickup At
    */
    'PickupAt'?: string;
    /**
    * Dropoff At
    */
    'DropoffAt'?: string;
    /**
    * Comment
    */
    'Comment'?: string;
    /**
    * Distance
    */
    'Distance'?: number;
    /**
    * Duration
    */
    'Duration'?: number;
    /**
    * Deliveries
    */
    'Deliveries'?: Array<JobDelivery>;
    /**
    * Pricing
    */
    'Pricing'?: JobPricing;
    /**
    * Driver
    */
    'Driver'?: JobDriver;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "CreatedAt",
            "baseName": "CreatedAt",
            "type": "Date"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "string"
        },
        {
            "name": "PackageType",
            "baseName": "PackageType",
            "type": "string"
        },
        {
            "name": "TransportType",
            "baseName": "TransportType",
            "type": "string"
        },
        {
            "name": "AssignmentCode",
            "baseName": "AssignmentCode",
            "type": "string"
        },
        {
            "name": "PickupAt",
            "baseName": "PickupAt",
            "type": "string"
        },
        {
            "name": "DropoffAt",
            "baseName": "DropoffAt",
            "type": "string"
        },
        {
            "name": "Comment",
            "baseName": "Comment",
            "type": "string"
        },
        {
            "name": "Distance",
            "baseName": "Distance",
            "type": "number"
        },
        {
            "name": "Duration",
            "baseName": "Duration",
            "type": "number"
        },
        {
            "name": "Deliveries",
            "baseName": "Deliveries",
            "type": "Array<JobDelivery>"
        },
        {
            "name": "Pricing",
            "baseName": "Pricing",
            "type": "JobPricing"
        },
        {
            "name": "Driver",
            "baseName": "Driver",
            "type": "JobDriver"
        }    ];

    static getAttributeTypeMap() {
        return JobResponse.attributeTypeMap;
    }
}

/**
* Kiosk bluetooth Initiate Install Update Event
*/
export class KioskBluetoothInstallUpdateInitiateEvent {
    /**
    * Device Id of the Kiosk
    */
    'DeviceId'?: string;
    /**
    * Terminal Type
    */
    'BluetoothTerminalType'?: KioskBluetoothInstallUpdateInitiateEvent.BluetoothTerminalTypeEnum;
    /**
    * User who made the change
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeviceId",
            "baseName": "DeviceId",
            "type": "string"
        },
        {
            "name": "BluetoothTerminalType",
            "baseName": "BluetoothTerminalType",
            "type": "KioskBluetoothInstallUpdateInitiateEvent.BluetoothTerminalTypeEnum"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return KioskBluetoothInstallUpdateInitiateEvent.attributeTypeMap;
    }
}

export namespace KioskBluetoothInstallUpdateInitiateEvent {
    export enum BluetoothTerminalTypeEnum {
        CHIPPER2X = <any> 'CHIPPER_2X',
        COTSDEVICE = <any> 'COTS_DEVICE',
        VERIFONEP400 = <any> 'VERIFONE_P400',
        WISEPAD3 = <any> 'WISEPAD_3',
        WISEPOSE = <any> 'WISEPOS_E'
    }
}
/**
* Kiosk Bluetooth Pairing mode initiated
*/
export class KioskBluetoothPairingModeEvent {
    /**
    * Device Id of the Kiosk
    */
    'DeviceId'?: string;
    /**
    * Terminal Type
    */
    'BluetoothTerminalType'?: KioskBluetoothPairingModeEvent.BluetoothTerminalTypeEnum;
    /**
    * User who made the change
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeviceId",
            "baseName": "DeviceId",
            "type": "string"
        },
        {
            "name": "BluetoothTerminalType",
            "baseName": "BluetoothTerminalType",
            "type": "KioskBluetoothPairingModeEvent.BluetoothTerminalTypeEnum"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return KioskBluetoothPairingModeEvent.attributeTypeMap;
    }
}

export namespace KioskBluetoothPairingModeEvent {
    export enum BluetoothTerminalTypeEnum {
        CHIPPER2X = <any> 'CHIPPER_2X',
        COTSDEVICE = <any> 'COTS_DEVICE',
        VERIFONEP400 = <any> 'VERIFONE_P400',
        WISEPAD3 = <any> 'WISEPAD_3',
        WISEPOSE = <any> 'WISEPOS_E'
    }
}
/**
* Kiosk bluetooth Cancel Update Install Event
*/
export class KioskBluetoothTerminalCancelUpdateEvent {
    /**
    * Device Id of the Kiosk
    */
    'DeviceId'?: string;
    /**
    * Terminal Type
    */
    'BluetoothTerminalType'?: KioskBluetoothTerminalCancelUpdateEvent.BluetoothTerminalTypeEnum;
    /**
    * User who made the change
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeviceId",
            "baseName": "DeviceId",
            "type": "string"
        },
        {
            "name": "BluetoothTerminalType",
            "baseName": "BluetoothTerminalType",
            "type": "KioskBluetoothTerminalCancelUpdateEvent.BluetoothTerminalTypeEnum"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return KioskBluetoothTerminalCancelUpdateEvent.attributeTypeMap;
    }
}

export namespace KioskBluetoothTerminalCancelUpdateEvent {
    export enum BluetoothTerminalTypeEnum {
        CHIPPER2X = <any> 'CHIPPER_2X',
        COTSDEVICE = <any> 'COTS_DEVICE',
        VERIFONEP400 = <any> 'VERIFONE_P400',
        WISEPAD3 = <any> 'WISEPAD_3',
        WISEPOSE = <any> 'WISEPOS_E'
    }
}
/**
* Kiosk Stripe Terminal Update info received event
*/
export class KioskBluetoothTerminalFirmwareVersionStatusEvent {
    /**
    * Device Id of the Kiosk
    */
    'DeviceId'?: string;
    /**
    * Serial Number of the device
    */
    'SerialNumber'?: string;
    /**
    * Indicates if Payment Terminal has Firmware Update
    */
    'HasFirmwareUpdate'?: boolean;
    /**
    * Indicates if Payment Terminal has Config Update
    */
    'HasConfigUpdate'?: boolean;
    /**
    * Indicates if Payment Terminal has Key Update
    */
    'HasKeyUpdate'?: boolean;
    /**
    * ETA to install the update
    */
    'UpdateTimeEstimate'?: KioskBluetoothTerminalFirmwareVersionStatusEvent.UpdateTimeEstimateEnum;
    /**
    * User who made the changes
    */
    'UserEventInfo'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeviceId",
            "baseName": "DeviceId",
            "type": "string"
        },
        {
            "name": "SerialNumber",
            "baseName": "SerialNumber",
            "type": "string"
        },
        {
            "name": "HasFirmwareUpdate",
            "baseName": "HasFirmwareUpdate",
            "type": "boolean"
        },
        {
            "name": "HasConfigUpdate",
            "baseName": "HasConfigUpdate",
            "type": "boolean"
        },
        {
            "name": "HasKeyUpdate",
            "baseName": "HasKeyUpdate",
            "type": "boolean"
        },
        {
            "name": "UpdateTimeEstimate",
            "baseName": "UpdateTimeEstimate",
            "type": "KioskBluetoothTerminalFirmwareVersionStatusEvent.UpdateTimeEstimateEnum"
        },
        {
            "name": "UserEventInfo",
            "baseName": "UserEventInfo",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return KioskBluetoothTerminalFirmwareVersionStatusEvent.attributeTypeMap;
    }
}

export namespace KioskBluetoothTerminalFirmwareVersionStatusEvent {
    export enum UpdateTimeEstimateEnum {
        LessThanOneMinute = <any> 'LessThanOneMinute',
        OneToTwoMinutes = <any> 'OneToTwoMinutes',
        TwoToFiveMinutes = <any> 'TwoToFiveMinutes',
        FiveToFifteenMinutes = <any> 'FiveToFifteenMinutes'
    }
}
/**
* Kiosk bluetooth trigger update check event
*/
export class KioskBluetoothTerminalInitiateUpdateCheckEvent {
    /**
    * Device Id of the Kiosk
    */
    'DeviceId'?: string;
    /**
    * User who made the change
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeviceId",
            "baseName": "DeviceId",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return KioskBluetoothTerminalInitiateUpdateCheckEvent.attributeTypeMap;
    }
}

/**
* Kiosk bluetooth terminal Installation Status
*/
export class KioskBluetoothTerminalInstallationStatusEvent {
    /**
    * Device Id of the Kiosk
    */
    'DeviceId'?: string;
    /**
    * Terminal Type
    */
    'BluetoothTerminalType'?: KioskBluetoothTerminalInstallationStatusEvent.BluetoothTerminalTypeEnum;
    /**
    * Serial number of the terminal
    */
    'BluetoothTerminalSerialNumber'?: string;
    /**
    * User who made the change
    */
    'User'?: UserEventInfo;
    /**
    * Update Install Progress for Card Reader
    */
    'Progress'?: number;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeviceId",
            "baseName": "DeviceId",
            "type": "string"
        },
        {
            "name": "BluetoothTerminalType",
            "baseName": "BluetoothTerminalType",
            "type": "KioskBluetoothTerminalInstallationStatusEvent.BluetoothTerminalTypeEnum"
        },
        {
            "name": "BluetoothTerminalSerialNumber",
            "baseName": "BluetoothTerminalSerialNumber",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Progress",
            "baseName": "Progress",
            "type": "number"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return KioskBluetoothTerminalInstallationStatusEvent.attributeTypeMap;
    }
}

export namespace KioskBluetoothTerminalInstallationStatusEvent {
    export enum BluetoothTerminalTypeEnum {
        CHIPPER2X = <any> 'CHIPPER_2X',
        COTSDEVICE = <any> 'COTS_DEVICE',
        VERIFONEP400 = <any> 'VERIFONE_P400',
        WISEPAD3 = <any> 'WISEPAD_3',
        WISEPOSE = <any> 'WISEPOS_E'
    }
}
/**
* Kiosk Bluetooth Unpairing mode initiated
*/
export class KioskBluetoothTerminalUnpairedEvent {
    /**
    * Device Id of the Kiosk
    */
    'DeviceId'?: string;
    /**
    * Terminal Type
    */
    'BluetoothTerminalType'?: KioskBluetoothTerminalUnpairedEvent.BluetoothTerminalTypeEnum;
    /**
    * User who made the change
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeviceId",
            "baseName": "DeviceId",
            "type": "string"
        },
        {
            "name": "BluetoothTerminalType",
            "baseName": "BluetoothTerminalType",
            "type": "KioskBluetoothTerminalUnpairedEvent.BluetoothTerminalTypeEnum"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return KioskBluetoothTerminalUnpairedEvent.attributeTypeMap;
    }
}

export namespace KioskBluetoothTerminalUnpairedEvent {
    export enum BluetoothTerminalTypeEnum {
        CHIPPER2X = <any> 'CHIPPER_2X',
        COTSDEVICE = <any> 'COTS_DEVICE',
        VERIFONEP400 = <any> 'VERIFONE_P400',
        WISEPAD3 = <any> 'WISEPAD_3',
        WISEPOSE = <any> 'WISEPOS_E'
    }
}
/**
* Kiosk bluetooth terminal unpaired
*/
export class KioskBluetoothTerminalUpdatedEvent {
    /**
    * Device Id of the Kiosk
    */
    'DeviceId'?: string;
    /**
    * Terminal Type
    */
    'BluetoothTerminalType'?: KioskBluetoothTerminalUpdatedEvent.BluetoothTerminalTypeEnum;
    /**
    * Serial number of the terminal
    */
    'BluetoothTerminalSerialNumber'?: string;
    /**
    * Status of the connected terminal
    */
    'BluetoothTerminalStatus'?: BluetoothTerminalStatus;
    /**
    * User who made the change
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeviceId",
            "baseName": "DeviceId",
            "type": "string"
        },
        {
            "name": "BluetoothTerminalType",
            "baseName": "BluetoothTerminalType",
            "type": "KioskBluetoothTerminalUpdatedEvent.BluetoothTerminalTypeEnum"
        },
        {
            "name": "BluetoothTerminalSerialNumber",
            "baseName": "BluetoothTerminalSerialNumber",
            "type": "string"
        },
        {
            "name": "BluetoothTerminalStatus",
            "baseName": "BluetoothTerminalStatus",
            "type": "BluetoothTerminalStatus"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return KioskBluetoothTerminalUpdatedEvent.attributeTypeMap;
    }
}

export namespace KioskBluetoothTerminalUpdatedEvent {
    export enum BluetoothTerminalTypeEnum {
        CHIPPER2X = <any> 'CHIPPER_2X',
        COTSDEVICE = <any> 'COTS_DEVICE',
        VERIFONEP400 = <any> 'VERIFONE_P400',
        WISEPAD3 = <any> 'WISEPAD_3',
        WISEPOSE = <any> 'WISEPOS_E'
    }
}
/**
* Kiosk Bluetooth Unpairing mode initiated
*/
export class KioskBluetoothUnpairingModeEvent {
    /**
    * Device Id of the Kiosk
    */
    'DeviceId'?: string;
    /**
    * Terminal Type
    */
    'BluetoothTerminalType'?: KioskBluetoothUnpairingModeEvent.BluetoothTerminalTypeEnum;
    /**
    * User who made the change
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeviceId",
            "baseName": "DeviceId",
            "type": "string"
        },
        {
            "name": "BluetoothTerminalType",
            "baseName": "BluetoothTerminalType",
            "type": "KioskBluetoothUnpairingModeEvent.BluetoothTerminalTypeEnum"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return KioskBluetoothUnpairingModeEvent.attributeTypeMap;
    }
}

export namespace KioskBluetoothUnpairingModeEvent {
    export enum BluetoothTerminalTypeEnum {
        CHIPPER2X = <any> 'CHIPPER_2X',
        COTSDEVICE = <any> 'COTS_DEVICE',
        VERIFONEP400 = <any> 'VERIFONE_P400',
        WISEPAD3 = <any> 'WISEPAD_3',
        WISEPOSE = <any> 'WISEPOS_E'
    }
}
/**
* Get Cash Payment Settings for a UserId
*/
export class KioskCashPaymentSettings {
    /**
    * false :disable cash on kiosk  true :enable cash on kiosk
    */
    'IsCashVisibleToCustomer'?: boolean;
    /**
    * HydraUser ID of the Device
    */
    'UserId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IsCashVisibleToCustomer",
            "baseName": "IsCashVisibleToCustomer",
            "type": "boolean"
        },
        {
            "name": "UserId",
            "baseName": "UserId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return KioskCashPaymentSettings.attributeTypeMap;
    }
}

/**
* Kiosk entitlements and usage
*/
export class KioskEntitlementsResult {
    /**
    * Number of kiosk devices entitled
    */
    'EntitledQuantity'?: number;
    /**
    * The quantity of entitlements that have been used
    */
    'UsedQuantity'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EntitledQuantity",
            "baseName": "EntitledQuantity",
            "type": "number"
        },
        {
            "name": "UsedQuantity",
            "baseName": "UsedQuantity",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return KioskEntitlementsResult.attributeTypeMap;
    }
}

/**
* Connection parameters to IoT
*/
export class KioskIotConnectionParameters {
    /**
    * The device connection string to the IoT server
    */
    'ConnectionString'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ConnectionString",
            "baseName": "ConnectionString",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return KioskIotConnectionParameters.attributeTypeMap;
    }
}

/**
* Kiosk level settings
*/
export class KioskSettings {
    /**
    * Hide logo from front page
    */
    'HideLogoFromFrontPage'?: boolean;
    /**
    * 2 Column Menu Layout
    */
    'TwoColumnMenuLayout'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "HideLogoFromFrontPage",
            "baseName": "HideLogoFromFrontPage",
            "type": "boolean"
        },
        {
            "name": "TwoColumnMenuLayout",
            "baseName": "TwoColumnMenuLayout",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return KioskSettings.attributeTypeMap;
    }
}

/**
* Kiosk Terminal action state changed
*/
export class KioskTerminalActionStateChangedEvent {
    /**
    * Card reader id
    */
    'ReaderId'?: string;
    /**
    * Terminal type
    */
    'BluetoothTerminalType'?: KioskTerminalActionStateChangedEvent.BluetoothTerminalTypeEnum;
    /**
    * Action state. success or fail
    */
    'ActionState'?: string;
    /**
    * Failure code if processing is failed
    */
    'FailureCode'?: string;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ReaderId",
            "baseName": "ReaderId",
            "type": "string"
        },
        {
            "name": "BluetoothTerminalType",
            "baseName": "BluetoothTerminalType",
            "type": "KioskTerminalActionStateChangedEvent.BluetoothTerminalTypeEnum"
        },
        {
            "name": "ActionState",
            "baseName": "ActionState",
            "type": "string"
        },
        {
            "name": "FailureCode",
            "baseName": "FailureCode",
            "type": "string"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return KioskTerminalActionStateChangedEvent.attributeTypeMap;
    }
}

export namespace KioskTerminalActionStateChangedEvent {
    export enum BluetoothTerminalTypeEnum {
        CHIPPER2X = <any> 'CHIPPER_2X',
        COTSDEVICE = <any> 'COTS_DEVICE',
        VERIFONEP400 = <any> 'VERIFONE_P400',
        WISEPAD3 = <any> 'WISEPAD_3',
        WISEPOSE = <any> 'WISEPOS_E'
    }
}
/**
* Sorted Language
*/
export class Language {
    /**
    * ISO 639-1 Language Code
    */
    'LanguageId'?: string;
    /**
    * Display Order
    */
    'DisplayOrder'?: number;
    /**
    * Language Name
    */
    'Name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LanguageId",
            "baseName": "LanguageId",
            "type": "string"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Language.attributeTypeMap;
    }
}

/**
* List's the issues with the last failed payment intent
*/
export class LastPaymentError {
    /**
    * For some errors that could be handled programmatically, a short string indicating the error code reported.
    */
    'Code'?: string;
    /**
    * For card errors resulting from a card issuer decline, a short string indicating the card issuer’s reason for the decline if they provide one.
    */
    'DeclineCode'?: string;
    /**
    * A human-readable message providing more details about the error. For card errors, these messages can be shown to your users.
    */
    'Message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        },
        {
            "name": "DeclineCode",
            "baseName": "DeclineCode",
            "type": "string"
        },
        {
            "name": "Message",
            "baseName": "Message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LastPaymentError.attributeTypeMap;
    }
}

/**
* 
*/
export class LeadTime {
    /**
    * There are two valid values for this field - `collection` and `delivery`.
    */
    'DispatchType': string;
    /**
    * This must be a positive integer.
    */
    'LeadTimeMinutes': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DispatchType",
            "baseName": "DispatchType",
            "type": "string"
        },
        {
            "name": "LeadTimeMinutes",
            "baseName": "LeadTimeMinutes",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return LeadTime.attributeTypeMap;
    }
}

/**
* Ligthspeed store settings
*/
export class LightspeedSettings {
    /**
    * Company Id
    */
    'CompanyId'?: string;
    /**
    * Use OAuth for authentication
    */
    'UseOAuth'?: boolean;
    /**
    * Enabled
    */
    'Enabled'?: boolean;
    /**
    * Estimated minutes for delivery
    */
    'EstimatedMinutesForDelivery'?: number;
    /**
    * Estimated minutes for collection
    */
    'EstimatedMinutesForCollection'?: number;
    /**
    * Geographic location (euc1, nae1, euw2, ....))
    */
    'GeographicLocation'?: string;
    /**
    * Is the CompanyId an establishment (kind of the store of a group of store)
    */
    'Establishment'?: boolean;
    /**
    * The Lightspeed voucher identifier to map with our
    */
    'VoucherId'?: string;
    /**
    * The Lightspeed delivery fee identifier to map with our
    */
    'DeliveryFeeId'?: string;
    /**
    * The Lightspeed processing fee identifier to map with our
    */
    'ProcessingFeeId'?: string;
    /**
    * Which price to choose from Lightspeed menu
    */
    'PriceType'?: LightspeedSettings.PriceTypeEnum;
    /**
    * The menu id of the store
    */
    'MenuId'?: number;
    /**
    * Collection Table ID to send orders
    */
    'CollectionTableId'?: number;
    /**
    * Delivery Table ID to send orders
    */
    'DeliveryTableId'?: number;
    /**
    * Collection Table IDs to send orders to
    */
    'CollectionTableIds'?: { [key: string]: string; };
    /**
    * Delivery Table IDs to send orders to
    */
    'DeliveryTableIds'?: { [key: string]: string; };
    /**
    * Exclude tax
    */
    'UseTaxInclusivePrices'?: boolean;
    /**
    * WARNING: only use this option if the Liteserver is not synchronizing within max 5 minutes with Lightspeed cloud!
    */
    'SkipStatusCheckAndAcceptOrderAfterSending'?: boolean;
    /**
    * Send Table Number to Table Id
    */
    'SendTableNumberToTableId'?: boolean;
    /**
    * Add ChefNote To Product
    */
    'AddChefNoteToProduct'?: boolean;
    /**
    * The Lightspeed Chef Note Item Id to map
    */
    'ChefNoteItemId'?: string;
    /**
    * The Lightspeed Chef Note Modifier Id to map
    */
    'ChefNoteModifierId'?: string;
    /**
    * The Lightspeed Service Charge Id to map
    */
    'ServiceChargeId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CompanyId",
            "baseName": "CompanyId",
            "type": "string"
        },
        {
            "name": "UseOAuth",
            "baseName": "UseOAuth",
            "type": "boolean"
        },
        {
            "name": "Enabled",
            "baseName": "Enabled",
            "type": "boolean"
        },
        {
            "name": "EstimatedMinutesForDelivery",
            "baseName": "EstimatedMinutesForDelivery",
            "type": "number"
        },
        {
            "name": "EstimatedMinutesForCollection",
            "baseName": "EstimatedMinutesForCollection",
            "type": "number"
        },
        {
            "name": "GeographicLocation",
            "baseName": "GeographicLocation",
            "type": "string"
        },
        {
            "name": "Establishment",
            "baseName": "Establishment",
            "type": "boolean"
        },
        {
            "name": "VoucherId",
            "baseName": "VoucherId",
            "type": "string"
        },
        {
            "name": "DeliveryFeeId",
            "baseName": "DeliveryFeeId",
            "type": "string"
        },
        {
            "name": "ProcessingFeeId",
            "baseName": "ProcessingFeeId",
            "type": "string"
        },
        {
            "name": "PriceType",
            "baseName": "PriceType",
            "type": "LightspeedSettings.PriceTypeEnum"
        },
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "CollectionTableId",
            "baseName": "CollectionTableId",
            "type": "number"
        },
        {
            "name": "DeliveryTableId",
            "baseName": "DeliveryTableId",
            "type": "number"
        },
        {
            "name": "CollectionTableIds",
            "baseName": "CollectionTableIds",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "DeliveryTableIds",
            "baseName": "DeliveryTableIds",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "UseTaxInclusivePrices",
            "baseName": "UseTaxInclusivePrices",
            "type": "boolean"
        },
        {
            "name": "SkipStatusCheckAndAcceptOrderAfterSending",
            "baseName": "SkipStatusCheckAndAcceptOrderAfterSending",
            "type": "boolean"
        },
        {
            "name": "SendTableNumberToTableId",
            "baseName": "SendTableNumberToTableId",
            "type": "boolean"
        },
        {
            "name": "AddChefNoteToProduct",
            "baseName": "AddChefNoteToProduct",
            "type": "boolean"
        },
        {
            "name": "ChefNoteItemId",
            "baseName": "ChefNoteItemId",
            "type": "string"
        },
        {
            "name": "ChefNoteModifierId",
            "baseName": "ChefNoteModifierId",
            "type": "string"
        },
        {
            "name": "ServiceChargeId",
            "baseName": "ServiceChargeId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LightspeedSettings.attributeTypeMap;
    }
}

export namespace LightspeedSettings {
    export enum PriceTypeEnum {
        Default = <any> 'Default',
        Takeaway = <any> 'Takeaway',
        Delivery = <any> 'Delivery'
    }
}
/**
* Defines a single line item
*/
export class LineItem {
    /**
    * Flipdish Item Id, if unknown leave 'null'
    */
    'Id'?: number;
    /**
    * Item Name
    */
    'Name'?: string;
    /**
    * Menu section name
    */
    'SectionName'?: string;
    /**
    * External Item Id
    */
    'ExternalId'?: string;
    /**
    * Item Quantity
    */
    'Quantity'?: number;
    /**
    * Item Price
    */
    'Price'?: Price;
    /**
    * Item Notes
    */
    'Notes'?: string;
    /**
    * Item Option
    */
    'Options'?: Array<LineItemOption>;
    /**
    * Other Item Metadata
    */
    'Metadata'?: { [key: string]: string; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "SectionName",
            "baseName": "SectionName",
            "type": "string"
        },
        {
            "name": "ExternalId",
            "baseName": "ExternalId",
            "type": "string"
        },
        {
            "name": "Quantity",
            "baseName": "Quantity",
            "type": "number"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "Price"
        },
        {
            "name": "Notes",
            "baseName": "Notes",
            "type": "string"
        },
        {
            "name": "Options",
            "baseName": "Options",
            "type": "Array<LineItemOption>"
        },
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "{ [key: string]: string; }"
        }    ];

    static getAttributeTypeMap() {
        return LineItem.attributeTypeMap;
    }
}

/**
* Defines a single line item option
*/
export class LineItemOption {
    /**
    * Flipdish Item Option Id, if unknown leave 'null'
    */
    'Id'?: number;
    /**
    * External Item Option Id
    */
    'ExternalId'?: string;
    /**
    * External Item Option Name
    */
    'Name'?: string;
    /**
    * External Item Option Price
    */
    'Price'?: Price;
    /**
    * Other Item Metadata
    */
    'Metadata'?: { [key: string]: string; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "ExternalId",
            "baseName": "ExternalId",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "Price"
        },
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "{ [key: string]: string; }"
        }    ];

    static getAttributeTypeMap() {
        return LineItemOption.attributeTypeMap;
    }
}

/**
* Represents a localised time zone
*/
export class LocalisedTimeZone {
    /**
    * Microsoft Time Zone Id
    */
    'TimeZoneId'?: string;
    /**
    * Iana Time Zone Id
    */
    'IanaTimeZoneId'?: string;
    /**
    * Display name in users language
    */
    'DisplayName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TimeZoneId",
            "baseName": "TimeZoneId",
            "type": "string"
        },
        {
            "name": "IanaTimeZoneId",
            "baseName": "IanaTimeZoneId",
            "type": "string"
        },
        {
            "name": "DisplayName",
            "baseName": "DisplayName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LocalisedTimeZone.attributeTypeMap;
    }
}

/**
* Location to deliver to
*/
export class Location {
    /**
    * Line 1 of the address
    */
    'AddressLine1'?: string;
    /**
    * Line 2 of the address
    */
    'AddressLine2'?: string;
    /**
    * Formatted Address
    */
    'FormattedAddress'?: string;
    /**
    * Postal / Zip Code
    */
    'PostalCode'?: string;
    /**
    * City to deliver to
    */
    'City'?: string;
    /**
    * Coordinates to deliver to
    */
    'Coordinates'?: Coordinates;
    /**
    * Notes for delivery
    */
    'Notes'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AddressLine1",
            "baseName": "AddressLine1",
            "type": "string"
        },
        {
            "name": "AddressLine2",
            "baseName": "AddressLine2",
            "type": "string"
        },
        {
            "name": "FormattedAddress",
            "baseName": "FormattedAddress",
            "type": "string"
        },
        {
            "name": "PostalCode",
            "baseName": "PostalCode",
            "type": "string"
        },
        {
            "name": "City",
            "baseName": "City",
            "type": "string"
        },
        {
            "name": "Coordinates",
            "baseName": "Coordinates",
            "type": "Coordinates"
        },
        {
            "name": "Notes",
            "baseName": "Notes",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Location.attributeTypeMap;
    }
}

/**
* Represents a LocationArea
*/
export class LocationArea {
    /**
    * Id of the LocationArea
    */
    'LocationAreaId'?: number;
    /**
    * Id of the Store that this LocationArea belongs to
    */
    'StoreId'?: number;
    /**
    * Descriptive LocationArea name
    */
    'LocationAreaName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LocationAreaId",
            "baseName": "LocationAreaId",
            "type": "number"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "LocationAreaName",
            "baseName": "LocationAreaName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LocationArea.attributeTypeMap;
    }
}

/**
* Event for logging creating of LocationAreas
*/
export class LocationAreaCreatedEvent {
    /**
    * LocationArea Id
    */
    'LocationAreaId'?: string;
    /**
    * LocationArea name
    */
    'LocationAreaName'?: string;
    /**
    * User who created the LocationArea
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LocationAreaId",
            "baseName": "LocationAreaId",
            "type": "string"
        },
        {
            "name": "LocationAreaName",
            "baseName": "LocationAreaName",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LocationAreaCreatedEvent.attributeTypeMap;
    }
}

/**
* Representation of a Location i.e: (Table, Hotel Room, Car Park, etc )
*/
export class LocationAreaLocation {
    /**
    * Id of the Location
    */
    'LocationId': number;
    /**
    * Name of the Location
    */
    'LocationName': string;
    /**
    * The order that the Location should be displayed on the screen
    */
    'DisplayOrder': number;
    /**
    * Id of the Location on an external system
    */
    'ExternalLocationId'?: string;
    /**
    * Shows if the Location is deleted or not
    */
    'IsDeleted'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LocationId",
            "baseName": "LocationId",
            "type": "number"
        },
        {
            "name": "LocationName",
            "baseName": "LocationName",
            "type": "string"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "ExternalLocationId",
            "baseName": "ExternalLocationId",
            "type": "string"
        },
        {
            "name": "IsDeleted",
            "baseName": "IsDeleted",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return LocationAreaLocation.attributeTypeMap;
    }
}

/**
* Event for logging updates of LocationAreas
*/
export class LocationAreaUpdatedEvent {
    /**
    * LocationArea Id
    */
    'LocationAreaId'?: string;
    /**
    * LocationArea Name
    */
    'LocationAreaName'?: string;
    /**
    * User who updated the LocationArea
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LocationAreaId",
            "baseName": "LocationAreaId",
            "type": "string"
        },
        {
            "name": "LocationAreaName",
            "baseName": "LocationAreaName",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LocationAreaUpdatedEvent.attributeTypeMap;
    }
}

/**
* Represents a LocationArea and its Location list
*/
export class LocationAreaWithLocations {
    /**
    * Id of the LocationArea
    */
    'LocationAreaId': number;
    /**
    * Id of the Store that this LocationArea belongs to
    */
    'StoreId': number;
    /**
    * Descriptive LocationArea name
    */
    'LocationAreaName': string;
    /**
    * List of Locations that belongs to this Location Area
    */
    'Locations'?: Array<LocationAreaLocation>;
    /**
    * Returns if the LocationArea is deleted or not
    */
    'IsDeleted'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LocationAreaId",
            "baseName": "LocationAreaId",
            "type": "number"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "LocationAreaName",
            "baseName": "LocationAreaName",
            "type": "string"
        },
        {
            "name": "Locations",
            "baseName": "Locations",
            "type": "Array<LocationAreaLocation>"
        },
        {
            "name": "IsDeleted",
            "baseName": "IsDeleted",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return LocationAreaWithLocations.attributeTypeMap;
    }
}

/**
* Event for logging the creating of Locations
*/
export class LocationCreatedEvent {
    /**
    * Location Location Id
    */
    'LocationId'?: number;
    /**
    * Location LocationName
    */
    'LocationName'?: string;
    /**
    * Location DisplayOrder
    */
    'DisplayOrder'?: number;
    /**
    * Location ExternalLocationId
    */
    'ExternalLocationId'?: string;
    /**
    * Location LocationAreaId
    */
    'LocationAreaId'?: number;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LocationId",
            "baseName": "LocationId",
            "type": "number"
        },
        {
            "name": "LocationName",
            "baseName": "LocationName",
            "type": "string"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "ExternalLocationId",
            "baseName": "ExternalLocationId",
            "type": "string"
        },
        {
            "name": "LocationAreaId",
            "baseName": "LocationAreaId",
            "type": "number"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LocationCreatedEvent.attributeTypeMap;
    }
}

/**
* Event for logging the deleting of Locations
*/
export class LocationDeletedEvent {
    /**
    * Location Id
    */
    'LocationId'?: number;
    /**
    * Location Name
    */
    'LocationName'?: string;
    /**
    * Location DisplayOrder
    */
    'DisplayOrder'?: number;
    /**
    * Location ExternalLocationId
    */
    'ExternalLocationId'?: string;
    /**
    * LocationAreaId
    */
    'LocationAreaId'?: number;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LocationId",
            "baseName": "LocationId",
            "type": "number"
        },
        {
            "name": "LocationName",
            "baseName": "LocationName",
            "type": "string"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "ExternalLocationId",
            "baseName": "ExternalLocationId",
            "type": "string"
        },
        {
            "name": "LocationAreaId",
            "baseName": "LocationAreaId",
            "type": "number"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LocationDeletedEvent.attributeTypeMap;
    }
}

/**
* Login model
*/
export class LoginModel {
    /**
    * Email address
    */
    'Email': string;
    /**
    * Password
    */
    'Password': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "Password",
            "baseName": "Password",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LoginModel.attributeTypeMap;
    }
}

/**
* Login with PIN model
*/
export class LoginWithPinModel {
    /**
    * Email addres
    */
    'Email': string;
    /**
    * PIN code (received via email)
    */
    'Pin': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "Pin",
            "baseName": "Pin",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return LoginWithPinModel.attributeTypeMap;
    }
}

/**
* Loyalty campaign
*/
export class LoyaltyCampaign {
    /**
    * Id of campaign
    */
    'CampaignId'?: number;
    /**
    * Statistics of campaign
    */
    'Statistics'?: CampaignStatistics;
    /**
    * Stores this campaign applies to with campaign start time in Utc
    */
    'Stores'?: Array<StoreCampaignStartTime>;
    /**
    * Permanent reference to the item.
    */
    'PublicId'?: string;
    /**
    * Number of orders customer needs to make, before receiving voucher
    */
    'OrdersBeforeReceivingVoucher'?: number;
    /**
    * Discount amount in percents
    */
    'PercentDiscountAmount'?: number;
    /**
    * Controls how the loyalty voucher's amount is rounded
    */
    'RoundingStrategy'?: number;
    /**
    * Controls whether we should include orders with loyalty vouchers in the campaign calculation
    */
    'ShouldIncludeOrdersWithLoyaltyVoucher'?: boolean;
    /**
    * Number of days for which the voucher will be valid.
    */
    'VoucherValidPeriodDays'?: number;
    /**
    * Discount will include delivery fee
    */
    'IncludeDeliveryFee'?: boolean;
    /**
    * Automatically apply resulting vouchers
    */
    'AutoApplyResultingVouchers'?: boolean;
    /**
    * Campaign will apply to existing orders
    */
    'IncludeExistingOrders'?: boolean;
    /**
    * Is campaign enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Ids of stores this campaign applies to
    */
    'StoreIds'?: Array<number>;
    /**
    * The app that this campaign belongs to.
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CampaignId",
            "baseName": "CampaignId",
            "type": "number"
        },
        {
            "name": "Statistics",
            "baseName": "Statistics",
            "type": "CampaignStatistics"
        },
        {
            "name": "Stores",
            "baseName": "Stores",
            "type": "Array<StoreCampaignStartTime>"
        },
        {
            "name": "PublicId",
            "baseName": "PublicId",
            "type": "string"
        },
        {
            "name": "OrdersBeforeReceivingVoucher",
            "baseName": "OrdersBeforeReceivingVoucher",
            "type": "number"
        },
        {
            "name": "PercentDiscountAmount",
            "baseName": "PercentDiscountAmount",
            "type": "number"
        },
        {
            "name": "RoundingStrategy",
            "baseName": "RoundingStrategy",
            "type": "number"
        },
        {
            "name": "ShouldIncludeOrdersWithLoyaltyVoucher",
            "baseName": "ShouldIncludeOrdersWithLoyaltyVoucher",
            "type": "boolean"
        },
        {
            "name": "VoucherValidPeriodDays",
            "baseName": "VoucherValidPeriodDays",
            "type": "number"
        },
        {
            "name": "IncludeDeliveryFee",
            "baseName": "IncludeDeliveryFee",
            "type": "boolean"
        },
        {
            "name": "AutoApplyResultingVouchers",
            "baseName": "AutoApplyResultingVouchers",
            "type": "boolean"
        },
        {
            "name": "IncludeExistingOrders",
            "baseName": "IncludeExistingOrders",
            "type": "boolean"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyCampaign.attributeTypeMap;
    }
}

/**
* Loyalty campaign base
*/
export class LoyaltyCampaignBase {
    /**
    * Number of orders customer needs to make, before receiving voucher
    */
    'OrdersBeforeReceivingVoucher'?: number;
    /**
    * Discount amount in percents
    */
    'PercentDiscountAmount'?: number;
    /**
    * Controls how the loyalty voucher's amount is rounded
    */
    'RoundingStrategy'?: number;
    /**
    * Controls whether we should include orders with loyalty vouchers in the campaign calculation
    */
    'ShouldIncludeOrdersWithLoyaltyVoucher'?: boolean;
    /**
    * Number of days for which the voucher will be valid.
    */
    'VoucherValidPeriodDays'?: number;
    /**
    * Discount will include delivery fee
    */
    'IncludeDeliveryFee'?: boolean;
    /**
    * Automatically apply resulting vouchers
    */
    'AutoApplyResultingVouchers'?: boolean;
    /**
    * Campaign will apply to existing orders
    */
    'IncludeExistingOrders'?: boolean;
    /**
    * Is campaign enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Ids of stores this campaign applies to
    */
    'StoreIds'?: Array<number>;
    /**
    * The app that this campaign belongs to.
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrdersBeforeReceivingVoucher",
            "baseName": "OrdersBeforeReceivingVoucher",
            "type": "number"
        },
        {
            "name": "PercentDiscountAmount",
            "baseName": "PercentDiscountAmount",
            "type": "number"
        },
        {
            "name": "RoundingStrategy",
            "baseName": "RoundingStrategy",
            "type": "number"
        },
        {
            "name": "ShouldIncludeOrdersWithLoyaltyVoucher",
            "baseName": "ShouldIncludeOrdersWithLoyaltyVoucher",
            "type": "boolean"
        },
        {
            "name": "VoucherValidPeriodDays",
            "baseName": "VoucherValidPeriodDays",
            "type": "number"
        },
        {
            "name": "IncludeDeliveryFee",
            "baseName": "IncludeDeliveryFee",
            "type": "boolean"
        },
        {
            "name": "AutoApplyResultingVouchers",
            "baseName": "AutoApplyResultingVouchers",
            "type": "boolean"
        },
        {
            "name": "IncludeExistingOrders",
            "baseName": "IncludeExistingOrders",
            "type": "boolean"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyCampaignBase.attributeTypeMap;
    }
}

/**
* Loyalty campaign created event
*/
export class LoyaltyCampaignCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The loyalty campaign
    */
    'LoyaltyCampaign'?: LoyaltyCampaign;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "LoyaltyCampaign",
            "baseName": "LoyaltyCampaign",
            "type": "LoyaltyCampaign"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyCampaignCreatedEvent.attributeTypeMap;
    }
}

/**
* Loyalty campaign deleted event
*/
export class LoyaltyCampaignDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The loyalty campaign
    */
    'LoyaltyCampaign'?: LoyaltyCampaign;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "LoyaltyCampaign",
            "baseName": "LoyaltyCampaign",
            "type": "LoyaltyCampaign"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyCampaignDeletedEvent.attributeTypeMap;
    }
}

/**
* Loyalty campaign updated event
*/
export class LoyaltyCampaignUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The loyalty campaign
    */
    'LoyaltyCampaign'?: LoyaltyCampaign;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "LoyaltyCampaign",
            "baseName": "LoyaltyCampaign",
            "type": "LoyaltyCampaign"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LoyaltyCampaignUpdatedEvent.attributeTypeMap;
    }
}

/**
* Lump discount details
*/
export class LumpDiscountDetails {
    /**
    * Discount amount
    */
    'DiscountAmount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DiscountAmount",
            "baseName": "DiscountAmount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return LumpDiscountDetails.attributeTypeMap;
    }
}

/**
* Representation of a Location and its External Mapping
*/
export class MappedLocation {
    /**
    * Id of the Location
    */
    'LocationId': number;
    /**
    * Id of the Location on an external system
    */
    'ExternalLocationId': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LocationId",
            "baseName": "LocationId",
            "type": "number"
        },
        {
            "name": "ExternalLocationId",
            "baseName": "ExternalLocationId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MappedLocation.attributeTypeMap;
    }
}

/**
* Represents a masked phone number
*/
export class MaskedPhoneNumber {
    /**
    * Defines if the feature is enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Defines the phone number to call
    */
    'PhoneNumber'?: string;
    /**
    * Defines the code to enter
    */
    'Code'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "PhoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        },
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MaskedPhoneNumber.attributeTypeMap;
    }
}

/**
* Menu
*/
export class Menu {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Last modified time
    */
    'ModifiedTime'?: Date;
    /**
    * Menu version
    */
    'VersionNumber'?: number;
    /**
    * Image Name
    */
    'ImageName'?: string;
    /**
    * Image url
    */
    'ImageUrl'?: string;
    /**
    * Name of Menu, only shown in portal
    */
    'Name'?: string;
    /**
    * Locked: is menu locked against modifcation
    */
    'Locked'?: boolean;
    /**
    * Menu sections (startes, main etc)
    */
    'MenuSections'?: Array<MenuSection>;
    /**
    * Menu tax rates
    */
    'TaxRates'?: Array<MenuTaxRate>;
    /**
    * Identifier of App the menu is attached to
    */
    'AppId'?: string;
    /**
    * Display menu section link on UI
    */
    'DisplaySectionLinks'?: boolean;
    /**
    * Menu section behaviour
    */
    'MenuSectionBehaviour'?: Menu.MenuSectionBehaviourEnum;
    /**
    * Tax type
    */
    'TaxType'?: Menu.TaxTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "ModifiedTime",
            "baseName": "ModifiedTime",
            "type": "Date"
        },
        {
            "name": "VersionNumber",
            "baseName": "VersionNumber",
            "type": "number"
        },
        {
            "name": "ImageName",
            "baseName": "ImageName",
            "type": "string"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Locked",
            "baseName": "Locked",
            "type": "boolean"
        },
        {
            "name": "MenuSections",
            "baseName": "MenuSections",
            "type": "Array<MenuSection>"
        },
        {
            "name": "TaxRates",
            "baseName": "TaxRates",
            "type": "Array<MenuTaxRate>"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "DisplaySectionLinks",
            "baseName": "DisplaySectionLinks",
            "type": "boolean"
        },
        {
            "name": "MenuSectionBehaviour",
            "baseName": "MenuSectionBehaviour",
            "type": "Menu.MenuSectionBehaviourEnum"
        },
        {
            "name": "TaxType",
            "baseName": "TaxType",
            "type": "Menu.TaxTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return Menu.attributeTypeMap;
    }
}

export namespace Menu {
    export enum MenuSectionBehaviourEnum {
        ExpandSingle = <any> 'ExpandSingle',
        ExpandMultiple = <any> 'ExpandMultiple'
    }
    export enum TaxTypeEnum {
        IncludedInBasePrice = <any> 'IncludedInBasePrice',
        ExcludedFromBasePrice = <any> 'ExcludedFromBasePrice'
    }
}
/**
* Menu async creation completed event
*/
export class MenuAsyncCreationCompletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * The menu
    */
    'Menu'?: Menu;
    /**
    * Flag indicating if the menu creation was successful
    */
    'Success'?: boolean;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Menu",
            "baseName": "Menu",
            "type": "Menu"
        },
        {
            "name": "Success",
            "baseName": "Success",
            "type": "boolean"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuAsyncCreationCompletedEvent.attributeTypeMap;
    }
}

/**
* Menu base
*/
export class MenuBase {
    /**
    * Display menu section link on UI
    */
    'DisplaySectionLinks'?: boolean;
    /**
    * Menu section behaviour
    */
    'MenuSectionBehaviour'?: MenuBase.MenuSectionBehaviourEnum;
    /**
    * Tax type
    */
    'TaxType'?: MenuBase.TaxTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DisplaySectionLinks",
            "baseName": "DisplaySectionLinks",
            "type": "boolean"
        },
        {
            "name": "MenuSectionBehaviour",
            "baseName": "MenuSectionBehaviour",
            "type": "MenuBase.MenuSectionBehaviourEnum"
        },
        {
            "name": "TaxType",
            "baseName": "TaxType",
            "type": "MenuBase.TaxTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuBase.attributeTypeMap;
    }
}

export namespace MenuBase {
    export enum MenuSectionBehaviourEnum {
        ExpandSingle = <any> 'ExpandSingle',
        ExpandMultiple = <any> 'ExpandMultiple'
    }
    export enum TaxTypeEnum {
        IncludedInBasePrice = <any> 'IncludedInBasePrice',
        ExcludedFromBasePrice = <any> 'ExcludedFromBasePrice'
    }
}
/**
* Menu bulk event
*/
export class MenuBulkEditEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Menu Name
    */
    'MenuName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Product
    */
    'Item'?: string;
    /**
    * Quantity of product
    */
    'InstanceCount'?: number;
    /**
    * Visibility of the item
    */
    'IsAvailable'?: boolean;
    /**
    * User who has uploaded the menu
    */
    'User'?: UserEventInfo;
    /**
    * The menu Id
    */
    'MenuId'?: number;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "MenuName",
            "baseName": "MenuName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Item",
            "baseName": "Item",
            "type": "string"
        },
        {
            "name": "InstanceCount",
            "baseName": "InstanceCount",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuBulkEditEvent.attributeTypeMap;
    }
}

/**
* Information to add a CatalogItem to a Menu
*/
export class MenuCatalogItem {
    /**
    * Product Id to the product to add as Menu Item
    */
    'CatalogItemId': string;
    /**
    * Small | Medium | Large | HiddenImage  Affects the layout of the menu.
    */
    'CellLayoutType'?: MenuCatalogItem.CellLayoutTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CatalogItemId",
            "baseName": "CatalogItemId",
            "type": "string"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "MenuCatalogItem.CellLayoutTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuCatalogItem.attributeTypeMap;
    }
}

export namespace MenuCatalogItem {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* Menu Checkpoint
*/
export class MenuCheckpoint {
    /**
    * Identifier of Menu Checkpoint
    */
    'MenuCheckpointId'?: number;
    /**
    * Time of creation of checkpoint
    */
    'Time'?: Date;
    /**
    * Name of checkpoint
    */
    'Name'?: string;
    /**
    * Url that points to Serialized Checkpoint
    */
    'Url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuCheckpointId",
            "baseName": "MenuCheckpointId",
            "type": "number"
        },
        {
            "name": "Time",
            "baseName": "Time",
            "type": "Date"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Url",
            "baseName": "Url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuCheckpoint.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuCheckpointCreatedEvent {
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Menu identifier
    */
    'Menu'?: Menu;
    /**
    * Menu Id
    */
    'MenuId'?: number;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Menu",
            "baseName": "Menu",
            "type": "Menu"
        },
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuCheckpointCreatedEvent.attributeTypeMap;
    }
}

/**
* Menu created event
*/
export class MenuCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * The menu
    */
    'Menu'?: Menu;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Menu",
            "baseName": "Menu",
            "type": "Menu"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuCreatedEvent.attributeTypeMap;
    }
}

/**
* Response with any menu elements that had issues being hidden/shown
*/
export class MenuElementEditResponse {
    /**
    * Section name
    */
    'SectionName'?: string;
    /**
    * Item name
    */
    'ItemName'?: string;
    /**
    * Option Set name
    */
    'OptionSetName'?: string;
    /**
    * Element name
    */
    'OptionSetItemName'?: string;
    /**
    * Holds the information for the A and CNAME Records of a domain.
    */
    'MenuElementId'?: number;
    /**
    * Type of menu element
    */
    'MenuElementType'?: MenuElementEditResponse.MenuElementTypeEnum;
    /**
    * Validation message for menu element issue
    */
    'ValidationCode'?: MenuElementEditResponse.ValidationCodeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "SectionName",
            "baseName": "SectionName",
            "type": "string"
        },
        {
            "name": "ItemName",
            "baseName": "ItemName",
            "type": "string"
        },
        {
            "name": "OptionSetName",
            "baseName": "OptionSetName",
            "type": "string"
        },
        {
            "name": "OptionSetItemName",
            "baseName": "OptionSetItemName",
            "type": "string"
        },
        {
            "name": "MenuElementId",
            "baseName": "MenuElementId",
            "type": "number"
        },
        {
            "name": "MenuElementType",
            "baseName": "MenuElementType",
            "type": "MenuElementEditResponse.MenuElementTypeEnum"
        },
        {
            "name": "ValidationCode",
            "baseName": "ValidationCode",
            "type": "MenuElementEditResponse.ValidationCodeEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuElementEditResponse.attributeTypeMap;
    }
}

export namespace MenuElementEditResponse {
    export enum MenuElementTypeEnum {
        Item = <any> 'Item',
        OptionSetItem = <any> 'OptionSetItem'
    }
    export enum ValidationCodeEnum {
        Success = <any> 'Success',
        MinimumCountViolation = <any> 'MinimumCountViolation',
        MasterOptionSetViolation = <any> 'MasterOptionSetViolation',
        IncorrectElementTypeInMenu = <any> 'IncorrectElementTypeInMenu',
        DBFailed = <any> 'DBFailed'
    }
}
/**
* Menu element hide
*/
export class MenuElementHide {
    /**
    * id of the menu item or menu option set item
    */
    'MenuElementId'?: number;
    /**
    * Type of menu element
    */
    'MenuElementType'?: MenuElementHide.MenuElementTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuElementId",
            "baseName": "MenuElementId",
            "type": "number"
        },
        {
            "name": "MenuElementType",
            "baseName": "MenuElementType",
            "type": "MenuElementHide.MenuElementTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuElementHide.attributeTypeMap;
    }
}

export namespace MenuElementHide {
    export enum MenuElementTypeEnum {
        Item = <any> 'Item',
        OptionSetItem = <any> 'OptionSetItem'
    }
}
/**
* Response with any menu elements that had issues being hidden/shown
*/
export class MenuElementListItemResponse {
    /**
    * Holds the information for the A and CNAME Records of a domain.
    */
    'MenuElementId'?: number;
    /**
    * Type of menu element
    */
    'MenuElementType'?: MenuElementListItemResponse.MenuElementTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuElementId",
            "baseName": "MenuElementId",
            "type": "number"
        },
        {
            "name": "MenuElementType",
            "baseName": "MenuElementType",
            "type": "MenuElementListItemResponse.MenuElementTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuElementListItemResponse.attributeTypeMap;
    }
}

export namespace MenuElementListItemResponse {
    export enum MenuElementTypeEnum {
        Item = <any> 'Item',
        OptionSetItem = <any> 'OptionSetItem'
    }
}
/**
* Response with any menu elements that had issues being hidden/shown
*/
export class MenuElementListResponse {
    /**
    * Menu Name
    */
    'MenuName'?: string;
    /**
    * Menu Item Name
    */
    'MenuElementName'?: string;
    /**
    * Menu Item Count
    */
    'InstanceCount'?: number;
    /**
    * Menu Item is hide or unhide
    */
    'IsAvailable'?: boolean;
    /**
    * List of Items
    */
    'Items'?: Array<MenuElementListItemResponse>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuName",
            "baseName": "MenuName",
            "type": "string"
        },
        {
            "name": "MenuElementName",
            "baseName": "MenuElementName",
            "type": "string"
        },
        {
            "name": "InstanceCount",
            "baseName": "InstanceCount",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "Items",
            "baseName": "Items",
            "type": "Array<MenuElementListItemResponse>"
        }    ];

    static getAttributeTypeMap() {
        return MenuElementListResponse.attributeTypeMap;
    }
}

/**
* Menu item option set
*/
export class MenuItemOptionSet {
    /**
    * Menu item option set identifier
    */
    'MenuItemOptionSetId'?: number;
    /**
    * Image Name
    */
    'ImageName'?: string;
    /**
    * Image url
    */
    'ImageUrl'?: string;
    /**
    * Option set items
    */
    'MenuItemOptionSetItems'?: Array<MenuItemOptionSetItem>;
    /**
    * Permanent reference to the item.
    */
    'PublicId'?: string;
    /**
    * Catalog item Id when the OptionSet is associated to a Product
    */
    'CatalogItemId'?: string;
    /**
    * Menu item option set name
    */
    'Name'?: string;
    /**
    * Is master option set. This can affect the layout of the options in the menu displayed to the customer. Usually it is true if the option could be considerd a standalone item as opposed to an addition (\"with ketchup\") or modifier (\"large\").
    */
    'IsMasterOptionSet'?: boolean;
    /**
    * Display order. Displayed in ascending order.
    */
    'DisplayOrder'?: number;
    /**
    * Minimum items must be selected
    */
    'MinSelectCount'?: number;
    /**
    * Maximum number of items can be selected
    */
    'MaxSelectCount'?: number;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: MenuItemOptionSet.CellLayoutTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuItemOptionSetId",
            "baseName": "MenuItemOptionSetId",
            "type": "number"
        },
        {
            "name": "ImageName",
            "baseName": "ImageName",
            "type": "string"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        },
        {
            "name": "MenuItemOptionSetItems",
            "baseName": "MenuItemOptionSetItems",
            "type": "Array<MenuItemOptionSetItem>"
        },
        {
            "name": "PublicId",
            "baseName": "PublicId",
            "type": "string"
        },
        {
            "name": "CatalogItemId",
            "baseName": "CatalogItemId",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "IsMasterOptionSet",
            "baseName": "IsMasterOptionSet",
            "type": "boolean"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "MinSelectCount",
            "baseName": "MinSelectCount",
            "type": "number"
        },
        {
            "name": "MaxSelectCount",
            "baseName": "MaxSelectCount",
            "type": "number"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "MenuItemOptionSet.CellLayoutTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSet.attributeTypeMap;
    }
}

export namespace MenuItemOptionSet {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* Menu item option set
*/
export class MenuItemOptionSetBase {
    /**
    * Menu item option set name
    */
    'Name'?: string;
    /**
    * Is master option set. This can affect the layout of the options in the menu displayed to the customer. Usually it is true if the option could be considerd a standalone item as opposed to an addition (\"with ketchup\") or modifier (\"large\").
    */
    'IsMasterOptionSet'?: boolean;
    /**
    * Display order. Displayed in ascending order.
    */
    'DisplayOrder'?: number;
    /**
    * Minimum items must be selected
    */
    'MinSelectCount'?: number;
    /**
    * Maximum number of items can be selected
    */
    'MaxSelectCount'?: number;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: MenuItemOptionSetBase.CellLayoutTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "IsMasterOptionSet",
            "baseName": "IsMasterOptionSet",
            "type": "boolean"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "MinSelectCount",
            "baseName": "MinSelectCount",
            "type": "number"
        },
        {
            "name": "MaxSelectCount",
            "baseName": "MaxSelectCount",
            "type": "number"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "MenuItemOptionSetBase.CellLayoutTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetBase.attributeTypeMap;
    }
}

export namespace MenuItemOptionSetBase {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* 
*/
export class MenuItemOptionSetCreatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Created menu item optionset
    */
    'MenuItemOptionSet'?: MenuItemOptionSet;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuItemOptionSet",
            "baseName": "MenuItemOptionSet",
            "type": "MenuItemOptionSet"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuItemOptionSetDeletedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Deleted menu item optionset
    */
    'MenuItemOptionSet'?: MenuItemOptionSet;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuItemOptionSet",
            "baseName": "MenuItemOptionSet",
            "type": "MenuItemOptionSet"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetDeletedEvent.attributeTypeMap;
    }
}

/**
* Menu item option set item
*/
export class MenuItemOptionSetItem {
    /**
    * Menu item option set item identifier
    */
    'MenuItemOptionSetItemId'?: number;
    /**
    * Permanent reference to the item.
    */
    'PublicId'?: string;
    /**
    * List of metadata
    */
    'Metadata'?: Array<CreateMetadata>;
    /**
    * if null, next option set is next. if -1, this is the final option set
    */
    'NextMenuItemOptionSetId'?: number;
    /**
    * Catalog item Id when the OptionSet is associated to a Product
    */
    'CatalogItemId'?: string;
    /**
    * Tax rate name
    */
    'TaxRateName'?: string;
    'TaxRateId'?: number;
    'TaxValue'?: number;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Price
    */
    'Price'?: number;
    /**
    * An optional fee that can be added to the price of the item.
    */
    'DepositReturnFee'?: number;
    /**
    * Is available
    */
    'IsAvailable'?: boolean;
    /**
    * Display order. Displayed in ascending order.
    */
    'DisplayOrder'?: number;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: MenuItemOptionSetItem.CellLayoutTypeEnum;
    /**
    * Image url
    */
    'ImageUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuItemOptionSetItemId",
            "baseName": "MenuItemOptionSetItemId",
            "type": "number"
        },
        {
            "name": "PublicId",
            "baseName": "PublicId",
            "type": "string"
        },
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "Array<CreateMetadata>"
        },
        {
            "name": "NextMenuItemOptionSetId",
            "baseName": "NextMenuItemOptionSetId",
            "type": "number"
        },
        {
            "name": "CatalogItemId",
            "baseName": "CatalogItemId",
            "type": "string"
        },
        {
            "name": "TaxRateName",
            "baseName": "TaxRateName",
            "type": "string"
        },
        {
            "name": "TaxRateId",
            "baseName": "TaxRateId",
            "type": "number"
        },
        {
            "name": "TaxValue",
            "baseName": "TaxValue",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "DepositReturnFee",
            "baseName": "DepositReturnFee",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "MenuItemOptionSetItem.CellLayoutTypeEnum"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetItem.attributeTypeMap;
    }
}

export namespace MenuItemOptionSetItem {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* Menu item option set item
*/
export class MenuItemOptionSetItemBase {
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Price
    */
    'Price'?: number;
    /**
    * An optional fee that can be added to the price of the item.
    */
    'DepositReturnFee'?: number;
    /**
    * Is available
    */
    'IsAvailable'?: boolean;
    /**
    * Display order. Displayed in ascending order.
    */
    'DisplayOrder'?: number;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: MenuItemOptionSetItemBase.CellLayoutTypeEnum;
    /**
    * Image url
    */
    'ImageUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "DepositReturnFee",
            "baseName": "DepositReturnFee",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "MenuItemOptionSetItemBase.CellLayoutTypeEnum"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetItemBase.attributeTypeMap;
    }
}

export namespace MenuItemOptionSetItemBase {
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* 
*/
export class MenuItemOptionSetItemCreatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Created menu item optionset item
    */
    'MenuItemOptionSetItem'?: MenuItemOptionSetItem;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuItemOptionSetItem",
            "baseName": "MenuItemOptionSetItem",
            "type": "MenuItemOptionSetItem"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetItemCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuItemOptionSetItemDeletedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Deleted menu item optionset item
    */
    'MenuItemOptionSetItem'?: MenuItemOptionSetItem;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuItemOptionSetItem",
            "baseName": "MenuItemOptionSetItem",
            "type": "MenuItemOptionSetItem"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetItemDeletedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuItemOptionSetItemUpdatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Updated menu item optionset item
    */
    'MenuItemOptionSetItem'?: MenuItemOptionSetItem;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuItemOptionSetItem",
            "baseName": "MenuItemOptionSetItem",
            "type": "MenuItemOptionSetItem"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetItemUpdatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuItemOptionSetUpdatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Updated menu item optionset
    */
    'MenuItemOptionSet'?: MenuItemOptionSet;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuItemOptionSet",
            "baseName": "MenuItemOptionSet",
            "type": "MenuItemOptionSet"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuItemOptionSetUpdatedEvent.attributeTypeMap;
    }
}

export class MenuNutritionInfoHeader {
    /**
    * Menu Id
    */
    'MenuId'?: number;
    /**
    * Nutrition information version guid (generated every time the nutrition information is updated)
    */
    'NutritionInfoVersionGuid'?: string;
    /**
    * Absolute URL of the nutrition information json file
    */
    'AbsoluteUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "NutritionInfoVersionGuid",
            "baseName": "NutritionInfoVersionGuid",
            "type": "string"
        },
        {
            "name": "AbsoluteUrl",
            "baseName": "AbsoluteUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuNutritionInfoHeader.attributeTypeMap;
    }
}

/**
* Collection of Display Orders for a Menu Object (Menu Section / Menu Items / Option Sets etc)
*/
export class MenuObjectDisplayOrders {
    /**
    * List of Objects and their new Display Orders
    */
    'DisplayOrders'?: Array<ObjectDisplayOrder>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DisplayOrders",
            "baseName": "DisplayOrders",
            "type": "Array<ObjectDisplayOrder>"
        }    ];

    static getAttributeTypeMap() {
        return MenuObjectDisplayOrders.attributeTypeMap;
    }
}

/**
* Menu section
*/
export class MenuSection {
    /**
    * Menu section identifier
    */
    'MenuSectionId'?: number;
    /**
    * Menu items
    */
    'MenuItems'?: Array<MenuSectionItem>;
    /**
    * Menu section availability
    */
    'MenuSectionAvailability'?: MenuSectionAvailability;
    /**
    * Permanent reference to the item.
    */
    'PublicId'?: string;
    /**
    * Image Name
    */
    'ImageName'?: string;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Display order
    */
    'DisplayOrder'?: number;
    /**
    * Is available
    */
    'IsAvailable'?: boolean;
    /**
    * Is hidden from customer. Perhaps when the item is out of stock.
    */
    'IsHiddenFromCustomers'?: boolean;
    /**
    * Image url
    */
    'ImageUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuSectionId",
            "baseName": "MenuSectionId",
            "type": "number"
        },
        {
            "name": "MenuItems",
            "baseName": "MenuItems",
            "type": "Array<MenuSectionItem>"
        },
        {
            "name": "MenuSectionAvailability",
            "baseName": "MenuSectionAvailability",
            "type": "MenuSectionAvailability"
        },
        {
            "name": "PublicId",
            "baseName": "PublicId",
            "type": "string"
        },
        {
            "name": "ImageName",
            "baseName": "ImageName",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "IsHiddenFromCustomers",
            "baseName": "IsHiddenFromCustomers",
            "type": "boolean"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuSection.attributeTypeMap;
    }
}

/**
* Menu section availability
*/
export class MenuSectionAvailability {
    /**
    * Available times
    */
    'AvailableTimes'?: Array<BusinessHoursPeriod>;
    /**
    * Availability mode
    */
    'AvailabilityMode'?: MenuSectionAvailability.AvailabilityModeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AvailableTimes",
            "baseName": "AvailableTimes",
            "type": "Array<BusinessHoursPeriod>"
        },
        {
            "name": "AvailabilityMode",
            "baseName": "AvailabilityMode",
            "type": "MenuSectionAvailability.AvailabilityModeEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionAvailability.attributeTypeMap;
    }
}

export namespace MenuSectionAvailability {
    export enum AvailabilityModeEnum {
        DisplayAlways = <any> 'DisplayAlways',
        DisplayBasedOnTimes = <any> 'DisplayBasedOnTimes',
        DisplayAlwaysStartCollapsed = <any> 'DisplayAlwaysStartCollapsed',
        DisplayAlwaysStartCollapsedBasedOnTimes = <any> 'DisplayAlwaysStartCollapsedBasedOnTimes'
    }
}
/**
* Menu section availability
*/
export class MenuSectionAvailabilityBase {
    /**
    * Availability mode
    */
    'AvailabilityMode'?: MenuSectionAvailabilityBase.AvailabilityModeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AvailabilityMode",
            "baseName": "AvailabilityMode",
            "type": "MenuSectionAvailabilityBase.AvailabilityModeEnum"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionAvailabilityBase.attributeTypeMap;
    }
}

export namespace MenuSectionAvailabilityBase {
    export enum AvailabilityModeEnum {
        DisplayAlways = <any> 'DisplayAlways',
        DisplayBasedOnTimes = <any> 'DisplayBasedOnTimes',
        DisplayAlwaysStartCollapsed = <any> 'DisplayAlwaysStartCollapsed',
        DisplayAlwaysStartCollapsedBasedOnTimes = <any> 'DisplayAlwaysStartCollapsedBasedOnTimes'
    }
}
/**
* Menu section
*/
export class MenuSectionBase {
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Display order
    */
    'DisplayOrder'?: number;
    /**
    * Is available
    */
    'IsAvailable'?: boolean;
    /**
    * Is hidden from customer. Perhaps when the item is out of stock.
    */
    'IsHiddenFromCustomers'?: boolean;
    /**
    * Image url
    */
    'ImageUrl'?: string;
    /**
    * Menu Section Id
    */
    'MenuSectionId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "IsHiddenFromCustomers",
            "baseName": "IsHiddenFromCustomers",
            "type": "boolean"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        },
        {
            "name": "MenuSectionId",
            "baseName": "MenuSectionId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionBase.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuSectionCreatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Created menu section
    */
    'MenuSection'?: MenuSection;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuSection",
            "baseName": "MenuSection",
            "type": "MenuSection"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuSectionDeletedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Deleted menu section
    */
    'MenuSection'?: MenuSection;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuSection",
            "baseName": "MenuSection",
            "type": "MenuSection"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionDeletedEvent.attributeTypeMap;
    }
}

/**
* Menu item
*/
export class MenuSectionItem {
    /**
    * Actual price - the minimum price possible when all required option set items prices are included.
    */
    'ActualPrice'?: number;
    /**
    * Menu item option sets
    */
    'MenuItemOptionSets'?: Array<MenuItemOptionSet>;
    /**
    * Daily special hours
    */
    'DailySpecialHours'?: Array<BusinessHoursPeriod>;
    /**
    * Permanent reference to the item.
    */
    'PublicId'?: string;
    /**
    * Tax rate name
    */
    'TaxRateName'?: string;
    /**
    * TaxRate
    */
    'TaxRateId'?: number;
    /**
    * TaxValue - the tax associated with this item, based on TaxRate / TaxType and Currency (currency determines decimal point precision)
    */
    'TaxValue'?: number;
    /**
    * If true, the item is excluded from voucher discount calculations
    */
    'ExcludeFromVoucherDiscounting'?: boolean;
    /**
    * List of metadata
    */
    'Metadata'?: Array<CreateMetadata>;
    /**
    * Catalog item Id when the Item is associated to a Product
    */
    'CatalogItemId'?: string;
    /**
    * Menu item name (like \"Korma\")
    */
    'Name'?: string;
    /**
    * Description (like \"A lovely dish from the east\")
    */
    'Description'?: string;
    /**
    * Spiciness rating
    */
    'SpicinessRating'?: MenuSectionItem.SpicinessRatingEnum;
    /**
    * Price - this is only used when there is no master option set and should be set to 0 if a master option set exists.
    */
    'Price'?: number;
    /**
    * An optional fee that can be added to the price of the item.
    */
    'DepositReturnFee'?: number;
    /**
    * Display order
    */
    'DisplayOrder'?: number;
    /**
    * To be set true if the item or an option of the item contains an alcoholic drink.
    */
    'Alcohol'?: boolean;
    /**
    * True if we accept orders for this item still
    */
    'IsAvailable'?: boolean;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: MenuSectionItem.CellLayoutTypeEnum;
    /**
    * If true, then vouchers won't be applied for this item
    */
    'DisableVouchers'?: boolean;
    /**
    * Image url
    */
    'ImageName'?: string;
    /**
    * Image url
    */
    'ImageUrl'?: string;
    /**
    * Menu Item Id
    */
    'MenuItemId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ActualPrice",
            "baseName": "ActualPrice",
            "type": "number"
        },
        {
            "name": "MenuItemOptionSets",
            "baseName": "MenuItemOptionSets",
            "type": "Array<MenuItemOptionSet>"
        },
        {
            "name": "DailySpecialHours",
            "baseName": "DailySpecialHours",
            "type": "Array<BusinessHoursPeriod>"
        },
        {
            "name": "PublicId",
            "baseName": "PublicId",
            "type": "string"
        },
        {
            "name": "TaxRateName",
            "baseName": "TaxRateName",
            "type": "string"
        },
        {
            "name": "TaxRateId",
            "baseName": "TaxRateId",
            "type": "number"
        },
        {
            "name": "TaxValue",
            "baseName": "TaxValue",
            "type": "number"
        },
        {
            "name": "ExcludeFromVoucherDiscounting",
            "baseName": "ExcludeFromVoucherDiscounting",
            "type": "boolean"
        },
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "Array<CreateMetadata>"
        },
        {
            "name": "CatalogItemId",
            "baseName": "CatalogItemId",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "SpicinessRating",
            "baseName": "SpicinessRating",
            "type": "MenuSectionItem.SpicinessRatingEnum"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "DepositReturnFee",
            "baseName": "DepositReturnFee",
            "type": "number"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "Alcohol",
            "baseName": "Alcohol",
            "type": "boolean"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "MenuSectionItem.CellLayoutTypeEnum"
        },
        {
            "name": "DisableVouchers",
            "baseName": "DisableVouchers",
            "type": "boolean"
        },
        {
            "name": "ImageName",
            "baseName": "ImageName",
            "type": "string"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        },
        {
            "name": "MenuItemId",
            "baseName": "MenuItemId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionItem.attributeTypeMap;
    }
}

export namespace MenuSectionItem {
    export enum SpicinessRatingEnum {
        NotRated = <any> 'NotRated',
        Mild = <any> 'Mild',
        Medium = <any> 'Medium',
        Hot = <any> 'Hot'
    }
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* Menu item
*/
export class MenuSectionItemBase {
    /**
    * Menu item name (like \"Korma\")
    */
    'Name'?: string;
    /**
    * Description (like \"A lovely dish from the east\")
    */
    'Description'?: string;
    /**
    * Spiciness rating
    */
    'SpicinessRating'?: MenuSectionItemBase.SpicinessRatingEnum;
    /**
    * Price - this is only used when there is no master option set and should be set to 0 if a master option set exists.
    */
    'Price'?: number;
    /**
    * An optional fee that can be added to the price of the item.
    */
    'DepositReturnFee'?: number;
    /**
    * Display order
    */
    'DisplayOrder'?: number;
    /**
    * To be set true if the item or an option of the item contains an alcoholic drink.
    */
    'Alcohol'?: boolean;
    /**
    * True if we accept orders for this item still
    */
    'IsAvailable'?: boolean;
    /**
    * Small | Medium | Large  Affects the layout of the menu.
    */
    'CellLayoutType'?: MenuSectionItemBase.CellLayoutTypeEnum;
    /**
    * If true, then vouchers won't be applied for this item
    */
    'DisableVouchers'?: boolean;
    /**
    * Image url
    */
    'ImageName'?: string;
    /**
    * Image url
    */
    'ImageUrl'?: string;
    /**
    * Menu Item Id
    */
    'MenuItemId'?: number;
    /**
    * If true, the item is excluded from voucher discount calculations
    */
    'ExcludeFromVoucherDiscounting'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "SpicinessRating",
            "baseName": "SpicinessRating",
            "type": "MenuSectionItemBase.SpicinessRatingEnum"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "DepositReturnFee",
            "baseName": "DepositReturnFee",
            "type": "number"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        },
        {
            "name": "Alcohol",
            "baseName": "Alcohol",
            "type": "boolean"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "CellLayoutType",
            "baseName": "CellLayoutType",
            "type": "MenuSectionItemBase.CellLayoutTypeEnum"
        },
        {
            "name": "DisableVouchers",
            "baseName": "DisableVouchers",
            "type": "boolean"
        },
        {
            "name": "ImageName",
            "baseName": "ImageName",
            "type": "string"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        },
        {
            "name": "MenuItemId",
            "baseName": "MenuItemId",
            "type": "number"
        },
        {
            "name": "ExcludeFromVoucherDiscounting",
            "baseName": "ExcludeFromVoucherDiscounting",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionItemBase.attributeTypeMap;
    }
}

export namespace MenuSectionItemBase {
    export enum SpicinessRatingEnum {
        NotRated = <any> 'NotRated',
        Mild = <any> 'Mild',
        Medium = <any> 'Medium',
        Hot = <any> 'Hot'
    }
    export enum CellLayoutTypeEnum {
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        HiddenImage = <any> 'HiddenImage'
    }
}
/**
* 
*/
export class MenuSectionItemCreatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the menu
    */
    'User'?: UserEventInfo;
    /**
    * Created menu section item
    */
    'MenuSectionItem'?: MenuSectionItem;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuSectionItem",
            "baseName": "MenuSectionItem",
            "type": "MenuSectionItem"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionItemCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuSectionItemDeletedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Event description
    */
    'Description'?: string;
    /**
    * Deleted by user
    */
    'User'?: UserEventInfo;
    /**
    * Deleted menu section item
    */
    'MenuSectionItem'?: MenuSectionItem;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuSectionItem",
            "baseName": "MenuSectionItem",
            "type": "MenuSectionItem"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionItemDeletedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuSectionItemUpdatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Event description
    */
    'Description'?: string;
    /**
    * Updated by user
    */
    'User'?: UserEventInfo;
    /**
    * Updated menu section item
    */
    'MenuSectionItem'?: MenuSectionItem;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuSectionItem",
            "baseName": "MenuSectionItem",
            "type": "MenuSectionItem"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionItemUpdatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class MenuSectionUpdatedEvent {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Event description
    */
    'Description'?: string;
    /**
    * Updated by user
    */
    'User'?: UserEventInfo;
    /**
    * Updated menu section
    */
    'MenuSection'?: MenuSection;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MenuSection",
            "baseName": "MenuSection",
            "type": "MenuSection"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuSectionUpdatedEvent.attributeTypeMap;
    }
}

/**
* Menu Store Names
*/
export class MenuStoreNames {
    /**
    * Names of stores associated with menu
    */
    'StoreNames'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return MenuStoreNames.attributeTypeMap;
    }
}

/**
* Menu Summary
*/
export class MenuSummary {
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Last modified time
    */
    'ModifiedTime'?: Date;
    /**
    * Menu version
    */
    'VersionNumber'?: number;
    /**
    * Menu Url
    */
    'MenuUrl'?: string;
    /**
    * Name of Menu, only shown in portal
    */
    'Name'?: string;
    /**
    * Locked: is menu locked against modifcation
    */
    'Locked'?: boolean;
    /**
    * List of stores names which are associated with this menu
    */
    'StoreNames'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "ModifiedTime",
            "baseName": "ModifiedTime",
            "type": "Date"
        },
        {
            "name": "VersionNumber",
            "baseName": "VersionNumber",
            "type": "number"
        },
        {
            "name": "MenuUrl",
            "baseName": "MenuUrl",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Locked",
            "baseName": "Locked",
            "type": "boolean"
        },
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return MenuSummary.attributeTypeMap;
    }
}

/**
* Tax information for Menu
*/
export class MenuTaxDetails {
    /**
    * Tax Rates
    */
    'TaxRates'?: Array<MenuTaxRate>;
    /**
    * Display tax for Menu
    */
    'DisplayTax'?: boolean;
    /**
    * TaxType
    */
    'TaxType'?: MenuTaxDetails.TaxTypeEnum;
    /**
    * ItemIds and TaxIds
    */
    'ItemTaxes'?: { [key: string]: number; };
    /**
    * SetItemIds and TaxIds
    */
    'SetItemTaxes'?: { [key: string]: number; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TaxRates",
            "baseName": "TaxRates",
            "type": "Array<MenuTaxRate>"
        },
        {
            "name": "DisplayTax",
            "baseName": "DisplayTax",
            "type": "boolean"
        },
        {
            "name": "TaxType",
            "baseName": "TaxType",
            "type": "MenuTaxDetails.TaxTypeEnum"
        },
        {
            "name": "ItemTaxes",
            "baseName": "ItemTaxes",
            "type": "{ [key: string]: number; }"
        },
        {
            "name": "SetItemTaxes",
            "baseName": "SetItemTaxes",
            "type": "{ [key: string]: number; }"
        }    ];

    static getAttributeTypeMap() {
        return MenuTaxDetails.attributeTypeMap;
    }
}

export namespace MenuTaxDetails {
    export enum TaxTypeEnum {
        IncludedInBasePrice = <any> 'IncludedInBasePrice',
        ExcludedFromBasePrice = <any> 'ExcludedFromBasePrice'
    }
}
/**
* Tax Rates Associated with a Menu
*/
export class MenuTaxRate {
    /**
    * Id of Tax Rate
    */
    'TaxRateId'?: number;
    /**
    * Name of Tax Rate
    */
    'Name'?: string;
    /**
    * In Percentage
    */
    'Rate'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TaxRateId",
            "baseName": "TaxRateId",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Rate",
            "baseName": "Rate",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return MenuTaxRate.attributeTypeMap;
    }
}

/**
* Menu updated event
*/
export class MenuUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has updated the menu
    */
    'User'?: UserEventInfo;
    /**
    * The menu
    */
    'Menu'?: Menu;
    /**
    * Menu Id
    */
    'MenuId'?: number;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Menu",
            "baseName": "Menu",
            "type": "Menu"
        },
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuUpdatedEvent.attributeTypeMap;
    }
}

/**
* Menu uploaded event
*/
export class MenuUploadedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has uploaded the menu
    */
    'User'?: UserEventInfo;
    /**
    * The menu
    */
    'Menu'?: Menu;
    /**
    * Quantity of events
    */
    'InstanceEventCount'?: string;
    /**
    * The menu Id
    */
    'MenuId'?: number;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Menu",
            "baseName": "Menu",
            "type": "Menu"
        },
        {
            "name": "InstanceEventCount",
            "baseName": "InstanceEventCount",
            "type": "string"
        },
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuUploadedEvent.attributeTypeMap;
    }
}

export class MenuZone {
    'MenuZoneId'?: number;
    'MenuId'?: number;
    'Name'?: string;
    'Description'?: string;
    'ImageName'?: string;
    'DisplayOrder'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuZoneId",
            "baseName": "MenuZoneId",
            "type": "number"
        },
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "ImageName",
            "baseName": "ImageName",
            "type": "string"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return MenuZone.attributeTypeMap;
    }
}

/**
* Metadata
*/
export class Metadata {
    /**
    * Menu entity identifier (eg: MenuItemId, MenuItemOptionSetItemId)
    */
    'MenuEntityId'?: number;
    /**
    * Metadata key (Unique identifier)
    */
    'Key'?: string;
    /**
    * Metadata value
    */
    'Value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuEntityId",
            "baseName": "MenuEntityId",
            "type": "number"
        },
        {
            "name": "Key",
            "baseName": "Key",
            "type": "string"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Metadata.attributeTypeMap;
    }
}

/**
* Metafield
*/
export class Metafield {
    /**
    * Key of the metafield.  Allowed characters: lowercase letters, numbers, hyphen, underscore and dot
    */
    'Key': string;
    /**
    * Value of the metafield.
    */
    'Value': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Key",
            "baseName": "Key",
            "type": "string"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Metafield.attributeTypeMap;
    }
}

/**
* Metafield Definition
*/
export class MetafieldDefinition {
    /**
    * Indicates if a definition can be edited or not
    */
    'IsReadOnly'?: boolean;
    /**
    * The Metafield will extend the specified {Flipdish.Metafields.PublicModels.V1.MetafieldDefinitionBase.OwnerEntity}
    */
    'OwnerEntity'?: MetafieldDefinition.OwnerEntityEnum;
    /**
    * Key of the metafield.  The key must have two parts, separated by a dot. The first part acts as a category, for organizational purposes.  The parts can be composed of lowercase letters, numbers, hyphen and underscore
    */
    'Key': string;
    /**
    * The excepted type for the Value field
    */
    'ValueType'?: MetafieldDefinition.ValueTypeEnum;
    /**
    * Field Name
    */
    'Name': string;
    /**
    * Field Description
    */
    'Description'?: string;
    /**
    * Enable Metafield Behaviors
    */
    'Behaviors'?: Array<MetafieldDefinition.BehaviorsEnum>;
    /**
    * Metafield Recommendation Id
    */
    'MetafieldDefinitionRecommendationId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IsReadOnly",
            "baseName": "IsReadOnly",
            "type": "boolean"
        },
        {
            "name": "OwnerEntity",
            "baseName": "OwnerEntity",
            "type": "MetafieldDefinition.OwnerEntityEnum"
        },
        {
            "name": "Key",
            "baseName": "Key",
            "type": "string"
        },
        {
            "name": "ValueType",
            "baseName": "ValueType",
            "type": "MetafieldDefinition.ValueTypeEnum"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Behaviors",
            "baseName": "Behaviors",
            "type": "Array<MetafieldDefinition.BehaviorsEnum>"
        },
        {
            "name": "MetafieldDefinitionRecommendationId",
            "baseName": "MetafieldDefinitionRecommendationId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return MetafieldDefinition.attributeTypeMap;
    }
}

export namespace MetafieldDefinition {
    export enum OwnerEntityEnum {
        CatalogItem = <any> 'CatalogItem',
        CatalogGroup = <any> 'CatalogGroup',
        Menu = <any> 'Menu'
    }
    export enum ValueTypeEnum {
        Boolean = <any> 'Boolean',
        Json = <any> 'Json',
        SingleLineString = <any> 'SingleLineString',
        MultiLineString = <any> 'MultiLineString'
    }
    export enum BehaviorsEnum {
        SendToOrder = <any> 'SendToOrder',
        SendToMenu = <any> 'SendToMenu'
    }
}
/**
* OwnerEntity Metafield Definition Recommendation
*/
export class MetafieldDefinitionRecommendation {
    /**
    * The Metafield will extend the specified {Flipdish.Metafields.PublicModels.V1.MetafieldDefinitionBase.OwnerEntity}
    */
    'OwnerEntity'?: MetafieldDefinitionRecommendation.OwnerEntityEnum;
    /**
    * Key of the metafield.  The key must have two parts, separated by a dot. The first part acts as a category, for organizational purposes.  The parts can be composed of lowercase letters, numbers, hyphen and underscore
    */
    'Key': string;
    /**
    * The excepted type for the Value field
    */
    'ValueType'?: MetafieldDefinitionRecommendation.ValueTypeEnum;
    /**
    * Field Name
    */
    'Name': string;
    /**
    * Field Description
    */
    'Description'?: string;
    /**
    * Enable Metafield Behaviors
    */
    'Behaviors'?: Array<MetafieldDefinitionRecommendation.BehaviorsEnum>;
    /**
    * Metafield Recommendation Id
    */
    'MetafieldDefinitionRecommendationId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OwnerEntity",
            "baseName": "OwnerEntity",
            "type": "MetafieldDefinitionRecommendation.OwnerEntityEnum"
        },
        {
            "name": "Key",
            "baseName": "Key",
            "type": "string"
        },
        {
            "name": "ValueType",
            "baseName": "ValueType",
            "type": "MetafieldDefinitionRecommendation.ValueTypeEnum"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Behaviors",
            "baseName": "Behaviors",
            "type": "Array<MetafieldDefinitionRecommendation.BehaviorsEnum>"
        },
        {
            "name": "MetafieldDefinitionRecommendationId",
            "baseName": "MetafieldDefinitionRecommendationId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return MetafieldDefinitionRecommendation.attributeTypeMap;
    }
}

export namespace MetafieldDefinitionRecommendation {
    export enum OwnerEntityEnum {
        CatalogItem = <any> 'CatalogItem',
        CatalogGroup = <any> 'CatalogGroup',
        Menu = <any> 'Menu'
    }
    export enum ValueTypeEnum {
        Boolean = <any> 'Boolean',
        Json = <any> 'Json',
        SingleLineString = <any> 'SingleLineString',
        MultiLineString = <any> 'MultiLineString'
    }
    export enum BehaviorsEnum {
        SendToOrder = <any> 'SendToOrder',
        SendToMenu = <any> 'SendToMenu'
    }
}
/**
* Mobile Apps Image
*/
export class MobileAppsImage {
    /**
    * Unique catalog Item id
    */
    'ImageUri'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ImageUri",
            "baseName": "ImageUri",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MobileAppsImage.attributeTypeMap;
    }
}

/**
* Mobile Apps Statistics
*/
export class MobileAppsStatistics {
    /**
    * Number Download
    */
    'NumberDownload'?: number;
    /**
    * Current Rate
    */
    'CurrentRate'?: number;
    /**
    * Current Version
    */
    'CurrentVersion'?: string;
    /**
    * Play Store Link
    */
    'PlayStoreLink'?: string;
    /**
    * App Bundle Id
    */
    'AppBundleId'?: string;
    /**
    * Last Updated
    */
    'LastUpdated'?: Date;
    /**
    * Last Updated
    */
    'Notes'?: string;
    /**
    * Published
    */
    'Published'?: boolean;
    /**
    * Platform Type
    */
    'PlatformType'?: MobileAppsStatistics.PlatformTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "NumberDownload",
            "baseName": "NumberDownload",
            "type": "number"
        },
        {
            "name": "CurrentRate",
            "baseName": "CurrentRate",
            "type": "number"
        },
        {
            "name": "CurrentVersion",
            "baseName": "CurrentVersion",
            "type": "string"
        },
        {
            "name": "PlayStoreLink",
            "baseName": "PlayStoreLink",
            "type": "string"
        },
        {
            "name": "AppBundleId",
            "baseName": "AppBundleId",
            "type": "string"
        },
        {
            "name": "LastUpdated",
            "baseName": "LastUpdated",
            "type": "Date"
        },
        {
            "name": "Notes",
            "baseName": "Notes",
            "type": "string"
        },
        {
            "name": "Published",
            "baseName": "Published",
            "type": "boolean"
        },
        {
            "name": "PlatformType",
            "baseName": "PlatformType",
            "type": "MobileAppsStatistics.PlatformTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return MobileAppsStatistics.attributeTypeMap;
    }
}

export namespace MobileAppsStatistics {
    export enum PlatformTypeEnum {
        None = <any> 'None',
        Android = <any> 'Android',
        IOS = <any> 'IOS'
    }
}
/**
* Mobile Apps form submission
*/
export class MobileAppsSubmission {
    /**
    * Mobile Apps Submission Id
    */
    'SubmissionId'?: number;
    /**
    * App Name
    */
    'AppName': string;
    /**
    * App Description
    */
    'AppDescription': string;
    /**
    * App Description
    */
    'AppShortDescription': string;
    /**
    * Keywords
    */
    'Keywords'?: Array<string>;
    /**
    * Publish automatically
    */
    'AutoPublish'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "SubmissionId",
            "baseName": "SubmissionId",
            "type": "number"
        },
        {
            "name": "AppName",
            "baseName": "AppName",
            "type": "string"
        },
        {
            "name": "AppDescription",
            "baseName": "AppDescription",
            "type": "string"
        },
        {
            "name": "AppShortDescription",
            "baseName": "AppShortDescription",
            "type": "string"
        },
        {
            "name": "Keywords",
            "baseName": "Keywords",
            "type": "Array<string>"
        },
        {
            "name": "AutoPublish",
            "baseName": "AutoPublish",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return MobileAppsSubmission.attributeTypeMap;
    }
}

/**
* Mobile Apps form submission
*/
export class MobileAppsSubmissionDetails {
    /**
    * Mobile Apps Submission Id
    */
    'MobileAppsSubmissionId'?: number;
    /**
    * App Name
    */
    'AppName'?: string;
    /**
    * App Description
    */
    'AppDescription'?: string;
    /**
    * App Description
    */
    'AppShortDescription'?: string;
    /**
    * Keywords
    */
    'Keywords'?: Array<string>;
    /**
    * Logo URL
    */
    'AppLogoUrl'?: string;
    /**
    * Publish automatically
    */
    'AutoPublish'?: boolean;
    /**
    * Mobile App Status
    */
    'Status'?: Array<MobileAppsSubmissionStatus>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MobileAppsSubmissionId",
            "baseName": "MobileAppsSubmissionId",
            "type": "number"
        },
        {
            "name": "AppName",
            "baseName": "AppName",
            "type": "string"
        },
        {
            "name": "AppDescription",
            "baseName": "AppDescription",
            "type": "string"
        },
        {
            "name": "AppShortDescription",
            "baseName": "AppShortDescription",
            "type": "string"
        },
        {
            "name": "Keywords",
            "baseName": "Keywords",
            "type": "Array<string>"
        },
        {
            "name": "AppLogoUrl",
            "baseName": "AppLogoUrl",
            "type": "string"
        },
        {
            "name": "AutoPublish",
            "baseName": "AutoPublish",
            "type": "boolean"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "Array<MobileAppsSubmissionStatus>"
        }    ];

    static getAttributeTypeMap() {
        return MobileAppsSubmissionDetails.attributeTypeMap;
    }
}

/**
* Mobile Apps Status
*/
export class MobileAppsSubmissionStatus {
    /**
    * Mobile Apps Submission Status Id
    */
    'MobileAppsSubmissionStatusId'?: number;
    /**
    * Mobile Apps Submission Id
    */
    'MobileAppsSubmissionId'?: number;
    /**
    * Mobile Type
    */
    'Type'?: MobileAppsSubmissionStatus.TypeEnum;
    /**
    * Mobile App Status
    */
    'AppStatus'?: MobileAppsSubmissionStatus.AppStatusEnum;
    /**
    * Mobile App Status
    */
    'UpdateStatus'?: MobileAppsSubmissionStatus.UpdateStatusEnum;
    /**
    * Mobile LastUpdateStatusTime
    */
    'LastUpdateStatusTime'?: Date;
    /**
    * Mobile CreateTime
    */
    'CreateTime'?: Date;
    /**
    * Mobile UpdateTime
    */
    'UpdateTime'?: Date;
    /**
    * Mobile Notes
    */
    'Notes'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MobileAppsSubmissionStatusId",
            "baseName": "MobileAppsSubmissionStatusId",
            "type": "number"
        },
        {
            "name": "MobileAppsSubmissionId",
            "baseName": "MobileAppsSubmissionId",
            "type": "number"
        },
        {
            "name": "Type",
            "baseName": "Type",
            "type": "MobileAppsSubmissionStatus.TypeEnum"
        },
        {
            "name": "AppStatus",
            "baseName": "AppStatus",
            "type": "MobileAppsSubmissionStatus.AppStatusEnum"
        },
        {
            "name": "UpdateStatus",
            "baseName": "UpdateStatus",
            "type": "MobileAppsSubmissionStatus.UpdateStatusEnum"
        },
        {
            "name": "LastUpdateStatusTime",
            "baseName": "LastUpdateStatusTime",
            "type": "Date"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "UpdateTime",
            "baseName": "UpdateTime",
            "type": "Date"
        },
        {
            "name": "Notes",
            "baseName": "Notes",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MobileAppsSubmissionStatus.attributeTypeMap;
    }
}

export namespace MobileAppsSubmissionStatus {
    export enum TypeEnum {
        None = <any> 'None',
        Android = <any> 'Android',
        IOS = <any> 'IOS'
    }
    export enum AppStatusEnum {
        None = <any> 'None',
        Published = <any> 'Published',
        Unpublished = <any> 'Unpublished'
    }
    export enum UpdateStatusEnum {
        None = <any> 'None',
        Submitted = <any> 'Submitted',
        InReview = <any> 'InReview',
        Rejected = <any> 'Rejected',
        Approved = <any> 'Approved',
        Published = <any> 'Published'
    }
}
/**
* Mobile Apps event
*/
export class MobileAppsSubmissionStatusUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the item
    */
    'User'?: UserEventInfo;
    /**
    * Mobile Apps Submission Status
    */
    'MobileAppsSubmissionStatus'?: MobileAppsSubmissionStatus;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "MobileAppsSubmissionStatus",
            "baseName": "MobileAppsSubmissionStatus",
            "type": "MobileAppsSubmissionStatus"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MobileAppsSubmissionStatusUpdatedEvent.attributeTypeMap;
    }
}

/**
* Mobile Apps event
*/
export class MobileAppsSubmissionUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has created the item
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MobileAppsSubmissionUpdatedEvent.attributeTypeMap;
    }
}

/**
* Model base
*/
export class ModelBase {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ModelBase.attributeTypeMap;
    }
}

/**
* Next status by order type
*/
export class NextStatusWithOrderType {
    /**
    * Order type
    */
    'OrderType'?: NextStatusWithOrderType.OrderTypeEnum;
    /**
    * Next status id
    */
    'NextStatus'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderType",
            "baseName": "OrderType",
            "type": "NextStatusWithOrderType.OrderTypeEnum"
        },
        {
            "name": "NextStatus",
            "baseName": "NextStatus",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NextStatusWithOrderType.attributeTypeMap;
    }
}

export namespace NextStatusWithOrderType {
    export enum OrderTypeEnum {
        All = <any> 'All',
        Delivery = <any> 'Delivery',
        Collection = <any> 'Collection',
        DineIn = <any> 'DineIn'
    }
}
/**
* Menu Nutrition Information
*/
export class NutritionInfo {
    /**
    * Version of the nutrition information model
    */
    'Version'?: string;
    /**
    * List of menu item nutrition infos
    */
    'MenuItems'?: Array<NutritionInfoMenuItem>;
    /**
    * List of menu item option set nutrition infos
    */
    'MenuItemOptionSetItems'?: Array<NutritionInfoMenuOptionSetItem>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Version",
            "baseName": "Version",
            "type": "string"
        },
        {
            "name": "MenuItems",
            "baseName": "MenuItems",
            "type": "Array<NutritionInfoMenuItem>"
        },
        {
            "name": "MenuItemOptionSetItems",
            "baseName": "MenuItemOptionSetItems",
            "type": "Array<NutritionInfoMenuOptionSetItem>"
        }    ];

    static getAttributeTypeMap() {
        return NutritionInfo.attributeTypeMap;
    }
}

export class NutritionInfoItemAddUpdateLabelModel {
    'Name'?: string;
    'Values'?: Array<string>;
    'IconUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Values",
            "baseName": "Values",
            "type": "Array<string>"
        },
        {
            "name": "IconUrl",
            "baseName": "IconUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NutritionInfoItemAddUpdateLabelModel.attributeTypeMap;
    }
}

export class NutritionInfoLabel {
    /**
    * Name of the allergen / ingredient
    */
    'Name'?: string;
    /**
    * Optional list of values for the allergen / ingredient
    */
    'Values'?: Array<string>;
    /**
    * Url to the icon for the allergen / ingredient
    */
    'IconUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Values",
            "baseName": "Values",
            "type": "Array<string>"
        },
        {
            "name": "IconUrl",
            "baseName": "IconUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NutritionInfoLabel.attributeTypeMap;
    }
}

export class NutritionInfoMenuItem {
    /**
    * Menu item public id
    */
    'PublicId'?: string;
    /**
    * List of Nutrition Info Labels for this menu item
    */
    'Labels'?: Array<NutritionInfoLabel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PublicId",
            "baseName": "PublicId",
            "type": "string"
        },
        {
            "name": "Labels",
            "baseName": "Labels",
            "type": "Array<NutritionInfoLabel>"
        }    ];

    static getAttributeTypeMap() {
        return NutritionInfoMenuItem.attributeTypeMap;
    }
}

export class NutritionInfoMenuOptionSetItem {
    /**
    * Menu item option set item public id
    */
    'PublicId'?: string;
    /**
    * List of Nutrition Info Labels for this menu item option set item
    */
    'Labels'?: Array<NutritionInfoLabel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PublicId",
            "baseName": "PublicId",
            "type": "string"
        },
        {
            "name": "Labels",
            "baseName": "Labels",
            "type": "Array<NutritionInfoLabel>"
        }    ];

    static getAttributeTypeMap() {
        return NutritionInfoMenuOptionSetItem.attributeTypeMap;
    }
}

/**
* Menu Nutrition Information. Version 2 (localized).
*/
export class NutritionInfoV2 {
    /**
    * List of menu item nutrition infos
    */
    'MenuItems'?: Array<NutritionInfoV2Item>;
    /**
    * List of menu item option set nutrition infos
    */
    'MenuItemOptionSetItems'?: Array<NutritionInfoV2Item>;
    /**
    * Base url for allergen images
    */
    'ImageBaseUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuItems",
            "baseName": "MenuItems",
            "type": "Array<NutritionInfoV2Item>"
        },
        {
            "name": "MenuItemOptionSetItems",
            "baseName": "MenuItemOptionSetItems",
            "type": "Array<NutritionInfoV2Item>"
        },
        {
            "name": "ImageBaseUrl",
            "baseName": "ImageBaseUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NutritionInfoV2.attributeTypeMap;
    }
}

export class NutritionInfoV2Allergen {
    /**
    * AllergenId (unique string identifier)
    */
    'AllergenId'?: string;
    /**
    * Localized allergen name
    */
    'LocalizedName'?: string;
    /**
    * Name of the image file. Append it to ImageBaseUrl to get the full URL
    */
    'ImageName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AllergenId",
            "baseName": "AllergenId",
            "type": "string"
        },
        {
            "name": "LocalizedName",
            "baseName": "LocalizedName",
            "type": "string"
        },
        {
            "name": "ImageName",
            "baseName": "ImageName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NutritionInfoV2Allergen.attributeTypeMap;
    }
}

export class NutritionInfoV2Item {
    /**
    * Menu item or menu item option set item public id
    */
    'PublicId'?: string;
    /**
    * List of allergens for this item
    */
    'Allergens'?: Array<NutritionInfoV2Allergen>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PublicId",
            "baseName": "PublicId",
            "type": "string"
        },
        {
            "name": "Allergens",
            "baseName": "Allergens",
            "type": "Array<NutritionInfoV2Allergen>"
        }    ];

    static getAttributeTypeMap() {
        return NutritionInfoV2Item.attributeTypeMap;
    }
}

/**
* Oauth client (also knowns as 'app')
*/
export class OAuthApp {
    /**
    * OAuth App Identifier
    */
    'OauthAppId'?: string;
    /**
    * OAuth App Name
    */
    'OauthAppName'?: string;
    /**
    * OAuth App owner user identifier
    */
    'OwnerUserId'?: number;
    /**
    * OAuth App logo uri
    */
    'LogoUri'?: string;
    /**
    * Supported OpenID Connect flows
    */
    'Flow'?: OAuthApp.FlowEnum;
    /**
    * ReUse: the refresh token handle will stay the same when refreshing tokens   OneTime: the refresh token handle will be updated when refreshing tokens
    */
    'RefreshTokenUsage'?: OAuthApp.RefreshTokenUsageEnum;
    /**
    * Timem it takes for the IdentityToken to expire in seconds
    */
    'AccessTokenLifetime'?: number;
    /**
    * Maximum lifetime of a refresh token in seconds
    */
    'AbsoluteRefreshTokenLifetime'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OauthAppId",
            "baseName": "OauthAppId",
            "type": "string"
        },
        {
            "name": "OauthAppName",
            "baseName": "OauthAppName",
            "type": "string"
        },
        {
            "name": "OwnerUserId",
            "baseName": "OwnerUserId",
            "type": "number"
        },
        {
            "name": "LogoUri",
            "baseName": "LogoUri",
            "type": "string"
        },
        {
            "name": "Flow",
            "baseName": "Flow",
            "type": "OAuthApp.FlowEnum"
        },
        {
            "name": "RefreshTokenUsage",
            "baseName": "RefreshTokenUsage",
            "type": "OAuthApp.RefreshTokenUsageEnum"
        },
        {
            "name": "AccessTokenLifetime",
            "baseName": "AccessTokenLifetime",
            "type": "number"
        },
        {
            "name": "AbsoluteRefreshTokenLifetime",
            "baseName": "AbsoluteRefreshTokenLifetime",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return OAuthApp.attributeTypeMap;
    }
}

export namespace OAuthApp {
    export enum FlowEnum {
        AuthorizationCode = <any> 'AuthorizationCode',
        Implicit = <any> 'Implicit',
        Hybrid = <any> 'Hybrid',
        ClientCredentials = <any> 'ClientCredentials'
    }
    export enum RefreshTokenUsageEnum {
        ReUse = <any> 'ReUse',
        OneTimeOnly = <any> 'OneTimeOnly'
    }
}
/**
* OAuth token model
*/
export class OAuthTokenModel {
    /**
    * Identitifier key
    */
    'Key'?: string;
    /**
    * Token type
    */
    'TokenType'?: string;
    /**
    * Oauth subject identifier
    */
    'SubjectId'?: string;
    /**
    * Oauth client identifier
    */
    'ClientId'?: string;
    /**
    * Token expiry
    */
    'Expiry'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Key",
            "baseName": "Key",
            "type": "string"
        },
        {
            "name": "TokenType",
            "baseName": "TokenType",
            "type": "string"
        },
        {
            "name": "SubjectId",
            "baseName": "SubjectId",
            "type": "string"
        },
        {
            "name": "ClientId",
            "baseName": "ClientId",
            "type": "string"
        },
        {
            "name": "Expiry",
            "baseName": "Expiry",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return OAuthTokenModel.attributeTypeMap;
    }
}

/**
* OAuth client redirect uri
*/
export class OauthClientRedirectUri {
    /**
    * Redirect uri identifier
    */
    'Id'?: number;
    /**
    * Redirect uri
    */
    'Uri'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "Uri",
            "baseName": "Uri",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OauthClientRedirectUri.attributeTypeMap;
    }
}

/**
* 
*/
export class ObjectDisplayOrder {
    /**
    * ID of object to be ordered
    */
    'Id'?: number;
    /**
    * New Display order
    */
    'DisplayOrder'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "DisplayOrder",
            "baseName": "DisplayOrder",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ObjectDisplayOrder.attributeTypeMap;
    }
}

/**
* Okta Portal Feature Flag Value
*/
export class OktaPortalFeatureFlag {
    /**
    * Feature flag backend_portal_enableOktaWebApi value
    */
    'OktaPortalEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OktaPortalEnabled",
            "baseName": "OktaPortalEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return OktaPortalFeatureFlag.attributeTypeMap;
    }
}

/**
* Model for updating the onboarding config
*/
export class OnboardingConfigUpdate {
    /**
    * Gets or sets whether onboarding is enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Gets or sets whether welcome screen is enabled
    */
    'IsWelcomeScreenEnabled'?: boolean;
    /**
    * Onboarding config type
    */
    'ConfigType'?: OnboardingConfigUpdate.ConfigTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "IsWelcomeScreenEnabled",
            "baseName": "IsWelcomeScreenEnabled",
            "type": "boolean"
        },
        {
            "name": "ConfigType",
            "baseName": "ConfigType",
            "type": "OnboardingConfigUpdate.ConfigTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return OnboardingConfigUpdate.attributeTypeMap;
    }
}

export namespace OnboardingConfigUpdate {
    export enum ConfigTypeEnum {
        Tutorial = <any> 'Tutorial',
        OnboardingWizard = <any> 'OnboardingWizard'
    }
}
/**
* 
*/
export class OnboardingItemUpdate {
    /**
    * Completion Status for Onboarding Item
    */
    'Status'?: OnboardingItemUpdate.StatusEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Status",
            "baseName": "Status",
            "type": "OnboardingItemUpdate.StatusEnum"
        }    ];

    static getAttributeTypeMap() {
        return OnboardingItemUpdate.attributeTypeMap;
    }
}

export namespace OnboardingItemUpdate {
    export enum StatusEnum {
        Pending = <any> 'Pending',
        InProgress = <any> 'InProgress',
        Completed = <any> 'Completed'
    }
}
/**
* Order
*/
export class Order {
    /**
    * Store summary
    */
    'Store'?: StoreSummary;
    /**
    * Customer summary
    */
    'Customer'?: CustomerSummary;
    /**
    * Voucher summary
    */
    'Voucher'?: OrderVoucherSummary;
    /**
    * Fee summary
    */
    'Fees'?: FeeSummary;
    /**
    * Ordered items
    */
    'OrderItems'?: Array<OrderItem>;
    /**
    * Delivery location for delivery orders
    */
    'DeliveryLocation'?: DeliveryLocation;
    /**
    * Customer location
    */
    'CustomerLocation'?: Coordinates;
    /**
    * Represents customers masked phone number
    */
    'MaskedPhoneNumber'?: MaskedPhoneNumber;
    /**
    * Represents table service drop off location
    */
    'DropOffLocationId'?: number;
    /**
    * Represents table service drop off location
    */
    'DropOffLocation'?: string;
    /**
    * Time store has accepted the order for
    */
    'AcceptedFor'?: Date;
    /**
    * Was order made within a fraud zone
    */
    'InFraudZone'?: boolean;
    /**
    * Is order of unusually high value
    */
    'UnusualHighValueOrder'?: boolean;
    /**
    * Id of user who rejected order, if available
    */
    'RejectedByUserId'?: number;
    /**
    * ChannelOrderId from external channel
    */
    'ChannelOrderId'?: string;
    /**
    * ChannelOrderDisplayId from external channel
    */
    'ChannelOrderDisplayId'?: string;
    /**
    * Channel where the Order comes from
    */
    'Channel'?: Channel;
    /**
    * DropOffLocation selected for this order
    */
    'OrderDropOffLocation'?: OrderDropOffLocation;
    /**
    * [BETA - this is a new field in development] Fulfillment status for this order
    */
    'FulfillmentStatus'?: OrderFulfillmentStatusBase;
    /**
    * OrderBatch information
    */
    'OrderBatchInfo'?: OrderBatchSummary;
    /**
    * Order identifier
    */
    'OrderId'?: number;
    /**
    * Local order Id. This is used for displaying a \"shorter\" order ID for customers (eg. Kiosk orders)
    */
    'LocalOrderId'?: string;
    /**
    * Delivery type
    */
    'DeliveryType'?: Order.DeliveryTypeEnum;
    /**
    * Pickup location type
    */
    'PickupLocationType'?: Order.PickupLocationTypeEnum;
    /**
    * Pickup location type
    */
    'TableServiceCatagory'?: Order.TableServiceCatagoryEnum;
    /**
    * Tip amount
    */
    'TipAmount'?: number;
    /**
    * Delivery amount
    */
    'DeliveryAmount'?: number;
    /**
    * Ordered items amount
    */
    'OrderItemsAmount'?: number;
    /**
    * Service Charge Amount
    */
    'ServiceChargeAmount'?: number;
    /**
    * Service Charge Percentage
    */
    'ServiceChargePercentage'?: number;
    /**
    * This is the sum of the OrderItemsAmount, DeliveryAmount, TipAmount and Voucher.Amount (which is usually negative) and OnlineOrderingFee for cash orders.  It does not include the OnlineOrderingFee in the case of card orders as this fee is charged by Flipdish directly to the customer.
    */
    'Amount'?: number;
    /**
    * This contains the online ordering processing fee. For card payments this is charged directly to the customer and for cash orders it is paid by the customer to the store. It is tax inclusive.
    */
    'ProcessingFee'?: number;
    /**
    * Payment account type
    */
    'PaymentAccountType'?: Order.PaymentAccountTypeEnum;
    /**
    * Payment account description (like Visa ****2371 or Apple Pay. or Cash)
    */
    'PaymentAccountDescription'?: string;
    /**
    * Order state
    */
    'OrderState'?: Order.OrderStateEnum;
    /**
    * Is pre-order
    */
    'IsPreOrder'?: boolean;
    /**
    * Order placed time
    */
    'PlacedTime'?: Date;
    /**
    * Order requested for
    */
    'RequestedForTime'?: Date;
    /**
    * Chef note
    */
    'ChefNote'?: string;
    /**
    * Used app type
    */
    'AppType'?: Order.AppTypeEnum;
    /**
    * User rating
    */
    'UserRating'?: number;
    /**
    * Status of the payment
    */
    'PaymentStatus'?: Order.PaymentStatusEnum;
    /**
    * Rejection reason. Can have value if the order is rejected.
    */
    'RejectionReason'?: Order.RejectionReasonEnum;
    /**
    * Amount refunded to customer.
    */
    'RefundedAmount'?: number;
    /**
    * Delivery tracking status
    */
    'DeliveryTrackingStatus'?: Order.DeliveryTrackingStatusEnum;
    /**
    * Assigned driver identifier
    */
    'DriverId'?: number;
    /**
    * Total tax applied to order
    */
    'TotalTax'?: number;
    /**
    * Unique, 6 character long alpha numeric code for tracking.
    */
    'OrderTrackingCode'?: string;
    /**
    * Delivery area identifier
    */
    'DeliveryFeeAreaId'?: number;
    /**
    * Code used to view the order's receipt
    */
    'ReceiptCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Store",
            "baseName": "Store",
            "type": "StoreSummary"
        },
        {
            "name": "Customer",
            "baseName": "Customer",
            "type": "CustomerSummary"
        },
        {
            "name": "Voucher",
            "baseName": "Voucher",
            "type": "OrderVoucherSummary"
        },
        {
            "name": "Fees",
            "baseName": "Fees",
            "type": "FeeSummary"
        },
        {
            "name": "OrderItems",
            "baseName": "OrderItems",
            "type": "Array<OrderItem>"
        },
        {
            "name": "DeliveryLocation",
            "baseName": "DeliveryLocation",
            "type": "DeliveryLocation"
        },
        {
            "name": "CustomerLocation",
            "baseName": "CustomerLocation",
            "type": "Coordinates"
        },
        {
            "name": "MaskedPhoneNumber",
            "baseName": "MaskedPhoneNumber",
            "type": "MaskedPhoneNumber"
        },
        {
            "name": "DropOffLocationId",
            "baseName": "DropOffLocationId",
            "type": "number"
        },
        {
            "name": "DropOffLocation",
            "baseName": "DropOffLocation",
            "type": "string"
        },
        {
            "name": "AcceptedFor",
            "baseName": "AcceptedFor",
            "type": "Date"
        },
        {
            "name": "InFraudZone",
            "baseName": "InFraudZone",
            "type": "boolean"
        },
        {
            "name": "UnusualHighValueOrder",
            "baseName": "UnusualHighValueOrder",
            "type": "boolean"
        },
        {
            "name": "RejectedByUserId",
            "baseName": "RejectedByUserId",
            "type": "number"
        },
        {
            "name": "ChannelOrderId",
            "baseName": "ChannelOrderId",
            "type": "string"
        },
        {
            "name": "ChannelOrderDisplayId",
            "baseName": "ChannelOrderDisplayId",
            "type": "string"
        },
        {
            "name": "Channel",
            "baseName": "Channel",
            "type": "Channel"
        },
        {
            "name": "OrderDropOffLocation",
            "baseName": "OrderDropOffLocation",
            "type": "OrderDropOffLocation"
        },
        {
            "name": "FulfillmentStatus",
            "baseName": "FulfillmentStatus",
            "type": "OrderFulfillmentStatusBase"
        },
        {
            "name": "OrderBatchInfo",
            "baseName": "OrderBatchInfo",
            "type": "OrderBatchSummary"
        },
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "LocalOrderId",
            "baseName": "LocalOrderId",
            "type": "string"
        },
        {
            "name": "DeliveryType",
            "baseName": "DeliveryType",
            "type": "Order.DeliveryTypeEnum"
        },
        {
            "name": "PickupLocationType",
            "baseName": "PickupLocationType",
            "type": "Order.PickupLocationTypeEnum"
        },
        {
            "name": "TableServiceCatagory",
            "baseName": "TableServiceCatagory",
            "type": "Order.TableServiceCatagoryEnum"
        },
        {
            "name": "TipAmount",
            "baseName": "TipAmount",
            "type": "number"
        },
        {
            "name": "DeliveryAmount",
            "baseName": "DeliveryAmount",
            "type": "number"
        },
        {
            "name": "OrderItemsAmount",
            "baseName": "OrderItemsAmount",
            "type": "number"
        },
        {
            "name": "ServiceChargeAmount",
            "baseName": "ServiceChargeAmount",
            "type": "number"
        },
        {
            "name": "ServiceChargePercentage",
            "baseName": "ServiceChargePercentage",
            "type": "number"
        },
        {
            "name": "Amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "ProcessingFee",
            "baseName": "ProcessingFee",
            "type": "number"
        },
        {
            "name": "PaymentAccountType",
            "baseName": "PaymentAccountType",
            "type": "Order.PaymentAccountTypeEnum"
        },
        {
            "name": "PaymentAccountDescription",
            "baseName": "PaymentAccountDescription",
            "type": "string"
        },
        {
            "name": "OrderState",
            "baseName": "OrderState",
            "type": "Order.OrderStateEnum"
        },
        {
            "name": "IsPreOrder",
            "baseName": "IsPreOrder",
            "type": "boolean"
        },
        {
            "name": "PlacedTime",
            "baseName": "PlacedTime",
            "type": "Date"
        },
        {
            "name": "RequestedForTime",
            "baseName": "RequestedForTime",
            "type": "Date"
        },
        {
            "name": "ChefNote",
            "baseName": "ChefNote",
            "type": "string"
        },
        {
            "name": "AppType",
            "baseName": "AppType",
            "type": "Order.AppTypeEnum"
        },
        {
            "name": "UserRating",
            "baseName": "UserRating",
            "type": "number"
        },
        {
            "name": "PaymentStatus",
            "baseName": "PaymentStatus",
            "type": "Order.PaymentStatusEnum"
        },
        {
            "name": "RejectionReason",
            "baseName": "RejectionReason",
            "type": "Order.RejectionReasonEnum"
        },
        {
            "name": "RefundedAmount",
            "baseName": "RefundedAmount",
            "type": "number"
        },
        {
            "name": "DeliveryTrackingStatus",
            "baseName": "DeliveryTrackingStatus",
            "type": "Order.DeliveryTrackingStatusEnum"
        },
        {
            "name": "DriverId",
            "baseName": "DriverId",
            "type": "number"
        },
        {
            "name": "TotalTax",
            "baseName": "TotalTax",
            "type": "number"
        },
        {
            "name": "OrderTrackingCode",
            "baseName": "OrderTrackingCode",
            "type": "string"
        },
        {
            "name": "DeliveryFeeAreaId",
            "baseName": "DeliveryFeeAreaId",
            "type": "number"
        },
        {
            "name": "ReceiptCode",
            "baseName": "ReceiptCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Order.attributeTypeMap;
    }
}

export namespace Order {
    export enum DeliveryTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
    export enum PickupLocationTypeEnum {
        TakeOut = <any> 'TakeOut',
        TableService = <any> 'TableService',
        DineIn = <any> 'DineIn'
    }
    export enum TableServiceCatagoryEnum {
        Generic = <any> 'Generic',
        Villa = <any> 'Villa',
        House = <any> 'House',
        Room = <any> 'Room',
        Area = <any> 'Area',
        Table = <any> 'Table',
        ParkingBay = <any> 'ParkingBay',
        Gate = <any> 'Gate',
        DriveThrough = <any> 'DriveThrough',
        Team = <any> 'Team'
    }
    export enum PaymentAccountTypeEnum {
        Card = <any> 'Card',
        Cash = <any> 'Cash',
        Ideal = <any> 'Ideal',
        Bancontact = <any> 'Bancontact',
        Giropay = <any> 'Giropay',
        Eps = <any> 'Eps',
        Emv = <any> 'Emv',
        PayPal = <any> 'PayPal',
        PayGreen = <any> 'PayGreen',
        GoogleWalletToken = <any> 'GoogleWalletToken'
    }
    export enum OrderStateEnum {
        Created = <any> 'Created',
        PlacedCanBeCancelled = <any> 'PlacedCanBeCancelled',
        ReadyToProcess = <any> 'ReadyToProcess',
        AcceptedByRestaurant = <any> 'AcceptedByRestaurant',
        Dispatched = <any> 'Dispatched',
        Delivered = <any> 'Delivered',
        Cancelled = <any> 'Cancelled',
        ManualReview = <any> 'ManualReview',
        RejectedByStore = <any> 'RejectedByStore',
        RejectedByFlipdish = <any> 'RejectedByFlipdish',
        RejectedAutomatically = <any> 'RejectedAutomatically',
        RejectedAfterBeingAccepted = <any> 'RejectedAfterBeingAccepted',
        AcceptedAndRefunded = <any> 'AcceptedAndRefunded'
    }
    export enum AppTypeEnum {
        Unknown = <any> 'Unknown',
        Ios = <any> 'Ios',
        Android = <any> 'Android',
        Web = <any> 'Web',
        Kiosk = <any> 'Kiosk',
        Pos = <any> 'Pos',
        TelephoneCall = <any> 'TelephoneCall',
        Sms = <any> 'Sms',
        PwaAndroid = <any> 'PwaAndroid',
        PwaIos = <any> 'PwaIos',
        Google = <any> 'Google'
    }
    export enum PaymentStatusEnum {
        Paid = <any> 'Paid',
        Unpaid = <any> 'Unpaid',
        Refunded = <any> 'Refunded',
        PartiallyRefunded = <any> 'PartiallyRefunded',
        Disputed = <any> 'Disputed'
    }
    export enum RejectionReasonEnum {
        TooBusy = <any> 'TooBusy',
        FoodUnavailable = <any> 'FoodUnavailable',
        UnableToDeliver = <any> 'UnableToDeliver',
        UnknownAddress = <any> 'UnknownAddress',
        UnknownReason = <any> 'UnknownReason',
        TooSoon = <any> 'TooSoon',
        TimeUnavailable = <any> 'TimeUnavailable',
        DontDeliverToArea = <any> 'DontDeliverToArea',
        StoreUncontactable = <any> 'StoreUncontactable'
    }
    export enum DeliveryTrackingStatusEnum {
        Unassigned = <any> 'Unassigned',
        Unaccepted = <any> 'Unaccepted',
        Accepted = <any> 'Accepted',
        Carrying = <any> 'Carrying',
        OnTheWay = <any> 'OnTheWay',
        ArrivedAtLocation = <any> 'ArrivedAtLocation',
        Delivered = <any> 'Delivered',
        CannotDeliver = <any> 'CannotDeliver'
    }
}
/**
* Order Accepted Event
*/
export class OrderAcceptedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order Accepted Time
    */
    'OrderAcceptedTime'?: Date;
    /**
    * User who has accepted the order
    */
    'User'?: UserEventInfo;
    /**
    * Order
    */
    'Order'?: Order;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "OrderAcceptedTime",
            "baseName": "OrderAcceptedTime",
            "type": "Date"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "Order"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderAcceptedEvent.attributeTypeMap;
    }
}

/**
* Order batch detailed information
*/
export class OrderBatch {
    /**
    * Orders' ids on the batch
    */
    'OrderIds'?: Array<number>;
    /**
    * Order batch id
    */
    'Id'?: number;
    /**
    * Order batch 6-sign human readable code
    */
    'DisplayCode'?: string;
    /**
    * Batch creation date and time
    */
    'CreateTime'?: Date;
    /**
    * If the batch is already published
    */
    'IsPublished'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderIds",
            "baseName": "OrderIds",
            "type": "Array<number>"
        },
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "DisplayCode",
            "baseName": "DisplayCode",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "IsPublished",
            "baseName": "IsPublished",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return OrderBatch.attributeTypeMap;
    }
}

/**
* Order Batch Published Event
*/
export class OrderBatchPublishedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Order Batch Id
    */
    'OrderBatchId'?: number;
    /**
    * Store id the order batch belogs to
    */
    'StoreId'?: number;
    /**
    * Orders' ids on the batch
    */
    'OrderIds'?: Array<number>;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "OrderBatchId",
            "baseName": "OrderBatchId",
            "type": "number"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "OrderIds",
            "baseName": "OrderIds",
            "type": "Array<number>"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderBatchPublishedEvent.attributeTypeMap;
    }
}

/**
* Order batch info
*/
export class OrderBatchSummary {
    /**
    * Order batch id
    */
    'Id'?: number;
    /**
    * Order batch 6-sign human readable code
    */
    'DisplayCode'?: string;
    /**
    * Batch creation date and time
    */
    'CreateTime'?: Date;
    /**
    * If the batch is already published
    */
    'IsPublished'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "DisplayCode",
            "baseName": "DisplayCode",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "IsPublished",
            "baseName": "IsPublished",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return OrderBatchSummary.attributeTypeMap;
    }
}

/**
* Describes the configuration of OrderBatching
*/
export class OrderBatchingConfiguration {
    /**
    * Batch sending interval in seconds
    */
    'BatchIntervalInSeconds'?: number;
    /**
    * OrderBatching is enabled or not
    */
    'IsEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "BatchIntervalInSeconds",
            "baseName": "BatchIntervalInSeconds",
            "type": "number"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return OrderBatchingConfiguration.attributeTypeMap;
    }
}

/**
* Store's Order Capacity Configuration Updated
*/
export class OrderCapacityConfigUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Id of the store whose order capacity configuration has been updated
    */
    'StoreId'?: number;
    /**
    * User which updated order capacity configuration for this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Updated order capacity configuration
    */
    'OrderCapacityConfig'?: StoreOrderCapacityConfigEditModel;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "OrderCapacityConfig",
            "baseName": "OrderCapacityConfig",
            "type": "StoreOrderCapacityConfigEditModel"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderCapacityConfigUpdatedEvent.attributeTypeMap;
    }
}

/**
* Order Created Event
*/
export class OrderCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order Created Time
    */
    'OrderCreatedTime'?: Date;
    /**
    * Order
    */
    'Order'?: Order;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "OrderCreatedTime",
            "baseName": "OrderCreatedTime",
            "type": "Date"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "Order"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class OrderCustomerTrackingCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order
    */
    'Order'?: CustomerDeliveryTrackingOrder;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "CustomerDeliveryTrackingOrder"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderCustomerTrackingCreatedEvent.attributeTypeMap;
    }
}

/**
* Order Delivery Status Information
*/
export class OrderDeliveryInformation {
    /**
    * Order Id
    */
    'OrderId'?: number;
    /**
    * External Reference Id
    */
    'ExternalReferenceId'?: string;
    /**
    * Tracking Url
    */
    'TrackUrl'?: string;
    /**
    * Delivery Status
    */
    'Status'?: OrderDeliveryInformation.StatusEnum;
    /**
    * Delivery Status Notes
    */
    'DeliveryStatusNotes'?: string;
    /**
    * Error Message
    */
    'ErrorMessage'?: string;
    /**
    * Integration Code
    */
    'IntegrationCode'?: string;
    /**
    * Integration Name
    */
    'IntegrationName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "ExternalReferenceId",
            "baseName": "ExternalReferenceId",
            "type": "string"
        },
        {
            "name": "TrackUrl",
            "baseName": "TrackUrl",
            "type": "string"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "OrderDeliveryInformation.StatusEnum"
        },
        {
            "name": "DeliveryStatusNotes",
            "baseName": "DeliveryStatusNotes",
            "type": "string"
        },
        {
            "name": "ErrorMessage",
            "baseName": "ErrorMessage",
            "type": "string"
        },
        {
            "name": "IntegrationCode",
            "baseName": "IntegrationCode",
            "type": "string"
        },
        {
            "name": "IntegrationName",
            "baseName": "IntegrationName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderDeliveryInformation.attributeTypeMap;
    }
}

export namespace OrderDeliveryInformation {
    export enum StatusEnum {
        None = <any> 'None',
        Unassigned = <any> 'Unassigned',
        Unaccepted = <any> 'Unaccepted',
        Accepted = <any> 'Accepted',
        Carrying = <any> 'Carrying',
        OnTheWay = <any> 'OnTheWay',
        ArrivedAtLocation = <any> 'ArrivedAtLocation',
        Delivered = <any> 'Delivered',
        CannotDeliver = <any> 'CannotDeliver'
    }
}
/**
* Order Delivery Status Information
*/
export class OrderDeliveryInformationBase {
    /**
    * External Reference Id
    */
    'ExternalReferenceId'?: string;
    /**
    * Tracking Url
    */
    'TrackUrl'?: string;
    /**
    * Delivery Status
    */
    'Status'?: OrderDeliveryInformationBase.StatusEnum;
    /**
    * Delivery Status Notes
    */
    'DeliveryStatusNotes'?: string;
    /**
    * Error Message
    */
    'ErrorMessage'?: string;
    /**
    * Integration Code
    */
    'IntegrationCode'?: string;
    /**
    * Integration Name
    */
    'IntegrationName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ExternalReferenceId",
            "baseName": "ExternalReferenceId",
            "type": "string"
        },
        {
            "name": "TrackUrl",
            "baseName": "TrackUrl",
            "type": "string"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "OrderDeliveryInformationBase.StatusEnum"
        },
        {
            "name": "DeliveryStatusNotes",
            "baseName": "DeliveryStatusNotes",
            "type": "string"
        },
        {
            "name": "ErrorMessage",
            "baseName": "ErrorMessage",
            "type": "string"
        },
        {
            "name": "IntegrationCode",
            "baseName": "IntegrationCode",
            "type": "string"
        },
        {
            "name": "IntegrationName",
            "baseName": "IntegrationName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderDeliveryInformationBase.attributeTypeMap;
    }
}

export namespace OrderDeliveryInformationBase {
    export enum StatusEnum {
        None = <any> 'None',
        Unassigned = <any> 'Unassigned',
        Unaccepted = <any> 'Unaccepted',
        Accepted = <any> 'Accepted',
        Carrying = <any> 'Carrying',
        OnTheWay = <any> 'OnTheWay',
        ArrivedAtLocation = <any> 'ArrivedAtLocation',
        Delivered = <any> 'Delivered',
        CannotDeliver = <any> 'CannotDeliver'
    }
}
/**
* 
*/
export class OrderDeliveryTrackingStatusUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order
    */
    'Order'?: Order;
    /**
    * Delivery integration name
    */
    'DeliveryIntegrationName'?: string;
    /**
    * Delivery error message (optional)
    */
    'DeliveryErrorMessage'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "Order"
        },
        {
            "name": "DeliveryIntegrationName",
            "baseName": "DeliveryIntegrationName",
            "type": "string"
        },
        {
            "name": "DeliveryErrorMessage",
            "baseName": "DeliveryErrorMessage",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderDeliveryTrackingStatusUpdatedEvent.attributeTypeMap;
    }
}

/**
* Order Dispatched Event
*/
export class OrderDispatchedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order Rejected Time
    */
    'OrderDispatchedTime'?: Date;
    /**
    * Order
    */
    'Order'?: Order;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "OrderDispatchedTime",
            "baseName": "OrderDispatchedTime",
            "type": "Date"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "Order"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderDispatchedEvent.attributeTypeMap;
    }
}

export class OrderDm {
    'UserLocation'?: CoordinatesDm;
    'RequestedDeliveryOrPickupTimeUtc'?: Date;
    'TipAmount'?: number;
    'DeliveryLocationId'?: number;
    'VoucherCode'?: string;
    'OrderItemVms'?: Array<OrderItemDm>;
    'VirtualRestaurantId'?: number;
    'PhysicalRestaurantId'?: number;
    'DeliveryType'?: OrderDm.DeliveryTypeEnum;
    'PickupLocationType'?: OrderDm.PickupLocationTypeEnum;
    'PickupLocationId'?: number;
    'TableServiceCatagory'?: OrderDm.TableServiceCatagoryEnum;
    'PaymentAccountId'?: number;
    'IsPreOrder'?: boolean;
    'IsAsapOrder'?: boolean;
    'MenuId'?: number;
    'MenuVersion'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "UserLocation",
            "baseName": "UserLocation",
            "type": "CoordinatesDm"
        },
        {
            "name": "RequestedDeliveryOrPickupTimeUtc",
            "baseName": "RequestedDeliveryOrPickupTimeUtc",
            "type": "Date"
        },
        {
            "name": "TipAmount",
            "baseName": "TipAmount",
            "type": "number"
        },
        {
            "name": "DeliveryLocationId",
            "baseName": "DeliveryLocationId",
            "type": "number"
        },
        {
            "name": "VoucherCode",
            "baseName": "VoucherCode",
            "type": "string"
        },
        {
            "name": "OrderItemVms",
            "baseName": "OrderItemVms",
            "type": "Array<OrderItemDm>"
        },
        {
            "name": "VirtualRestaurantId",
            "baseName": "VirtualRestaurantId",
            "type": "number"
        },
        {
            "name": "PhysicalRestaurantId",
            "baseName": "PhysicalRestaurantId",
            "type": "number"
        },
        {
            "name": "DeliveryType",
            "baseName": "DeliveryType",
            "type": "OrderDm.DeliveryTypeEnum"
        },
        {
            "name": "PickupLocationType",
            "baseName": "PickupLocationType",
            "type": "OrderDm.PickupLocationTypeEnum"
        },
        {
            "name": "PickupLocationId",
            "baseName": "PickupLocationId",
            "type": "number"
        },
        {
            "name": "TableServiceCatagory",
            "baseName": "TableServiceCatagory",
            "type": "OrderDm.TableServiceCatagoryEnum"
        },
        {
            "name": "PaymentAccountId",
            "baseName": "PaymentAccountId",
            "type": "number"
        },
        {
            "name": "IsPreOrder",
            "baseName": "IsPreOrder",
            "type": "boolean"
        },
        {
            "name": "IsAsapOrder",
            "baseName": "IsAsapOrder",
            "type": "boolean"
        },
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "MenuVersion",
            "baseName": "MenuVersion",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return OrderDm.attributeTypeMap;
    }
}

export namespace OrderDm {
    export enum DeliveryTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
    export enum PickupLocationTypeEnum {
        TakeOut = <any> 'TakeOut',
        TableService = <any> 'TableService',
        DineIn = <any> 'DineIn'
    }
    export enum TableServiceCatagoryEnum {
        Generic = <any> 'Generic',
        Villa = <any> 'Villa',
        House = <any> 'House',
        Room = <any> 'Room',
        Area = <any> 'Area',
        Table = <any> 'Table',
        ParkingBay = <any> 'ParkingBay',
        Gate = <any> 'Gate',
        DriveThrough = <any> 'DriveThrough',
        Team = <any> 'Team'
    }
}
export class OrderDropOffLocation {
    'OrderId'?: number;
    'LocationName'?: string;
    'LocationAreaName'?: string;
    'LocationId'?: number;
    'LocationAreaId'?: number;
    'ExternalLocationId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "LocationName",
            "baseName": "LocationName",
            "type": "string"
        },
        {
            "name": "LocationAreaName",
            "baseName": "LocationAreaName",
            "type": "string"
        },
        {
            "name": "LocationId",
            "baseName": "LocationId",
            "type": "number"
        },
        {
            "name": "LocationAreaId",
            "baseName": "LocationAreaId",
            "type": "number"
        },
        {
            "name": "ExternalLocationId",
            "baseName": "ExternalLocationId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderDropOffLocation.attributeTypeMap;
    }
}

/**
* Order Fulfillment Status Information
*/
export class OrderFulfillmentStatus {
    /**
    * Order Id
    */
    'OrderId'?: number;
    /**
    * Fulfillment Status Id
    */
    'StatusId'?: string;
    /**
    * Fulfillment Status Name
    */
    'StatusName'?: string;
    /**
    * Status Icon
    */
    'Icon'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "StatusId",
            "baseName": "StatusId",
            "type": "string"
        },
        {
            "name": "StatusName",
            "baseName": "StatusName",
            "type": "string"
        },
        {
            "name": "Icon",
            "baseName": "Icon",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderFulfillmentStatus.attributeTypeMap;
    }
}

/**
* Fulfillment Status Information
*/
export class OrderFulfillmentStatusBase {
    /**
    * Fulfillment Status Id
    */
    'StatusId'?: string;
    /**
    * Fulfillment Status Name
    */
    'StatusName'?: string;
    /**
    * Status Icon
    */
    'Icon'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StatusId",
            "baseName": "StatusId",
            "type": "string"
        },
        {
            "name": "StatusName",
            "baseName": "StatusName",
            "type": "string"
        },
        {
            "name": "Icon",
            "baseName": "Icon",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderFulfillmentStatusBase.attributeTypeMap;
    }
}

export class OrderFulfillmentStatusUpdate {
    /**
    * Fulfillment Status Id
    */
    'StatusId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StatusId",
            "baseName": "StatusId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderFulfillmentStatusUpdate.attributeTypeMap;
    }
}

/**
* Fulfillment status updated event
*/
export class OrderFulfillmentStatusUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order Id
    */
    'OrderId'?: number;
    /**
    * Fulfillment status name
    */
    'StatusName'?: string;
    /**
    * Fulfillment status ID
    */
    'StatusId'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "StatusName",
            "baseName": "StatusName",
            "type": "string"
        },
        {
            "name": "StatusId",
            "baseName": "StatusId",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderFulfillmentStatusUpdatedEvent.attributeTypeMap;
    }
}

/**
* Order Fulfillment status with configured next actions
*/
export class OrderFulfillmentStatusWithConfigurationActions {
    /**
    * Default next status (id)
    */
    'DefaultNextStatus'?: string;
    /**
    * Possible next statuses
    */
    'NextStatuses'?: Array<FulfillentStatusActionItem>;
    /**
    * Order Id
    */
    'OrderId'?: number;
    /**
    * Fulfillment Status Id
    */
    'StatusId'?: string;
    /**
    * Fulfillment Status Name
    */
    'StatusName'?: string;
    /**
    * Status Icon
    */
    'Icon'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DefaultNextStatus",
            "baseName": "DefaultNextStatus",
            "type": "string"
        },
        {
            "name": "NextStatuses",
            "baseName": "NextStatuses",
            "type": "Array<FulfillentStatusActionItem>"
        },
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "StatusId",
            "baseName": "StatusId",
            "type": "string"
        },
        {
            "name": "StatusName",
            "baseName": "StatusName",
            "type": "string"
        },
        {
            "name": "Icon",
            "baseName": "Icon",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderFulfillmentStatusWithConfigurationActions.attributeTypeMap;
    }
}

/**
* Generic model for ingesting external orders from   3rd parties into the system
*/
export class OrderIngestSubmitOrderRequest {
    /**
    * [Required] Indicated the name from where the request is coming from
    */
    'AppType'?: OrderIngestSubmitOrderRequest.AppTypeEnum;
    /**
    * [Required] Store Id
    */
    'StoreId'?: number;
    /**
    * [Required] Currency Code  These must match three letter codes ISO 4127 http://en.wikipedia.org/wiki/ISO_4217
    */
    'CurrencyCode'?: OrderIngestSubmitOrderRequest.CurrencyCodeEnum;
    /**
    * [Required] Cart of the user
    */
    'Cart'?: Cart;
    /**
    * [Required] Relevant fulfillment Information
    */
    'FulfillmentInfo'?: FulfillmentInfo;
    /**
    * [Required] Order ID in the external System
    */
    'ChannelOrderId'?: string;
    /**
    * [Optional] Public Order ID in the external System
    */
    'ChannelPublicOrderId'?: string;
    /**
    * Date the order was placed at in UTC  [Required]
    */
    'OrderDateUtc'?: Date;
    /**
    * Payment Information  [Required]
    */
    'PaymentInfo'?: PaymentInfo;
    /**
    * Contact Information  [Required]
    */
    'Contact'?: Contact;
    /**
    * Tip amount
    */
    'TipAmount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AppType",
            "baseName": "AppType",
            "type": "OrderIngestSubmitOrderRequest.AppTypeEnum"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "CurrencyCode",
            "baseName": "CurrencyCode",
            "type": "OrderIngestSubmitOrderRequest.CurrencyCodeEnum"
        },
        {
            "name": "Cart",
            "baseName": "Cart",
            "type": "Cart"
        },
        {
            "name": "FulfillmentInfo",
            "baseName": "FulfillmentInfo",
            "type": "FulfillmentInfo"
        },
        {
            "name": "ChannelOrderId",
            "baseName": "ChannelOrderId",
            "type": "string"
        },
        {
            "name": "ChannelPublicOrderId",
            "baseName": "ChannelPublicOrderId",
            "type": "string"
        },
        {
            "name": "OrderDateUtc",
            "baseName": "OrderDateUtc",
            "type": "Date"
        },
        {
            "name": "PaymentInfo",
            "baseName": "PaymentInfo",
            "type": "PaymentInfo"
        },
        {
            "name": "Contact",
            "baseName": "Contact",
            "type": "Contact"
        },
        {
            "name": "TipAmount",
            "baseName": "TipAmount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return OrderIngestSubmitOrderRequest.attributeTypeMap;
    }
}

export namespace OrderIngestSubmitOrderRequest {
    export enum AppTypeEnum {
        Unknown = <any> 'Unknown',
        Ios = <any> 'Ios',
        Android = <any> 'Android',
        Web = <any> 'Web',
        Kiosk = <any> 'Kiosk',
        Pos = <any> 'Pos',
        TelephoneCall = <any> 'TelephoneCall',
        Sms = <any> 'Sms',
        PwaAndroid = <any> 'PwaAndroid',
        PwaIos = <any> 'PwaIos',
        Google = <any> 'Google'
    }
    export enum CurrencyCodeEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
export class OrderIngestSubmitOrderResponse {
    'OrderId'?: number;
    'ReceiptUrl'?: string;
    'CurrencyCode'?: OrderIngestSubmitOrderResponse.CurrencyCodeEnum;
    'TotalPrice'?: Price;
    'DeliveryFee'?: Price;
    'EstimatedDeliveryTime'?: Date;
    'ChannelOrderId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "ReceiptUrl",
            "baseName": "ReceiptUrl",
            "type": "string"
        },
        {
            "name": "CurrencyCode",
            "baseName": "CurrencyCode",
            "type": "OrderIngestSubmitOrderResponse.CurrencyCodeEnum"
        },
        {
            "name": "TotalPrice",
            "baseName": "TotalPrice",
            "type": "Price"
        },
        {
            "name": "DeliveryFee",
            "baseName": "DeliveryFee",
            "type": "Price"
        },
        {
            "name": "EstimatedDeliveryTime",
            "baseName": "EstimatedDeliveryTime",
            "type": "Date"
        },
        {
            "name": "ChannelOrderId",
            "baseName": "ChannelOrderId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderIngestSubmitOrderResponse.attributeTypeMap;
    }
}

export namespace OrderIngestSubmitOrderResponse {
    export enum CurrencyCodeEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Order item
*/
export class OrderItem {
    /**
    * Option list
    */
    'OrderItemOptions'?: Array<OrderItemOption>;
    /**
    * Metadata
    */
    'Metadata'?: { [key: string]: string; };
    /**
    * Public id of the Menu Item
    */
    'MenuItemPublicId'?: string;
    /**
    * Menu section name
    */
    'MenuSectionName'?: string;
    /**
    * Menu section display order
    */
    'MenuSectionDisplayOrder'?: number;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Price
    */
    'Price'?: number;
    /**
    * Price including option set items
    */
    'PriceIncludingOptionSetItems'?: number;
    /**
    * Menu item identifier
    */
    'MenuItemId'?: number;
    /**
    * Menu item display order
    */
    'MenuItemDisplayOrder'?: number;
    /**
    * Is available
    */
    'IsAvailable'?: boolean;
    /**
    * Deposit return fee
    */
    'DepositReturnFee'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderItemOptions",
            "baseName": "OrderItemOptions",
            "type": "Array<OrderItemOption>"
        },
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "MenuItemPublicId",
            "baseName": "MenuItemPublicId",
            "type": "string"
        },
        {
            "name": "MenuSectionName",
            "baseName": "MenuSectionName",
            "type": "string"
        },
        {
            "name": "MenuSectionDisplayOrder",
            "baseName": "MenuSectionDisplayOrder",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "PriceIncludingOptionSetItems",
            "baseName": "PriceIncludingOptionSetItems",
            "type": "number"
        },
        {
            "name": "MenuItemId",
            "baseName": "MenuItemId",
            "type": "number"
        },
        {
            "name": "MenuItemDisplayOrder",
            "baseName": "MenuItemDisplayOrder",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "DepositReturnFee",
            "baseName": "DepositReturnFee",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return OrderItem.attributeTypeMap;
    }
}

export class OrderItemDm {
    'MenuItemId'?: number;
    'IsAvailable'?: boolean;
    'MenuItemOptionSetItemIds'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuItemId",
            "baseName": "MenuItemId",
            "type": "number"
        },
        {
            "name": "IsAvailable",
            "baseName": "IsAvailable",
            "type": "boolean"
        },
        {
            "name": "MenuItemOptionSetItemIds",
            "baseName": "MenuItemOptionSetItemIds",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return OrderItemDm.attributeTypeMap;
    }
}

/**
* Order item option
*/
export class OrderItemOption {
    /**
    * Metadata
    */
    'Metadata'?: { [key: string]: string; };
    /**
    * Public id of the Menu Item Option
    */
    'MenuItemOptionPublicId'?: string;
    /**
    * Menu item option identifier
    */
    'MenuItemOptionId'?: number;
    /**
    * Is master option set item
    */
    'IsMasterOptionSetItem'?: boolean;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Price
    */
    'Price'?: number;
    /**
    * Menu item option display order
    */
    'MenuItemOptionDisplayOrder'?: number;
    /**
    * Menu item option set display order
    */
    'MenuItemOptionSetDisplayOrder'?: number;
    /**
    * Deposit return fee
    */
    'DepositReturnFee'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "MenuItemOptionPublicId",
            "baseName": "MenuItemOptionPublicId",
            "type": "string"
        },
        {
            "name": "MenuItemOptionId",
            "baseName": "MenuItemOptionId",
            "type": "number"
        },
        {
            "name": "IsMasterOptionSetItem",
            "baseName": "IsMasterOptionSetItem",
            "type": "boolean"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "MenuItemOptionDisplayOrder",
            "baseName": "MenuItemOptionDisplayOrder",
            "type": "number"
        },
        {
            "name": "MenuItemOptionSetDisplayOrder",
            "baseName": "MenuItemOptionSetDisplayOrder",
            "type": "number"
        },
        {
            "name": "DepositReturnFee",
            "baseName": "DepositReturnFee",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return OrderItemOption.attributeTypeMap;
    }
}

/**
* When orders are accepted, and no lead time is specified by the operator, this is the lead time that will be  applied to the order.
*/
export class OrderLeadTimes {
    /**
    * Mapping from the type of order to, to the default lead time that will be applied to those orders.  The lead time is an integer number of minutes.
    */
    'LeadTimeMinutes'?: { [key: string]: number; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LeadTimeMinutes",
            "baseName": "LeadTimeMinutes",
            "type": "{ [key: string]: number; }"
        }    ];

    static getAttributeTypeMap() {
        return OrderLeadTimes.attributeTypeMap;
    }
}

/**
* A list of orders.
*/
export class OrderList {
    /**
    * A list of orders.
    */
    'Orders'?: Array<OrderReference>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Orders",
            "baseName": "Orders",
            "type": "Array<OrderReference>"
        }    ];

    static getAttributeTypeMap() {
        return OrderList.attributeTypeMap;
    }
}

/**
* Order Payment Information
*/
export class OrderPaymentInformation {
    /**
    * ID of the Order
    */
    'OrderId'?: number;
    /**
    * Signifies if the payment is refundable
    */
    'PaymentRefundable'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "PaymentRefundable",
            "baseName": "PaymentRefundable",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return OrderPaymentInformation.attributeTypeMap;
    }
}

/**
* Order Rating Update Event
*/
export class OrderRatingUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * New User Rating
    */
    'Rating'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order
    */
    'Order'?: Order;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Rating",
            "baseName": "Rating",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "Order"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderRatingUpdatedEvent.attributeTypeMap;
    }
}

/**
* A reference to an order.
*/
export class OrderReference {
    /**
    * The ID of the order.
    */
    'OrderId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return OrderReference.attributeTypeMap;
    }
}

/**
* Order Refunded Event
*/
export class OrderRefundedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The amount refunded
    */
    'RefundedAmount'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has refunded the order
    */
    'User'?: UserEventInfo;
    /**
    * Order
    */
    'Order'?: Order;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "RefundedAmount",
            "baseName": "RefundedAmount",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "Order"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderRefundedEvent.attributeTypeMap;
    }
}

/**
* Order Rejected Event
*/
export class OrderRejectedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order Rejected Time
    */
    'OrderRejectedTime'?: Date;
    /**
    * Reason for Rejection
    */
    'Reason'?: string;
    /**
    * User who has rejected the order
    */
    'User'?: UserEventInfo;
    /**
    * Order
    */
    'Order'?: Order;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "OrderRejectedTime",
            "baseName": "OrderRejectedTime",
            "type": "Date"
        },
        {
            "name": "Reason",
            "baseName": "Reason",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "Order"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderRejectedEvent.attributeTypeMap;
    }
}

/**
* Order summary
*/
export class OrderSummary {
    /**
    * Order identifier
    */
    'OrderId'?: number;
    /**
    * Delivery type
    */
    'DeliveryType'?: OrderSummary.DeliveryTypeEnum;
    /**
    * Pickup location type
    */
    'PickupLocationType'?: OrderSummary.PickupLocationTypeEnum;
    /**
    * Table service category
    */
    'TableServiceCatagory'?: OrderSummary.TableServiceCatagoryEnum;
    /**
    * Order state
    */
    'OrderState'?: OrderSummary.OrderStateEnum;
    /**
    * Order requested for
    */
    'RequestedForTime'?: Date;
    /**
    * Name of the store
    */
    'StoreName'?: string;
    /**
    * Store IANA time zone
    */
    'StoreIanaTimeZone'?: string;
    /**
    * Name of the customer
    */
    'CustomerName'?: string;
    /**
    * Phone number of customer
    */
    'CustomerPhoneNumber'?: string;
    /**
    * This is the sum of the OrderItemsAmount, DeliveryAmount, TipAmount and Voucher.Amount (which is usually negative) and OnlineOrderingFee  It does include the OnlineOrderingFee
    */
    'Amount'?: number;
    /**
    * Refunded amount
    */
    'RefundedAmount'?: number;
    /**
    * Payment Account
    */
    'PaymentAccountType'?: OrderSummary.PaymentAccountTypeEnum;
    /**
    * Status of the payment
    */
    'PaymentStatus'?: OrderSummary.PaymentStatusEnum;
    /**
    * Currency of payment
    */
    'Currency'?: OrderSummary.CurrencyEnum;
    /**
    * Type of app end user is on
    */
    'AppType'?: OrderSummary.AppTypeEnum;
    /**
    * Local order Id. This is used for displaying a \"shorter\" order ID for customers (eg. Kiosk orders)
    */
    'LocalOrderId'?: string;
    /**
    * id of the collection/drop off location
    */
    'DropOffLocationId'?: number;
    /**
    * Represents table service drop off location
    */
    'DropOffLocation'?: string;
    /**
    * Time store has accepted the order for
    */
    'AcceptedFor'?: Date;
    /**
    * Channel where the Order comes from
    */
    'Channel'?: Channel;
    /**
    * Was order made within a fraud zone
    */
    'InFraudZone'?: boolean;
    /**
    * Is order of unusually high value
    */
    'UnusualHighValueOrder'?: boolean;
    /**
    * ChannelOrderId from external channel
    */
    'ChannelOrderId'?: string;
    /**
    * ChannelOrderDisplayId from external channel
    */
    'ChannelOrderDisplayId'?: string;
    /**
    * DropOffLocation selected for this order
    */
    'OrderDropOffLocation'?: OrderDropOffLocation;
    /**
    * OrderBatch information
    */
    'OrderBatchInfo'?: OrderBatchSummary;
    'DeliveryLocation'?: DeliveryLocation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "DeliveryType",
            "baseName": "DeliveryType",
            "type": "OrderSummary.DeliveryTypeEnum"
        },
        {
            "name": "PickupLocationType",
            "baseName": "PickupLocationType",
            "type": "OrderSummary.PickupLocationTypeEnum"
        },
        {
            "name": "TableServiceCatagory",
            "baseName": "TableServiceCatagory",
            "type": "OrderSummary.TableServiceCatagoryEnum"
        },
        {
            "name": "OrderState",
            "baseName": "OrderState",
            "type": "OrderSummary.OrderStateEnum"
        },
        {
            "name": "RequestedForTime",
            "baseName": "RequestedForTime",
            "type": "Date"
        },
        {
            "name": "StoreName",
            "baseName": "StoreName",
            "type": "string"
        },
        {
            "name": "StoreIanaTimeZone",
            "baseName": "StoreIanaTimeZone",
            "type": "string"
        },
        {
            "name": "CustomerName",
            "baseName": "CustomerName",
            "type": "string"
        },
        {
            "name": "CustomerPhoneNumber",
            "baseName": "CustomerPhoneNumber",
            "type": "string"
        },
        {
            "name": "Amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "RefundedAmount",
            "baseName": "RefundedAmount",
            "type": "number"
        },
        {
            "name": "PaymentAccountType",
            "baseName": "PaymentAccountType",
            "type": "OrderSummary.PaymentAccountTypeEnum"
        },
        {
            "name": "PaymentStatus",
            "baseName": "PaymentStatus",
            "type": "OrderSummary.PaymentStatusEnum"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "OrderSummary.CurrencyEnum"
        },
        {
            "name": "AppType",
            "baseName": "AppType",
            "type": "OrderSummary.AppTypeEnum"
        },
        {
            "name": "LocalOrderId",
            "baseName": "LocalOrderId",
            "type": "string"
        },
        {
            "name": "DropOffLocationId",
            "baseName": "DropOffLocationId",
            "type": "number"
        },
        {
            "name": "DropOffLocation",
            "baseName": "DropOffLocation",
            "type": "string"
        },
        {
            "name": "AcceptedFor",
            "baseName": "AcceptedFor",
            "type": "Date"
        },
        {
            "name": "Channel",
            "baseName": "Channel",
            "type": "Channel"
        },
        {
            "name": "InFraudZone",
            "baseName": "InFraudZone",
            "type": "boolean"
        },
        {
            "name": "UnusualHighValueOrder",
            "baseName": "UnusualHighValueOrder",
            "type": "boolean"
        },
        {
            "name": "ChannelOrderId",
            "baseName": "ChannelOrderId",
            "type": "string"
        },
        {
            "name": "ChannelOrderDisplayId",
            "baseName": "ChannelOrderDisplayId",
            "type": "string"
        },
        {
            "name": "OrderDropOffLocation",
            "baseName": "OrderDropOffLocation",
            "type": "OrderDropOffLocation"
        },
        {
            "name": "OrderBatchInfo",
            "baseName": "OrderBatchInfo",
            "type": "OrderBatchSummary"
        },
        {
            "name": "DeliveryLocation",
            "baseName": "DeliveryLocation",
            "type": "DeliveryLocation"
        }    ];

    static getAttributeTypeMap() {
        return OrderSummary.attributeTypeMap;
    }
}

export namespace OrderSummary {
    export enum DeliveryTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
    export enum PickupLocationTypeEnum {
        TakeOut = <any> 'TakeOut',
        TableService = <any> 'TableService',
        DineIn = <any> 'DineIn'
    }
    export enum TableServiceCatagoryEnum {
        Generic = <any> 'Generic',
        Villa = <any> 'Villa',
        House = <any> 'House',
        Room = <any> 'Room',
        Area = <any> 'Area',
        Table = <any> 'Table',
        ParkingBay = <any> 'ParkingBay',
        Gate = <any> 'Gate',
        DriveThrough = <any> 'DriveThrough',
        Team = <any> 'Team'
    }
    export enum OrderStateEnum {
        Created = <any> 'Created',
        PlacedCanBeCancelled = <any> 'PlacedCanBeCancelled',
        ReadyToProcess = <any> 'ReadyToProcess',
        AcceptedByRestaurant = <any> 'AcceptedByRestaurant',
        Dispatched = <any> 'Dispatched',
        Delivered = <any> 'Delivered',
        Cancelled = <any> 'Cancelled',
        ManualReview = <any> 'ManualReview',
        RejectedByStore = <any> 'RejectedByStore',
        RejectedByFlipdish = <any> 'RejectedByFlipdish',
        RejectedAutomatically = <any> 'RejectedAutomatically',
        RejectedAfterBeingAccepted = <any> 'RejectedAfterBeingAccepted',
        AcceptedAndRefunded = <any> 'AcceptedAndRefunded'
    }
    export enum PaymentAccountTypeEnum {
        Card = <any> 'Card',
        Cash = <any> 'Cash',
        Ideal = <any> 'Ideal',
        Bancontact = <any> 'Bancontact',
        Giropay = <any> 'Giropay',
        Eps = <any> 'Eps',
        Emv = <any> 'Emv',
        PayPal = <any> 'PayPal',
        PayGreen = <any> 'PayGreen',
        GoogleWalletToken = <any> 'GoogleWalletToken'
    }
    export enum PaymentStatusEnum {
        Paid = <any> 'Paid',
        Unpaid = <any> 'Unpaid',
        Refunded = <any> 'Refunded',
        PartiallyRefunded = <any> 'PartiallyRefunded',
        Disputed = <any> 'Disputed'
    }
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
    export enum AppTypeEnum {
        Unknown = <any> 'Unknown',
        Ios = <any> 'Ios',
        Android = <any> 'Android',
        Web = <any> 'Web',
        Kiosk = <any> 'Kiosk',
        Pos = <any> 'Pos',
        TelephoneCall = <any> 'TelephoneCall',
        Sms = <any> 'Sms',
        PwaAndroid = <any> 'PwaAndroid',
        PwaIos = <any> 'PwaIos',
        Google = <any> 'Google'
    }
}
/**
* Order Tip Update Event
*/
export class OrderTipUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Tip Amount
    */
    'TipAmount'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Order
    */
    'Order'?: Order;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "TipAmount",
            "baseName": "TipAmount",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Order",
            "baseName": "Order",
            "type": "Order"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderTipUpdatedEvent.attributeTypeMap;
    }
}

/**
* Voucher summary
*/
export class OrderVoucherSummary {
    /**
    * Voucher ID
    */
    'VoucherId'?: number;
    /**
    * Voucher name
    */
    'Name'?: string;
    /**
    * Voucher description
    */
    'Description'?: string;
    /**
    * Voucher code
    */
    'Code'?: string;
    /**
    * Voucher amount
    */
    'Amount'?: number;
    /**
    * Voucher type
    */
    'Type'?: OrderVoucherSummary.TypeEnum;
    /**
    * Voucher sub type
    */
    'SubType'?: OrderVoucherSummary.SubTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "VoucherId",
            "baseName": "VoucherId",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        },
        {
            "name": "Amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "Type",
            "baseName": "Type",
            "type": "OrderVoucherSummary.TypeEnum"
        },
        {
            "name": "SubType",
            "baseName": "SubType",
            "type": "OrderVoucherSummary.SubTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return OrderVoucherSummary.attributeTypeMap;
    }
}

export namespace OrderVoucherSummary {
    export enum TypeEnum {
        PercentageDiscount = <any> 'PercentageDiscount',
        LumpDiscount = <any> 'LumpDiscount',
        AddItem = <any> 'AddItem',
        CreditNote = <any> 'CreditNote',
        FreeDelivery = <any> 'FreeDelivery'
    }
    export enum SubTypeEnum {
        None = <any> 'None',
        SignUp = <any> 'SignUp',
        Loyalty = <any> 'Loyalty',
        Loyalty25 = <any> 'Loyalty25',
        Retention = <any> 'Retention',
        SecondaryRetention = <any> 'SecondaryRetention',
        Custom = <any> 'Custom'
    }
}
/**
* Breakdown of other charges
*/
export class OtherChargesDetails {
    /**
    * Total amount of other charges
    */
    'TotalOtherCharges'?: number;
    /**
    * Number of other charges
    */
    'ChargesCount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TotalOtherCharges",
            "baseName": "TotalOtherCharges",
            "type": "number"
        },
        {
            "name": "ChargesCount",
            "baseName": "ChargesCount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return OtherChargesDetails.attributeTypeMap;
    }
}

/**
* OwnerEntity information to configure its {Flipdish.Metafields.PublicModels.V1.MetafieldDefinition}s
*/
export class OwnerEntityConfiguration {
    /**
    * Owner Entity
    */
    'OwnerEntity'?: OwnerEntityConfiguration.OwnerEntityEnum;
    /**
    * 
    */
    'AllowedBehaviors'?: Array<OwnerEntityConfiguration.AllowedBehaviorsEnum>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OwnerEntity",
            "baseName": "OwnerEntity",
            "type": "OwnerEntityConfiguration.OwnerEntityEnum"
        },
        {
            "name": "AllowedBehaviors",
            "baseName": "AllowedBehaviors",
            "type": "Array<OwnerEntityConfiguration.AllowedBehaviorsEnum>"
        }    ];

    static getAttributeTypeMap() {
        return OwnerEntityConfiguration.attributeTypeMap;
    }
}

export namespace OwnerEntityConfiguration {
    export enum OwnerEntityEnum {
        CatalogItem = <any> 'CatalogItem',
        CatalogGroup = <any> 'CatalogGroup',
        Menu = <any> 'Menu'
    }
    export enum AllowedBehaviorsEnum {
        SendToOrder = <any> 'SendToOrder',
        SendToMenu = <any> 'SendToMenu'
    }
}
/**
* Owner Entity Configurations
*/
export class OwnerEntityConfigurations {
    /**
    * Owner Entity Configuration
    */
    'Configurations'?: Array<OwnerEntityConfiguration>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Configurations",
            "baseName": "Configurations",
            "type": "Array<OwnerEntityConfiguration>"
        }    ];

    static getAttributeTypeMap() {
        return OwnerEntityConfigurations.attributeTypeMap;
    }
}

/**
* Password reset model
*/
export class PasswordResetModel {
    /**
    * Token Id
    */
    'TokenId'?: string;
    /**
    * Email address
    */
    'Email'?: string;
    /**
    * Password
    */
    'Password': string;
    /**
    * Password confirmation
    */
    'PasswordConfirmation': string;
    /**
    * Password reset token
    */
    'Token'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TokenId",
            "baseName": "TokenId",
            "type": "string"
        },
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "Password",
            "baseName": "Password",
            "type": "string"
        },
        {
            "name": "PasswordConfirmation",
            "baseName": "PasswordConfirmation",
            "type": "string"
        },
        {
            "name": "Token",
            "baseName": "Token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PasswordResetModel.attributeTypeMap;
    }
}

/**
* Payment information
*/
export class PaymentInfo {
    /**
    * Defines if the order was paid
    */
    'Paid'?: boolean;
    /**
    * Payment Description
    */
    'PaymentType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Paid",
            "baseName": "Paid",
            "type": "boolean"
        },
        {
            "name": "PaymentType",
            "baseName": "PaymentType",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PaymentInfo.attributeTypeMap;
    }
}

/**
* Represents stripe PaymentIntent
*/
export class PaymentIntent {
    /**
    * Id of payment intent
    */
    'Id'?: string;
    /**
    * An arbitrary string attached to the object. Often useful for displaying to users.
    */
    'Description'?: string;
    /**
    * Three-letter <a href=\"https://www.iso.org/iso-4217-currency-codes.html\">ISO currency  code</a>, in lowercase. Must be a <a href=\"https://stripe.com/docs/currencies\">supported  currency</a>.
    */
    'Currency'?: string;
    /**
    * Status of this PaymentIntent, one of requires_payment_method,  requires_confirmation, requires_action, processing,  requires_capture, canceled, or succeeded. Read more about each  PaymentIntent <a href=\"https://stripe.com/docs/payments/intents#intent-statuses\">status</a>.  One of: canceled, processing, requires_action,  requires_capture, requires_confirmation, requires_payment_method,  or succeeded.
    */
    'Status'?: string;
    /**
    * Time at which the object was created. Measured in seconds since the Unix epoch.
    */
    'Created'?: Date;
    /**
    * Failed payment intent Errors
    */
    'LastPaymentError'?: LastPaymentError;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "string"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "string"
        },
        {
            "name": "Created",
            "baseName": "Created",
            "type": "Date"
        },
        {
            "name": "LastPaymentError",
            "baseName": "LastPaymentError",
            "type": "LastPaymentError"
        }    ];

    static getAttributeTypeMap() {
        return PaymentIntent.attributeTypeMap;
    }
}

/**
* Details of Payment Terminal
*/
export class PaymentTerminalDetails {
    /**
    * Terminal Id (tid)
    */
    'TerminalId'?: string;
    /**
    * Status of Terminal
    */
    'Status'?: string;
    /**
    * Currency configured on the terminal
    */
    'Currency'?: string;
    /**
    * Location to Device
    */
    'Uri'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TerminalId",
            "baseName": "TerminalId",
            "type": "string"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "string"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "string"
        },
        {
            "name": "Uri",
            "baseName": "Uri",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PaymentTerminalDetails.attributeTypeMap;
    }
}

/**
* Details of Payment Terminal Transaction
*/
export class PaymentTerminalTransactionDetails {
    /**
    * Card Type
    */
    'CardSchemeName'?: string;
    /**
    * Expirey Date on Card
    */
    'DateOfExpiry'?: string;
    /**
    * AuthCode
    */
    'AuthCode'?: string;
    /**
    * State of Request, \"PENDING\" is not yet completed
    */
    'TransactionResult'?: string;
    /**
    * Masked PAN
    */
    'PrimaryAccountNumber'?: string;
    /**
    * Type of Verification.
    */
    'CardholderVerificationMethod'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CardSchemeName",
            "baseName": "CardSchemeName",
            "type": "string"
        },
        {
            "name": "DateOfExpiry",
            "baseName": "DateOfExpiry",
            "type": "string"
        },
        {
            "name": "AuthCode",
            "baseName": "AuthCode",
            "type": "string"
        },
        {
            "name": "TransactionResult",
            "baseName": "TransactionResult",
            "type": "string"
        },
        {
            "name": "PrimaryAccountNumber",
            "baseName": "PrimaryAccountNumber",
            "type": "string"
        },
        {
            "name": "CardholderVerificationMethod",
            "baseName": "CardholderVerificationMethod",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PaymentTerminalTransactionDetails.attributeTypeMap;
    }
}

/**
* Holds the information for a whitelabel payout.
*/
export class Payout {
    /**
    * The id of the payout.
    */
    'PayoutId'?: number;
    /**
    * Bank account identifier
    */
    'PayeeBankAccountId'?: number;
    /**
    * Account name of the payout destination
    */
    'AccountName'?: string;
    /**
    * Status of the payout
    */
    'PayoutStatus'?: Payout.PayoutStatusEnum;
    /**
    * Date payout was created
    */
    'CreatedDate'?: Date;
    /**
    * This payout includes operations after at this date (inclusive)
    */
    'PeriodStartTime'?: Date;
    /**
    * This payout includes operations before at this date (exclusive)
    */
    'PeriodEndTime'?: Date;
    /**
    * Destination bank name
    */
    'DestinationBank'?: string;
    /**
    * Last 4 digits of the destination bank IBAN
    */
    'DestinationAccount'?: string;
    /**
    * Payout amount
    */
    'Amount'?: number;
    /**
    * Type of payout source
    */
    'PayoutType'?: Payout.PayoutTypeEnum;
    /**
    * Payout currency
    */
    'Currency'?: Payout.CurrencyEnum;
    /**
    * Payouts before this date do not have a details breakdown
    */
    'CutoffDate'?: Date;
    /**
    * Payout online sales amount
    */
    'OnlineSalesAmount'?: number;
    /**
    * Payout online sales delivery charges
    */
    'OnlineSalesDeliveryCharges'?: number;
    /**
    * Payout online sales tips
    */
    'OnlineSalesTips'?: number;
    /**
    * Payout online sales service charges
    */
    'OnlineSalesServiceCharges'?: number;
    /**
    * Payout online sales refunded fees
    */
    'OnlineSalesRefundedFees'?: number;
    /**
    * Payout online sales fees
    */
    'OnlineSalesFees'?: number;
    /**
    * Payout online sales fees
    */
    'PosSalesFees'?: number;
    /**
    * Payout online sales refunded amount
    */
    'OnlineSalesRefundedAmount'?: number;
    /**
    * POS Payout online sales refunded amount
    */
    'PosSalesRefundedAmount'?: number;
    /**
    * Payout online sales tax
    */
    'OnlineSalesTax'?: number;
    /**
    * Payout total online revenue
    */
    'TotalOnlineRevenue'?: number;
    /**
    * Payout cash sales fees
    */
    'CashSalesFees'?: number;
    /**
    * Payout cash sales refunded fees
    */
    'CashSalesRefundedFees'?: number;
    /**
    * Payout cash fees charged to customer
    */
    'CustomerCashFees'?: number;
    /**
    * Payout sales fees vat
    */
    'SalesFeesVat'?: number;
    /**
    * Payout total fees
    */
    'TotalFees'?: number;
    /**
    * Payout total online revenue adjustments
    */
    'TotalOnlineRevenueAdjustments'?: number;
    /**
    * Payout chargeback amount
    */
    'ChargebackAmount'?: number;
    /**
    * POS Payout chargeback amount
    */
    'PosSalesChargebackAmount'?: number;
    /**
    * Payout chargeback refunded fees
    */
    'ChargebackRefundedFees'?: number;
    /**
    * Payout chargebacks total cost
    */
    'TotalChargebackCost'?: number;
    /**
    * Payout other charges total
    */
    'TotalOtherCharges'?: number;
    /**
    * Payout opening balance
    */
    'OpeningBalance'?: number;
    /**
    * Payout closing balance
    */
    'ClosingBalance'?: number;
    /**
    * Amount of sales through PayGreen (restaurant vouchers)
    */
    'PayGreenSalesAmount'?: number;
    /**
    * Third party integration delivery fee
    */
    'DeliveryIntegrationFee'?: number;
    /**
    * Third party integration delivery tip fee
    */
    'DeliveryIntegrationTipFee'?: number;
    /**
    * Total third party integration fees
    */
    'TotalThirdPartyFees'?: number;
    /**
    * POS sales amount
    */
    'PosSalesAmount'?: number;
    /**
    * POS sales tax
    */
    'PosSalesTax'?: number;
    /**
    * Tips on POS sales
    */
    'TipsOnPosSales'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PayoutId",
            "baseName": "PayoutId",
            "type": "number"
        },
        {
            "name": "PayeeBankAccountId",
            "baseName": "PayeeBankAccountId",
            "type": "number"
        },
        {
            "name": "AccountName",
            "baseName": "AccountName",
            "type": "string"
        },
        {
            "name": "PayoutStatus",
            "baseName": "PayoutStatus",
            "type": "Payout.PayoutStatusEnum"
        },
        {
            "name": "CreatedDate",
            "baseName": "CreatedDate",
            "type": "Date"
        },
        {
            "name": "PeriodStartTime",
            "baseName": "PeriodStartTime",
            "type": "Date"
        },
        {
            "name": "PeriodEndTime",
            "baseName": "PeriodEndTime",
            "type": "Date"
        },
        {
            "name": "DestinationBank",
            "baseName": "DestinationBank",
            "type": "string"
        },
        {
            "name": "DestinationAccount",
            "baseName": "DestinationAccount",
            "type": "string"
        },
        {
            "name": "Amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "PayoutType",
            "baseName": "PayoutType",
            "type": "Payout.PayoutTypeEnum"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "Payout.CurrencyEnum"
        },
        {
            "name": "CutoffDate",
            "baseName": "CutoffDate",
            "type": "Date"
        },
        {
            "name": "OnlineSalesAmount",
            "baseName": "OnlineSalesAmount",
            "type": "number"
        },
        {
            "name": "OnlineSalesDeliveryCharges",
            "baseName": "OnlineSalesDeliveryCharges",
            "type": "number"
        },
        {
            "name": "OnlineSalesTips",
            "baseName": "OnlineSalesTips",
            "type": "number"
        },
        {
            "name": "OnlineSalesServiceCharges",
            "baseName": "OnlineSalesServiceCharges",
            "type": "number"
        },
        {
            "name": "OnlineSalesRefundedFees",
            "baseName": "OnlineSalesRefundedFees",
            "type": "number"
        },
        {
            "name": "OnlineSalesFees",
            "baseName": "OnlineSalesFees",
            "type": "number"
        },
        {
            "name": "PosSalesFees",
            "baseName": "PosSalesFees",
            "type": "number"
        },
        {
            "name": "OnlineSalesRefundedAmount",
            "baseName": "OnlineSalesRefundedAmount",
            "type": "number"
        },
        {
            "name": "PosSalesRefundedAmount",
            "baseName": "PosSalesRefundedAmount",
            "type": "number"
        },
        {
            "name": "OnlineSalesTax",
            "baseName": "OnlineSalesTax",
            "type": "number"
        },
        {
            "name": "TotalOnlineRevenue",
            "baseName": "TotalOnlineRevenue",
            "type": "number"
        },
        {
            "name": "CashSalesFees",
            "baseName": "CashSalesFees",
            "type": "number"
        },
        {
            "name": "CashSalesRefundedFees",
            "baseName": "CashSalesRefundedFees",
            "type": "number"
        },
        {
            "name": "CustomerCashFees",
            "baseName": "CustomerCashFees",
            "type": "number"
        },
        {
            "name": "SalesFeesVat",
            "baseName": "SalesFeesVat",
            "type": "number"
        },
        {
            "name": "TotalFees",
            "baseName": "TotalFees",
            "type": "number"
        },
        {
            "name": "TotalOnlineRevenueAdjustments",
            "baseName": "TotalOnlineRevenueAdjustments",
            "type": "number"
        },
        {
            "name": "ChargebackAmount",
            "baseName": "ChargebackAmount",
            "type": "number"
        },
        {
            "name": "PosSalesChargebackAmount",
            "baseName": "PosSalesChargebackAmount",
            "type": "number"
        },
        {
            "name": "ChargebackRefundedFees",
            "baseName": "ChargebackRefundedFees",
            "type": "number"
        },
        {
            "name": "TotalChargebackCost",
            "baseName": "TotalChargebackCost",
            "type": "number"
        },
        {
            "name": "TotalOtherCharges",
            "baseName": "TotalOtherCharges",
            "type": "number"
        },
        {
            "name": "OpeningBalance",
            "baseName": "OpeningBalance",
            "type": "number"
        },
        {
            "name": "ClosingBalance",
            "baseName": "ClosingBalance",
            "type": "number"
        },
        {
            "name": "PayGreenSalesAmount",
            "baseName": "PayGreenSalesAmount",
            "type": "number"
        },
        {
            "name": "DeliveryIntegrationFee",
            "baseName": "DeliveryIntegrationFee",
            "type": "number"
        },
        {
            "name": "DeliveryIntegrationTipFee",
            "baseName": "DeliveryIntegrationTipFee",
            "type": "number"
        },
        {
            "name": "TotalThirdPartyFees",
            "baseName": "TotalThirdPartyFees",
            "type": "number"
        },
        {
            "name": "PosSalesAmount",
            "baseName": "PosSalesAmount",
            "type": "number"
        },
        {
            "name": "PosSalesTax",
            "baseName": "PosSalesTax",
            "type": "number"
        },
        {
            "name": "TipsOnPosSales",
            "baseName": "TipsOnPosSales",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Payout.attributeTypeMap;
    }
}

export namespace Payout {
    export enum PayoutStatusEnum {
        Pending = <any> 'Pending',
        InTransit = <any> 'InTransit',
        Paid = <any> 'Paid',
        Failed = <any> 'Failed',
        Cancelled = <any> 'Cancelled'
    }
    export enum PayoutTypeEnum {
        Internal = <any> 'Internal',
        Stripe = <any> 'Stripe'
    }
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Holds the information for a chargeback related to a payout
*/
export class PayoutChargeback {
    /**
    * The id of the order the chargeback was for
    */
    'OrderId'?: number;
    /**
    * Order currency
    */
    'OrderCurrency'?: PayoutChargeback.OrderCurrencyEnum;
    /**
    * The id of the payout the order is related to
    */
    'PayoutId'?: number;
    /**
    * The date the order was placed
    */
    'OrderDate'?: Date;
    /**
    * Order type (online or cash)
    */
    'OrderType'?: PayoutChargeback.OrderTypeEnum;
    /**
    * The date the chargeback was done
    */
    'ChargebackDate'?: Date;
    /**
    * Store id
    */
    'StoreId'?: number;
    /**
    * Chargeback amount
    */
    'ChargebackAmount'?: number;
    /**
    * Amount of refunded fees
    */
    'RefundedFees'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "OrderCurrency",
            "baseName": "OrderCurrency",
            "type": "PayoutChargeback.OrderCurrencyEnum"
        },
        {
            "name": "PayoutId",
            "baseName": "PayoutId",
            "type": "number"
        },
        {
            "name": "OrderDate",
            "baseName": "OrderDate",
            "type": "Date"
        },
        {
            "name": "OrderType",
            "baseName": "OrderType",
            "type": "PayoutChargeback.OrderTypeEnum"
        },
        {
            "name": "ChargebackDate",
            "baseName": "ChargebackDate",
            "type": "Date"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "ChargebackAmount",
            "baseName": "ChargebackAmount",
            "type": "number"
        },
        {
            "name": "RefundedFees",
            "baseName": "RefundedFees",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PayoutChargeback.attributeTypeMap;
    }
}

export namespace PayoutChargeback {
    export enum OrderCurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
    export enum OrderTypeEnum {
        Cash = <any> 'Cash',
        Online = <any> 'Online'
    }
}
/**
* Holds the information for a whitelabel payout with details broken down by Store
*/
export class PayoutDetail {
    /**
    * The id of the payout.
    */
    'PayoutId'?: number;
    /**
    * Bank account identifier
    */
    'BankAccountId'?: number;
    /**
    * Account name of the payout destination
    */
    'AccountName'?: string;
    /**
    * Status of the payout
    */
    'PayoutStatus'?: PayoutDetail.PayoutStatusEnum;
    /**
    * Date payout was created
    */
    'CreatedDate'?: Date;
    /**
    * This payout includes operations after at this date (inclusive)
    */
    'PeriodStartTime'?: Date;
    /**
    * This payout includes operations before at this date (exclusive)
    */
    'PeriodEndTime'?: Date;
    /**
    * Destination bank name
    */
    'DestinationBank'?: string;
    /**
    * Last 4 digits of the destination bank IBAN
    */
    'DestinationAccount'?: string;
    /**
    * Type of payout source
    */
    'PayoutType'?: PayoutDetail.PayoutTypeEnum;
    /**
    * Payout currency
    */
    'Currency'?: PayoutDetail.CurrencyEnum;
    /**
    * Payout information broken down by Store
    */
    'PayoutStores'?: Array<PayoutStore>;
    /**
    * Payout amount
    */
    'Amount'?: number;
    /**
    * Payouts before this date do not have a details breakdown
    */
    'CutoffDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PayoutId",
            "baseName": "PayoutId",
            "type": "number"
        },
        {
            "name": "BankAccountId",
            "baseName": "BankAccountId",
            "type": "number"
        },
        {
            "name": "AccountName",
            "baseName": "AccountName",
            "type": "string"
        },
        {
            "name": "PayoutStatus",
            "baseName": "PayoutStatus",
            "type": "PayoutDetail.PayoutStatusEnum"
        },
        {
            "name": "CreatedDate",
            "baseName": "CreatedDate",
            "type": "Date"
        },
        {
            "name": "PeriodStartTime",
            "baseName": "PeriodStartTime",
            "type": "Date"
        },
        {
            "name": "PeriodEndTime",
            "baseName": "PeriodEndTime",
            "type": "Date"
        },
        {
            "name": "DestinationBank",
            "baseName": "DestinationBank",
            "type": "string"
        },
        {
            "name": "DestinationAccount",
            "baseName": "DestinationAccount",
            "type": "string"
        },
        {
            "name": "PayoutType",
            "baseName": "PayoutType",
            "type": "PayoutDetail.PayoutTypeEnum"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "PayoutDetail.CurrencyEnum"
        },
        {
            "name": "PayoutStores",
            "baseName": "PayoutStores",
            "type": "Array<PayoutStore>"
        },
        {
            "name": "Amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "CutoffDate",
            "baseName": "CutoffDate",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return PayoutDetail.attributeTypeMap;
    }
}

export namespace PayoutDetail {
    export enum PayoutStatusEnum {
        Pending = <any> 'Pending',
        InTransit = <any> 'InTransit',
        Paid = <any> 'Paid',
        Failed = <any> 'Failed',
        Cancelled = <any> 'Cancelled'
    }
    export enum PayoutTypeEnum {
        Internal = <any> 'Internal',
        Stripe = <any> 'Stripe'
    }
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Holds the information for an order related to a payout
*/
export class PayoutOrder {
    /**
    * The id of the order
    */
    'OrderId'?: number;
    /**
    * The id of the payout the order is related to
    */
    'PayoutId'?: number;
    /**
    * The date the order was placed
    */
    'OrderDate'?: Date;
    /**
    * Order type (online or cash)
    */
    'OrderType'?: PayoutOrder.OrderTypeEnum;
    /**
    * Order currency
    */
    'OrderCurrency'?: PayoutOrder.OrderCurrencyEnum;
    /**
    * Order sales amount
    */
    'Sales'?: number;
    /**
    * Order sales tax amount
    */
    'SalesTax'?: number;
    /**
    * Order delivery charges
    */
    'DeliveryCharges'?: number;
    /**
    * Order tips amount
    */
    'Tips'?: number;
    /**
    * Order voucher amount
    */
    'Voucher'?: number;
    /**
    * Order flat fee amount excluding VAT
    */
    'FlatFeeExcludingVat'?: number;
    /**
    * Order flat fee amount excluding VAT
    */
    'FlatFeeExcludingVAT'?: number;
    /**
    * Order flat fee amount including VAT
    */
    'FlatFeeIncludingVat'?: number;
    /**
    * Order percentage fee excluding VAT
    */
    'PercentageFeeExcludingVat'?: number;
    /**
    * Order percentage fee excluding VAT
    */
    'PercentageFeeExcludingVAT'?: number;
    /**
    * Order VAT amount
    */
    'Vat'?: number;
    /**
    * Total order fees amount
    */
    'TotalFees'?: number;
    /**
    * Cash fee charged to customer
    */
    'CashFeeChargedToCustomer'?: number;
    /**
    * Order net sales amount
    */
    'NetSales'?: number;
    /**
    * Store id
    */
    'StoreId'?: number;
    /**
    * Order ServiceChargeAmount amount
    */
    'ServiceChargeAmount'?: number;
    /**
    * Order ServiceChargePercentage amount
    */
    'ServiceChargePercentage'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "PayoutId",
            "baseName": "PayoutId",
            "type": "number"
        },
        {
            "name": "OrderDate",
            "baseName": "OrderDate",
            "type": "Date"
        },
        {
            "name": "OrderType",
            "baseName": "OrderType",
            "type": "PayoutOrder.OrderTypeEnum"
        },
        {
            "name": "OrderCurrency",
            "baseName": "OrderCurrency",
            "type": "PayoutOrder.OrderCurrencyEnum"
        },
        {
            "name": "Sales",
            "baseName": "Sales",
            "type": "number"
        },
        {
            "name": "SalesTax",
            "baseName": "SalesTax",
            "type": "number"
        },
        {
            "name": "DeliveryCharges",
            "baseName": "DeliveryCharges",
            "type": "number"
        },
        {
            "name": "Tips",
            "baseName": "Tips",
            "type": "number"
        },
        {
            "name": "Voucher",
            "baseName": "Voucher",
            "type": "number"
        },
        {
            "name": "FlatFeeExcludingVat",
            "baseName": "FlatFeeExcludingVat",
            "type": "number"
        },
        {
            "name": "FlatFeeExcludingVAT",
            "baseName": "FlatFeeExcludingVAT",
            "type": "number"
        },
        {
            "name": "FlatFeeIncludingVat",
            "baseName": "FlatFeeIncludingVat",
            "type": "number"
        },
        {
            "name": "PercentageFeeExcludingVat",
            "baseName": "PercentageFeeExcludingVat",
            "type": "number"
        },
        {
            "name": "PercentageFeeExcludingVAT",
            "baseName": "PercentageFeeExcludingVAT",
            "type": "number"
        },
        {
            "name": "Vat",
            "baseName": "Vat",
            "type": "number"
        },
        {
            "name": "TotalFees",
            "baseName": "TotalFees",
            "type": "number"
        },
        {
            "name": "CashFeeChargedToCustomer",
            "baseName": "CashFeeChargedToCustomer",
            "type": "number"
        },
        {
            "name": "NetSales",
            "baseName": "NetSales",
            "type": "number"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "ServiceChargeAmount",
            "baseName": "ServiceChargeAmount",
            "type": "number"
        },
        {
            "name": "ServiceChargePercentage",
            "baseName": "ServiceChargePercentage",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PayoutOrder.attributeTypeMap;
    }
}

export namespace PayoutOrder {
    export enum OrderTypeEnum {
        Cash = <any> 'Cash',
        Online = <any> 'Online'
    }
    export enum OrderCurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Holds the information for a charge related to a payout
*/
export class PayoutOtherCharge {
    /**
    * The id of the charge
    */
    'ChargeId'?: number;
    /**
    * Charge amount
    */
    'Amount'?: number;
    /**
    * Currency of the charge
    */
    'Currency'?: PayoutOtherCharge.CurrencyEnum;
    /**
    * The id of the payout the order is related to
    */
    'PayoutId'?: number;
    /**
    * The date the order was placed
    */
    'ChargeDate'?: Date;
    /**
    * Charge type
    */
    'ChargeType'?: PayoutOtherCharge.ChargeTypeEnum;
    /**
    * Charge description
    */
    'ChargeDescription'?: string;
    /**
    * Store id
    */
    'StoreId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ChargeId",
            "baseName": "ChargeId",
            "type": "number"
        },
        {
            "name": "Amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "PayoutOtherCharge.CurrencyEnum"
        },
        {
            "name": "PayoutId",
            "baseName": "PayoutId",
            "type": "number"
        },
        {
            "name": "ChargeDate",
            "baseName": "ChargeDate",
            "type": "Date"
        },
        {
            "name": "ChargeType",
            "baseName": "ChargeType",
            "type": "PayoutOtherCharge.ChargeTypeEnum"
        },
        {
            "name": "ChargeDescription",
            "baseName": "ChargeDescription",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PayoutOtherCharge.attributeTypeMap;
    }
}

export namespace PayoutOtherCharge {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
    export enum ChargeTypeEnum {
        Other = <any> 'Other',
        Fees = <any> 'Fees',
        Chargeback = <any> 'Chargeback',
        TipFailure = <any> 'TipFailure',
        ExternalDisbursement = <any> 'ExternalDisbursement',
        Goods = <any> 'Goods',
        RestaurantSales = <any> 'RestaurantSales',
        Tips = <any> 'Tips'
    }
}
/**
* Holds the information for a refund related to a payout
*/
export class PayoutRefund {
    /**
    * The id of the order the refund was for
    */
    'OrderId'?: number;
    /**
    * Order currency
    */
    'OrderCurrency'?: PayoutRefund.OrderCurrencyEnum;
    /**
    * The id of the payout the order is related to
    */
    'PayoutId'?: number;
    /**
    * The date the order was placed
    */
    'OrderDate'?: Date;
    /**
    * Order type (online or cash)
    */
    'OrderType'?: PayoutRefund.OrderTypeEnum;
    /**
    * The date the refund was done
    */
    'RefundDate'?: Date;
    /**
    * Store id
    */
    'StoreId'?: number;
    /**
    * Total refund amount
    */
    'TotalRefund'?: number;
    /**
    * Refunded fees amount
    */
    'RefundedFees'?: number;
    /**
    * Refunded amount
    */
    'RefundedAmount'?: number;
    /**
    * Cash fee refunded to customer
    */
    'CashFeeRefundedToCustomer'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "OrderCurrency",
            "baseName": "OrderCurrency",
            "type": "PayoutRefund.OrderCurrencyEnum"
        },
        {
            "name": "PayoutId",
            "baseName": "PayoutId",
            "type": "number"
        },
        {
            "name": "OrderDate",
            "baseName": "OrderDate",
            "type": "Date"
        },
        {
            "name": "OrderType",
            "baseName": "OrderType",
            "type": "PayoutRefund.OrderTypeEnum"
        },
        {
            "name": "RefundDate",
            "baseName": "RefundDate",
            "type": "Date"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "TotalRefund",
            "baseName": "TotalRefund",
            "type": "number"
        },
        {
            "name": "RefundedFees",
            "baseName": "RefundedFees",
            "type": "number"
        },
        {
            "name": "RefundedAmount",
            "baseName": "RefundedAmount",
            "type": "number"
        },
        {
            "name": "CashFeeRefundedToCustomer",
            "baseName": "CashFeeRefundedToCustomer",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PayoutRefund.attributeTypeMap;
    }
}

export namespace PayoutRefund {
    export enum OrderCurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
    export enum OrderTypeEnum {
        Cash = <any> 'Cash',
        Online = <any> 'Online'
    }
}
export class PayoutReport3Details {
    'Amount'?: number;
    'Currency'?: string;
    'Summary'?: PayoutReport3DetailsSummary;
    'Revenue'?: PayoutReport3DetailsRevenue;
    'FlipdishFees'?: PayoutReport3DetailsFlipdishFees;
    'Adjustments'?: PayoutReport3DetailsAdjustments;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "string"
        },
        {
            "name": "Summary",
            "baseName": "Summary",
            "type": "PayoutReport3DetailsSummary"
        },
        {
            "name": "Revenue",
            "baseName": "Revenue",
            "type": "PayoutReport3DetailsRevenue"
        },
        {
            "name": "FlipdishFees",
            "baseName": "FlipdishFees",
            "type": "PayoutReport3DetailsFlipdishFees"
        },
        {
            "name": "Adjustments",
            "baseName": "Adjustments",
            "type": "PayoutReport3DetailsAdjustments"
        }    ];

    static getAttributeTypeMap() {
        return PayoutReport3Details.attributeTypeMap;
    }
}

export class PayoutReport3DetailsAdjustments {
    'OpeningBalanceDate'?: Date;
    'ClosingBalanceDate'?: Date;
    'OpeningBalance'?: number;
    'RefundsOnCardOrders'?: number;
    'RefundsOnCashOrders'?: number;
    'CashCustomerFees'?: number;
    'Chargebacks'?: number;
    'OtherTransactions'?: number;
    'ClosingBalance'?: number;
    'BalanceRepaid'?: number;
    'RefundsOnCardOrdersBracketsAmount'?: number;
    'RefundsOnCardOrdersBracketsOutOfAmount'?: number;
    'RefundsOnCashOrdersBracketsAmount'?: number;
    'RefundsOnCashOrdersBracketsOutOfAmount'?: number;
    'CashCustomerFeesBracketsAmount'?: number;
    'CashCustomerFeesBracketsOutOfAmount'?: number;
    'BalanceChange'?: number;
    'PreviousPayoutId'?: number;
    'NextPayoutId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OpeningBalanceDate",
            "baseName": "OpeningBalanceDate",
            "type": "Date"
        },
        {
            "name": "ClosingBalanceDate",
            "baseName": "ClosingBalanceDate",
            "type": "Date"
        },
        {
            "name": "OpeningBalance",
            "baseName": "OpeningBalance",
            "type": "number"
        },
        {
            "name": "RefundsOnCardOrders",
            "baseName": "RefundsOnCardOrders",
            "type": "number"
        },
        {
            "name": "RefundsOnCashOrders",
            "baseName": "RefundsOnCashOrders",
            "type": "number"
        },
        {
            "name": "CashCustomerFees",
            "baseName": "CashCustomerFees",
            "type": "number"
        },
        {
            "name": "Chargebacks",
            "baseName": "Chargebacks",
            "type": "number"
        },
        {
            "name": "OtherTransactions",
            "baseName": "OtherTransactions",
            "type": "number"
        },
        {
            "name": "ClosingBalance",
            "baseName": "ClosingBalance",
            "type": "number"
        },
        {
            "name": "BalanceRepaid",
            "baseName": "BalanceRepaid",
            "type": "number"
        },
        {
            "name": "RefundsOnCardOrdersBracketsAmount",
            "baseName": "RefundsOnCardOrdersBracketsAmount",
            "type": "number"
        },
        {
            "name": "RefundsOnCardOrdersBracketsOutOfAmount",
            "baseName": "RefundsOnCardOrdersBracketsOutOfAmount",
            "type": "number"
        },
        {
            "name": "RefundsOnCashOrdersBracketsAmount",
            "baseName": "RefundsOnCashOrdersBracketsAmount",
            "type": "number"
        },
        {
            "name": "RefundsOnCashOrdersBracketsOutOfAmount",
            "baseName": "RefundsOnCashOrdersBracketsOutOfAmount",
            "type": "number"
        },
        {
            "name": "CashCustomerFeesBracketsAmount",
            "baseName": "CashCustomerFeesBracketsAmount",
            "type": "number"
        },
        {
            "name": "CashCustomerFeesBracketsOutOfAmount",
            "baseName": "CashCustomerFeesBracketsOutOfAmount",
            "type": "number"
        },
        {
            "name": "BalanceChange",
            "baseName": "BalanceChange",
            "type": "number"
        },
        {
            "name": "PreviousPayoutId",
            "baseName": "PreviousPayoutId",
            "type": "number"
        },
        {
            "name": "NextPayoutId",
            "baseName": "NextPayoutId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PayoutReport3DetailsAdjustments.attributeTypeMap;
    }
}

export class PayoutReport3DetailsFlipdishFees {
    'WebAndAppCash'?: number;
    'WebAndAppCashRevenueIncludingTips'?: number;
    'WebAndAppCard'?: number;
    'WebAndAppCardRevenueIncludingTips'?: number;
    'KioskCash'?: number;
    'KioskCashRevenue'?: number;
    'KioskCard'?: number;
    'KioskCardRevenue'?: number;
    'QropCash'?: number;
    'QropCard'?: number;
    'PosCard'?: number;
    'PosCardRevenue'?: number;
    'PosCardOnFlipdishOrders'?: number;
    'OtherIntegrationFees'?: number;
    'OtherIntegrationTips'?: number;
    'RefundedFeesOnRefundedSales'?: number;
    'Vat'?: number;
    'Total'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "WebAndAppCash",
            "baseName": "WebAndAppCash",
            "type": "number"
        },
        {
            "name": "WebAndAppCashRevenueIncludingTips",
            "baseName": "WebAndAppCashRevenueIncludingTips",
            "type": "number"
        },
        {
            "name": "WebAndAppCard",
            "baseName": "WebAndAppCard",
            "type": "number"
        },
        {
            "name": "WebAndAppCardRevenueIncludingTips",
            "baseName": "WebAndAppCardRevenueIncludingTips",
            "type": "number"
        },
        {
            "name": "KioskCash",
            "baseName": "KioskCash",
            "type": "number"
        },
        {
            "name": "KioskCashRevenue",
            "baseName": "KioskCashRevenue",
            "type": "number"
        },
        {
            "name": "KioskCard",
            "baseName": "KioskCard",
            "type": "number"
        },
        {
            "name": "KioskCardRevenue",
            "baseName": "KioskCardRevenue",
            "type": "number"
        },
        {
            "name": "QropCash",
            "baseName": "QropCash",
            "type": "number"
        },
        {
            "name": "QropCard",
            "baseName": "QropCard",
            "type": "number"
        },
        {
            "name": "PosCard",
            "baseName": "PosCard",
            "type": "number"
        },
        {
            "name": "PosCardRevenue",
            "baseName": "PosCardRevenue",
            "type": "number"
        },
        {
            "name": "PosCardOnFlipdishOrders",
            "baseName": "PosCardOnFlipdishOrders",
            "type": "number"
        },
        {
            "name": "OtherIntegrationFees",
            "baseName": "OtherIntegrationFees",
            "type": "number"
        },
        {
            "name": "OtherIntegrationTips",
            "baseName": "OtherIntegrationTips",
            "type": "number"
        },
        {
            "name": "RefundedFeesOnRefundedSales",
            "baseName": "RefundedFeesOnRefundedSales",
            "type": "number"
        },
        {
            "name": "Vat",
            "baseName": "Vat",
            "type": "number"
        },
        {
            "name": "Total",
            "baseName": "Total",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PayoutReport3DetailsFlipdishFees.attributeTypeMap;
    }
}

export class PayoutReport3DetailsRevenue {
    'GrossSales'?: PayoutReport3DetailsSalesLine;
    'SalesTax'?: PayoutReport3DetailsSalesLine;
    'DeliveryCharges'?: PayoutReport3DetailsSalesLine;
    'OtherCharges'?: PayoutReport3DetailsSalesLine;
    'Tips'?: PayoutReport3DetailsSalesLine;
    'TotalRevenue'?: PayoutReport3DetailsSalesLine;
    'RevenueForFeeCalculations'?: PayoutReport3DetailsSalesLine;
    'DrsCharges'?: PayoutReport3DetailsSalesLine;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "GrossSales",
            "baseName": "GrossSales",
            "type": "PayoutReport3DetailsSalesLine"
        },
        {
            "name": "SalesTax",
            "baseName": "SalesTax",
            "type": "PayoutReport3DetailsSalesLine"
        },
        {
            "name": "DeliveryCharges",
            "baseName": "DeliveryCharges",
            "type": "PayoutReport3DetailsSalesLine"
        },
        {
            "name": "OtherCharges",
            "baseName": "OtherCharges",
            "type": "PayoutReport3DetailsSalesLine"
        },
        {
            "name": "Tips",
            "baseName": "Tips",
            "type": "PayoutReport3DetailsSalesLine"
        },
        {
            "name": "TotalRevenue",
            "baseName": "TotalRevenue",
            "type": "PayoutReport3DetailsSalesLine"
        },
        {
            "name": "RevenueForFeeCalculations",
            "baseName": "RevenueForFeeCalculations",
            "type": "PayoutReport3DetailsSalesLine"
        },
        {
            "name": "DrsCharges",
            "baseName": "DrsCharges",
            "type": "PayoutReport3DetailsSalesLine"
        }    ];

    static getAttributeTypeMap() {
        return PayoutReport3DetailsRevenue.attributeTypeMap;
    }
}

export class PayoutReport3DetailsSalesLine {
    'Online'?: number;
    'Pos'?: number;
    'Other'?: number;
    'Total'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Online",
            "baseName": "Online",
            "type": "number"
        },
        {
            "name": "Pos",
            "baseName": "Pos",
            "type": "number"
        },
        {
            "name": "Other",
            "baseName": "Other",
            "type": "number"
        },
        {
            "name": "Total",
            "baseName": "Total",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PayoutReport3DetailsSalesLine.attributeTypeMap;
    }
}

export class PayoutReport3DetailsSummary {
    'Revenue'?: number;
    'RevenueOfWhichCash'?: number;
    'RevenueForFeeCalculations'?: number;
    'FlipdishFees'?: number;
    'Adjustments'?: number;
    'ThirdPartyIntegrationFeesAndTips'?: number;
    'Total'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Revenue",
            "baseName": "Revenue",
            "type": "number"
        },
        {
            "name": "RevenueOfWhichCash",
            "baseName": "RevenueOfWhichCash",
            "type": "number"
        },
        {
            "name": "RevenueForFeeCalculations",
            "baseName": "RevenueForFeeCalculations",
            "type": "number"
        },
        {
            "name": "FlipdishFees",
            "baseName": "FlipdishFees",
            "type": "number"
        },
        {
            "name": "Adjustments",
            "baseName": "Adjustments",
            "type": "number"
        },
        {
            "name": "ThirdPartyIntegrationFeesAndTips",
            "baseName": "ThirdPartyIntegrationFeesAndTips",
            "type": "number"
        },
        {
            "name": "Total",
            "baseName": "Total",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PayoutReport3DetailsSummary.attributeTypeMap;
    }
}

export class PayoutReport3Overview {
    'PayoutReport3OverviewHeader'?: PayoutReport3OverviewHeader;
    'PayoutStores'?: Array<PayoutReport3Store>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PayoutReport3OverviewHeader",
            "baseName": "PayoutReport3OverviewHeader",
            "type": "PayoutReport3OverviewHeader"
        },
        {
            "name": "PayoutStores",
            "baseName": "PayoutStores",
            "type": "Array<PayoutReport3Store>"
        }    ];

    static getAttributeTypeMap() {
        return PayoutReport3Overview.attributeTypeMap;
    }
}

export class PayoutReport3OverviewHeader {
    'PayoutId'?: number;
    'BankAccountId'?: number;
    'IsManualPayout'?: boolean;
    'AccountName'?: string;
    'PayoutStatus'?: string;
    'CreatedDate'?: Date;
    'PeriodStartTime'?: Date;
    'PeriodEndTime'?: Date;
    'DestinationBank'?: string;
    'DestinationAccount'?: string;
    'Amount'?: number;
    'Currency'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PayoutId",
            "baseName": "PayoutId",
            "type": "number"
        },
        {
            "name": "BankAccountId",
            "baseName": "BankAccountId",
            "type": "number"
        },
        {
            "name": "IsManualPayout",
            "baseName": "IsManualPayout",
            "type": "boolean"
        },
        {
            "name": "AccountName",
            "baseName": "AccountName",
            "type": "string"
        },
        {
            "name": "PayoutStatus",
            "baseName": "PayoutStatus",
            "type": "string"
        },
        {
            "name": "CreatedDate",
            "baseName": "CreatedDate",
            "type": "Date"
        },
        {
            "name": "PeriodStartTime",
            "baseName": "PeriodStartTime",
            "type": "Date"
        },
        {
            "name": "PeriodEndTime",
            "baseName": "PeriodEndTime",
            "type": "Date"
        },
        {
            "name": "DestinationBank",
            "baseName": "DestinationBank",
            "type": "string"
        },
        {
            "name": "DestinationAccount",
            "baseName": "DestinationAccount",
            "type": "string"
        },
        {
            "name": "Amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PayoutReport3OverviewHeader.attributeTypeMap;
    }
}

export class PayoutReport3PayoutOrder {
    'OrderId'?: number;
    'OrderDate'?: Date;
    'StoreId'?: number;
    'StoreName'?: string;
    'OrderType'?: PayoutReport3PayoutOrder.OrderTypeEnum;
    'Sales'?: number;
    'SalesTax'?: number;
    'DeliveryCharges'?: number;
    'Tips'?: number;
    'Voucher'?: number;
    'OrderCurrency'?: PayoutReport3PayoutOrder.OrderCurrencyEnum;
    'RefundChargebackType'?: PayoutReport3PayoutOrder.RefundChargebackTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "OrderDate",
            "baseName": "OrderDate",
            "type": "Date"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreName",
            "baseName": "StoreName",
            "type": "string"
        },
        {
            "name": "OrderType",
            "baseName": "OrderType",
            "type": "PayoutReport3PayoutOrder.OrderTypeEnum"
        },
        {
            "name": "Sales",
            "baseName": "Sales",
            "type": "number"
        },
        {
            "name": "SalesTax",
            "baseName": "SalesTax",
            "type": "number"
        },
        {
            "name": "DeliveryCharges",
            "baseName": "DeliveryCharges",
            "type": "number"
        },
        {
            "name": "Tips",
            "baseName": "Tips",
            "type": "number"
        },
        {
            "name": "Voucher",
            "baseName": "Voucher",
            "type": "number"
        },
        {
            "name": "OrderCurrency",
            "baseName": "OrderCurrency",
            "type": "PayoutReport3PayoutOrder.OrderCurrencyEnum"
        },
        {
            "name": "RefundChargebackType",
            "baseName": "RefundChargebackType",
            "type": "PayoutReport3PayoutOrder.RefundChargebackTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return PayoutReport3PayoutOrder.attributeTypeMap;
    }
}

export namespace PayoutReport3PayoutOrder {
    export enum OrderTypeEnum {
        Cash = <any> 'Cash',
        Card = <any> 'Card'
    }
    export enum OrderCurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
    export enum RefundChargebackTypeEnum {
        Refund = <any> 'Refund',
        Chargeback = <any> 'Chargeback'
    }
}
export class PayoutReport3Store {
    'StoreId'?: number;
    'StoreName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreName",
            "baseName": "StoreName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PayoutReport3Store.attributeTypeMap;
    }
}

/**
* Payout Request ids for filtering on Payouts
*/
export class PayoutRequestIds {
    /**
    * List of bank account ids to search for
    */
    'BankAccountIds'?: Array<number>;
    /**
    * List of {Flipdish.PublicModels.V1.Payouts.PayoutStatus} so search for
    */
    'States'?: Array<PayoutRequestIds.StatesEnum>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "BankAccountIds",
            "baseName": "BankAccountIds",
            "type": "Array<number>"
        },
        {
            "name": "States",
            "baseName": "States",
            "type": "Array<PayoutRequestIds.StatesEnum>"
        }    ];

    static getAttributeTypeMap() {
        return PayoutRequestIds.attributeTypeMap;
    }
}

export namespace PayoutRequestIds {
    export enum StatesEnum {
        Pending = <any> 'Pending',
        InTransit = <any> 'InTransit',
        Paid = <any> 'Paid',
        Failed = <any> 'Failed',
        Cancelled = <any> 'Cancelled'
    }
}
/**
* Payout details for a single store
*/
export class PayoutStore {
    /**
    * The id of the Store.
    */
    'StoreId'?: number;
    /**
    * Name of the store
    */
    'StoreName'?: string;
    /**
    * Amount of the payout for this Store
    */
    'Amount'?: number;
    /**
    * Revenue details (DEPRECATED: Use Revenue)
    */
    'OnlineRevenue'?: RevenueDetail;
    /**
    * Revenue details
    */
    'Revenue'?: RevenueDetail;
    /**
    * Revenue Adjustments breakdown
    */
    'RevenueAdjustments'?: RevenueAdjustmentsDetails;
    /**
    * Fees breakdown
    */
    'FlipdishFees'?: FlipdishFeesDetails;
    /**
    * Chargebacks breakdown
    */
    'Chargebacks'?: ChargebackDetails;
    /**
    * Breakdown of other charges
    */
    'OtherCharges'?: OtherChargesDetails;
    /**
    * Period opening and closing balance
    */
    'Balance'?: BalanceDetails;
    /**
    * Breakdown of POS charges
    */
    'PosRevenue'?: PosRevenueDetails;
    /**
    * Third party integration fees
    */
    'ThirdPartyFees'?: ThirdPartyFeesDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreName",
            "baseName": "StoreName",
            "type": "string"
        },
        {
            "name": "Amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "OnlineRevenue",
            "baseName": "OnlineRevenue",
            "type": "RevenueDetail"
        },
        {
            "name": "Revenue",
            "baseName": "Revenue",
            "type": "RevenueDetail"
        },
        {
            "name": "RevenueAdjustments",
            "baseName": "RevenueAdjustments",
            "type": "RevenueAdjustmentsDetails"
        },
        {
            "name": "FlipdishFees",
            "baseName": "FlipdishFees",
            "type": "FlipdishFeesDetails"
        },
        {
            "name": "Chargebacks",
            "baseName": "Chargebacks",
            "type": "ChargebackDetails"
        },
        {
            "name": "OtherCharges",
            "baseName": "OtherCharges",
            "type": "OtherChargesDetails"
        },
        {
            "name": "Balance",
            "baseName": "Balance",
            "type": "BalanceDetails"
        },
        {
            "name": "PosRevenue",
            "baseName": "PosRevenue",
            "type": "PosRevenueDetails"
        },
        {
            "name": "ThirdPartyFees",
            "baseName": "ThirdPartyFees",
            "type": "ThirdPartyFeesDetails"
        }    ];

    static getAttributeTypeMap() {
        return PayoutStore.attributeTypeMap;
    }
}

/**
* Holds the information for a whitelabel payouts summary.
*/
export class PayoutSummary {
    /**
    * Status of the payout
    */
    'PayoutStatus'?: PayoutSummary.PayoutStatusEnum;
    /**
    * Total payouts amount
    */
    'TotalAmount'?: number;
    /**
    * Payout currency
    */
    'Currency'?: PayoutSummary.CurrencyEnum;
    /**
    * Total payouts count
    */
    'TotalCount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PayoutStatus",
            "baseName": "PayoutStatus",
            "type": "PayoutSummary.PayoutStatusEnum"
        },
        {
            "name": "TotalAmount",
            "baseName": "TotalAmount",
            "type": "number"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "PayoutSummary.CurrencyEnum"
        },
        {
            "name": "TotalCount",
            "baseName": "TotalCount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PayoutSummary.attributeTypeMap;
    }
}

export namespace PayoutSummary {
    export enum PayoutStatusEnum {
        Pending = <any> 'Pending',
        InTransit = <any> 'InTransit',
        Paid = <any> 'Paid',
        Failed = <any> 'Failed',
        Cancelled = <any> 'Cancelled'
    }
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Pending Menu Changes
*/
export class PendingMenuChanges {
    /**
    * Unique catalog item id
    */
    'CatalogItemId'?: string;
    /**
    * Unique menu id
    */
    'MenuId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CatalogItemId",
            "baseName": "CatalogItemId",
            "type": "string"
        },
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PendingMenuChanges.attributeTypeMap;
    }
}

/**
* Pending menu changes summaries
*/
export class PendingMenuChangesSummaries {
    /**
    * Menu id
    */
    'MenuId'?: number;
    /**
    * Sum of pending changes per menu id
    */
    'TotalPendingChanges'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "TotalPendingChanges",
            "baseName": "TotalPendingChanges",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PendingMenuChangesSummaries.attributeTypeMap;
    }
}

/**
* Percent discount details
*/
export class PercentDiscountDetails {
    /**
    * Percentage discount
    */
    'PercentageDiscount'?: number;
    /**
    * The maximum amount that the percentage discount value can be.  If not set then there is no maximum.  If set to e.g. 20 euro, and the percentage discount is 25%, and the order total is 100 euro, then the discount will be 20 euro (not 25 euro).
    */
    'MaxDiscountAmount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PercentageDiscount",
            "baseName": "PercentageDiscount",
            "type": "number"
        },
        {
            "name": "MaxDiscountAmount",
            "baseName": "MaxDiscountAmount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PercentDiscountDetails.attributeTypeMap;
    }
}

/**
* Phone call
*/
export class PhoneCall {
    /**
    * Phone call id
    */
    'PhoneCallId'?: number;
    /**
    * Time of the call
    */
    'TimeOfCall'?: Date;
    /**
    * Time of the call, local to the store to which the call was made
    */
    'TimeOfCallLocal'?: Date;
    /**
    * ID of the store that the call was TO
    */
    'StoreId'?: number;
    /**
    * Name of the store that the call was TO
    */
    'StoreName'?: string;
    /**
    * Name of the caller
    */
    'CallerName'?: string;
    /**
    * UserID of the caller
    */
    'CallerUserId'?: number;
    /**
    * Phone number of the caller
    */
    'CallerNumber'?: string;
    /**
    * The amount of time the call took
    */
    'CallLengthInSeconds'?: number;
    /**
    * The status of the call
    */
    'CallStatus'?: PhoneCall.CallStatusEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PhoneCallId",
            "baseName": "PhoneCallId",
            "type": "number"
        },
        {
            "name": "TimeOfCall",
            "baseName": "TimeOfCall",
            "type": "Date"
        },
        {
            "name": "TimeOfCallLocal",
            "baseName": "TimeOfCallLocal",
            "type": "Date"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreName",
            "baseName": "StoreName",
            "type": "string"
        },
        {
            "name": "CallerName",
            "baseName": "CallerName",
            "type": "string"
        },
        {
            "name": "CallerUserId",
            "baseName": "CallerUserId",
            "type": "number"
        },
        {
            "name": "CallerNumber",
            "baseName": "CallerNumber",
            "type": "string"
        },
        {
            "name": "CallLengthInSeconds",
            "baseName": "CallLengthInSeconds",
            "type": "number"
        },
        {
            "name": "CallStatus",
            "baseName": "CallStatus",
            "type": "PhoneCall.CallStatusEnum"
        }    ];

    static getAttributeTypeMap() {
        return PhoneCall.attributeTypeMap;
    }
}

export namespace PhoneCall {
    export enum CallStatusEnum {
        Queued = <any> 'Queued',
        Ringing = <any> 'Ringing',
        InProgress = <any> 'InProgress',
        Completed = <any> 'Completed',
        Failed = <any> 'Failed',
        Busy = <any> 'Busy',
        NoAnswer = <any> 'NoAnswer',
        Unknown = <any> 'Unknown',
        Canceled = <any> 'Canceled'
    }
}
/**
* Phone call ended event
*/
export class PhoneCallEndedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * The phone call
    */
    'PhoneCall'?: PhoneCall;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "PhoneCall",
            "baseName": "PhoneCall",
            "type": "PhoneCall"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PhoneCallEndedEvent.attributeTypeMap;
    }
}

/**
* Phone call started event
*/
export class PhoneCallStartedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * The phone call
    */
    'PhoneCall'?: PhoneCall;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "PhoneCall",
            "baseName": "PhoneCall",
            "type": "PhoneCall"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PhoneCallStartedEvent.attributeTypeMap;
    }
}

/**
* Breakdown of POS charges
*/
export class PosRevenueDetails {
    /**
    * POS sale amount for the store
    */
    'PosSalesAmount'?: number;
    /**
    * POS sale Tax for the store
    */
    'PosSalesTax'?: number;
    /**
    * POS sale tips for the store
    */
    'PosSalesTips'?: number;
    /**
    * POS Total Revenue for the store
    */
    'TotalPosRevenue'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PosSalesAmount",
            "baseName": "PosSalesAmount",
            "type": "number"
        },
        {
            "name": "PosSalesTax",
            "baseName": "PosSalesTax",
            "type": "number"
        },
        {
            "name": "PosSalesTips",
            "baseName": "PosSalesTips",
            "type": "number"
        },
        {
            "name": "TotalPosRevenue",
            "baseName": "TotalPosRevenue",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PosRevenueDetails.attributeTypeMap;
    }
}

/**
* Pre Order Config
*/
export class PreOrderConfig {
    /**
    * Lead Time in Minutes
    */
    'LeadTimeMinutes'?: number;
    /**
    * Interval in minutes
    */
    'IntervalMinutes'?: number;
    /**
    * Max Days to order ahead
    */
    'MaxOrderAheadDays'?: number;
    /**
    * Show ASAP as option
    */
    'IncludeAsap'?: boolean;
    /**
    * Granual Init' Time
    */
    'IncludeMoreGranularInitialTime'?: boolean;
    /**
    * Cut off time previous day
    */
    'CutOffTimePreviousDayBasic'?: string;
    /**
    * Cut off time current day
    */
    'CutOffTimeCurrentDayBasic'?: string;
    /**
    * Type of time displayed.
    */
    'PreOrderTimeDisplayType'?: PreOrderConfig.PreOrderTimeDisplayTypeEnum;
    /**
    * Specifies whether a customer can pre-order outside the store opening hours or not.
    */
    'AlwaysAppearOpen'?: boolean;
    /**
    * Force customer to select collection time.
    */
    'RequireExplicitSelectAlways'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LeadTimeMinutes",
            "baseName": "LeadTimeMinutes",
            "type": "number"
        },
        {
            "name": "IntervalMinutes",
            "baseName": "IntervalMinutes",
            "type": "number"
        },
        {
            "name": "MaxOrderAheadDays",
            "baseName": "MaxOrderAheadDays",
            "type": "number"
        },
        {
            "name": "IncludeAsap",
            "baseName": "IncludeAsap",
            "type": "boolean"
        },
        {
            "name": "IncludeMoreGranularInitialTime",
            "baseName": "IncludeMoreGranularInitialTime",
            "type": "boolean"
        },
        {
            "name": "CutOffTimePreviousDayBasic",
            "baseName": "CutOffTimePreviousDayBasic",
            "type": "string"
        },
        {
            "name": "CutOffTimeCurrentDayBasic",
            "baseName": "CutOffTimeCurrentDayBasic",
            "type": "string"
        },
        {
            "name": "PreOrderTimeDisplayType",
            "baseName": "PreOrderTimeDisplayType",
            "type": "PreOrderConfig.PreOrderTimeDisplayTypeEnum"
        },
        {
            "name": "AlwaysAppearOpen",
            "baseName": "AlwaysAppearOpen",
            "type": "boolean"
        },
        {
            "name": "RequireExplicitSelectAlways",
            "baseName": "RequireExplicitSelectAlways",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return PreOrderConfig.attributeTypeMap;
    }
}

export namespace PreOrderConfig {
    export enum PreOrderTimeDisplayTypeEnum {
        SingleTime = <any> 'SingleTime',
        StartAndEndTime = <any> 'StartAndEndTime',
        DayOnly = <any> 'DayOnly'
    }
}
/**
* Time order can be placed
*/
export class PreOrderTime {
    /**
    * Start Time
    */
    'StartTime'?: Date;
    /**
    * End Time
    */
    'EndTime'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StartTime",
            "baseName": "StartTime",
            "type": "Date"
        },
        {
            "name": "EndTime",
            "baseName": "EndTime",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return PreOrderTime.attributeTypeMap;
    }
}

/**
* Predefined answer
*/
export class PredefinedAnswer {
    /**
    * Identifier
    */
    'Id'?: number;
    /**
    * Text
    */
    'Text'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "Text",
            "baseName": "Text",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PredefinedAnswer.attributeTypeMap;
    }
}

export class PreviousOrder {
    'DeliveryType'?: string;
    'DeliveryLocationAddressString'?: string;
    'PaymentAccountType'?: string;
    'OrderId'?: number;
    'RestaurantName'?: string;
    'LocalOrderId'?: string;
    'TableServiceCategory'?: string;
    'PickupLocationOptionValue'?: string;
    'CustomerName'?: string;
    'PhoneNumberInternationalFormatString'?: string;
    'DeliveryInstructions'?: string;
    'Currency'?: PreviousOrder.CurrencyEnum;
    'ProcessingFee'?: number;
    'ServiceChargePercentage'?: number;
    'ServiceChargeAmount'?: number;
    'TipAmount'?: number;
    'DeliveryAmount'?: number;
    'DepositReturnFeeAmount'?: number;
    'TotalTax'?: number;
    'TotalAmount'?: number;
    'Items'?: Array<PreviousOrderItem>;
    'TaxRates'?: Array<TaxRate>;
    'WhiteLabelId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeliveryType",
            "baseName": "DeliveryType",
            "type": "string"
        },
        {
            "name": "DeliveryLocationAddressString",
            "baseName": "DeliveryLocationAddressString",
            "type": "string"
        },
        {
            "name": "PaymentAccountType",
            "baseName": "PaymentAccountType",
            "type": "string"
        },
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "RestaurantName",
            "baseName": "RestaurantName",
            "type": "string"
        },
        {
            "name": "LocalOrderId",
            "baseName": "LocalOrderId",
            "type": "string"
        },
        {
            "name": "TableServiceCategory",
            "baseName": "TableServiceCategory",
            "type": "string"
        },
        {
            "name": "PickupLocationOptionValue",
            "baseName": "PickupLocationOptionValue",
            "type": "string"
        },
        {
            "name": "CustomerName",
            "baseName": "CustomerName",
            "type": "string"
        },
        {
            "name": "PhoneNumberInternationalFormatString",
            "baseName": "PhoneNumberInternationalFormatString",
            "type": "string"
        },
        {
            "name": "DeliveryInstructions",
            "baseName": "DeliveryInstructions",
            "type": "string"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "PreviousOrder.CurrencyEnum"
        },
        {
            "name": "ProcessingFee",
            "baseName": "ProcessingFee",
            "type": "number"
        },
        {
            "name": "ServiceChargePercentage",
            "baseName": "ServiceChargePercentage",
            "type": "number"
        },
        {
            "name": "ServiceChargeAmount",
            "baseName": "ServiceChargeAmount",
            "type": "number"
        },
        {
            "name": "TipAmount",
            "baseName": "TipAmount",
            "type": "number"
        },
        {
            "name": "DeliveryAmount",
            "baseName": "DeliveryAmount",
            "type": "number"
        },
        {
            "name": "DepositReturnFeeAmount",
            "baseName": "DepositReturnFeeAmount",
            "type": "number"
        },
        {
            "name": "TotalTax",
            "baseName": "TotalTax",
            "type": "number"
        },
        {
            "name": "TotalAmount",
            "baseName": "TotalAmount",
            "type": "number"
        },
        {
            "name": "Items",
            "baseName": "Items",
            "type": "Array<PreviousOrderItem>"
        },
        {
            "name": "TaxRates",
            "baseName": "TaxRates",
            "type": "Array<TaxRate>"
        },
        {
            "name": "WhiteLabelId",
            "baseName": "WhiteLabelId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PreviousOrder.attributeTypeMap;
    }
}

export namespace PreviousOrder {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
export class PreviousOrderItem {
    'MenuSectionDisplayOrder'?: number;
    'MenuSectionName'?: string;
    'Name'?: string;
    'PriceIncludingOptionSetItems'?: number;
    'DepositReturnFee'?: number;
    'TaxAmount'?: number;
    'PreviousOrderItemOptions'?: Array<PreviousOrderItemOption>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MenuSectionDisplayOrder",
            "baseName": "MenuSectionDisplayOrder",
            "type": "number"
        },
        {
            "name": "MenuSectionName",
            "baseName": "MenuSectionName",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "PriceIncludingOptionSetItems",
            "baseName": "PriceIncludingOptionSetItems",
            "type": "number"
        },
        {
            "name": "DepositReturnFee",
            "baseName": "DepositReturnFee",
            "type": "number"
        },
        {
            "name": "TaxAmount",
            "baseName": "TaxAmount",
            "type": "number"
        },
        {
            "name": "PreviousOrderItemOptions",
            "baseName": "PreviousOrderItemOptions",
            "type": "Array<PreviousOrderItemOption>"
        }    ];

    static getAttributeTypeMap() {
        return PreviousOrderItem.attributeTypeMap;
    }
}

export class PreviousOrderItemOption {
    'Name'?: string;
    'DepositReturnFee'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "DepositReturnFee",
            "baseName": "DepositReturnFee",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PreviousOrderItemOption.attributeTypeMap;
    }
}

/**
* Defines a price
*/
export class Price {
    /**
    * Amount (including tax)
    */
    'Amount'?: number;
    /**
    * Tax (only required in tax exclusive prices)
    */
    'Tax'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "Tax",
            "baseName": "Tax",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Price.attributeTypeMap;
    }
}

/**
* Printer
*/
export class Printer {
    /**
    * Unique serial number of the printer
    */
    'SerialNumber'?: string;
    /**
    * Date and time when the printer last polled Flipdish for new orders.
    */
    'LastPollTime'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "SerialNumber",
            "baseName": "SerialNumber",
            "type": "string"
        },
        {
            "name": "LastPollTime",
            "baseName": "LastPollTime",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return Printer.attributeTypeMap;
    }
}

/**
* Printer assigned to store event
*/
export class PrinterAssignedToStoreEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The printer
    */
    'Printer'?: Printer;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Printer",
            "baseName": "Printer",
            "type": "Printer"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PrinterAssignedToStoreEvent.attributeTypeMap;
    }
}

/**
* Printer turned off event
*/
export class PrinterTurnedOffEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The printer
    */
    'Printer'?: Printer;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Printer",
            "baseName": "Printer",
            "type": "Printer"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PrinterTurnedOffEvent.attributeTypeMap;
    }
}

/**
* Printer turned on event
*/
export class PrinterTurnedOnEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The printer
    */
    'Printer'?: Printer;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Printer",
            "baseName": "Printer",
            "type": "Printer"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PrinterTurnedOnEvent.attributeTypeMap;
    }
}

/**
* Printer assigned from store event
*/
export class PrinterUnassignedFromStoreEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The printer
    */
    'Printer'?: Printer;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Printer",
            "baseName": "Printer",
            "type": "Printer"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PrinterUnassignedFromStoreEvent.attributeTypeMap;
    }
}

/**
* Initiate card reader Payment process request
*/
export class ProcessPaymentIntentRequest {
    /**
    * Device card paymentIntentId
    */
    'PaymentIntentId': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PaymentIntentId",
            "baseName": "PaymentIntentId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ProcessPaymentIntentRequest.attributeTypeMap;
    }
}

/**
* Processing fee config
*/
export class ProcessingFeeConfig {
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Payment account type
    */
    'PaymentAccountType'?: ProcessingFeeConfig.PaymentAccountTypeEnum;
    /**
    * Percent fee to customer, including VAT
    */
    'PercentFee'?: number;
    /**
    * Fixed fee to customer, including VAT
    */
    'FixedFee'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "PaymentAccountType",
            "baseName": "PaymentAccountType",
            "type": "ProcessingFeeConfig.PaymentAccountTypeEnum"
        },
        {
            "name": "PercentFee",
            "baseName": "PercentFee",
            "type": "number"
        },
        {
            "name": "FixedFee",
            "baseName": "FixedFee",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ProcessingFeeConfig.attributeTypeMap;
    }
}

export namespace ProcessingFeeConfig {
    export enum PaymentAccountTypeEnum {
        Card = <any> 'Card',
        Cash = <any> 'Cash',
        Ideal = <any> 'Ideal',
        Bancontact = <any> 'Bancontact',
        Giropay = <any> 'Giropay',
        Eps = <any> 'Eps',
        Emv = <any> 'Emv',
        PayPal = <any> 'PayPal',
        PayGreen = <any> 'PayGreen',
        GoogleWalletToken = <any> 'GoogleWalletToken'
    }
}
/**
* Product
*/
export class Product {
    /**
    * Unique catalog Item id
    */
    'CatalogItemId'?: string;
    /**
    * Returns true if the item is archived
    */
    'IsArchived'?: boolean;
    /**
    * Collection of groups associated with this item
    */
    'Groups'?: Array<GroupReference>;
    /**
    * Collection of metafields
    */
    'Metafields'?: Array<Metafield>;
    /**
    * Type of item (Product, Modifier, etc)
    */
    'ProductType': Product.ProductTypeEnum;
    /**
    * Stock Keeping Unit (SKU)
    */
    'Sku': string;
    /**
    * Product name
    */
    'Name': string;
    /**
    * Product description
    */
    'Description'?: string;
    /**
    * Product price
    */
    'Price': number;
    /**
    * Image File Name
    */
    'ImageFileName'?: string;
    /**
    * Product contains alcohol
    */
    'Alcohol'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CatalogItemId",
            "baseName": "CatalogItemId",
            "type": "string"
        },
        {
            "name": "IsArchived",
            "baseName": "IsArchived",
            "type": "boolean"
        },
        {
            "name": "Groups",
            "baseName": "Groups",
            "type": "Array<GroupReference>"
        },
        {
            "name": "Metafields",
            "baseName": "Metafields",
            "type": "Array<Metafield>"
        },
        {
            "name": "ProductType",
            "baseName": "ProductType",
            "type": "Product.ProductTypeEnum"
        },
        {
            "name": "Sku",
            "baseName": "Sku",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "ImageFileName",
            "baseName": "ImageFileName",
            "type": "string"
        },
        {
            "name": "Alcohol",
            "baseName": "Alcohol",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Product.attributeTypeMap;
    }
}

export namespace Product {
    export enum ProductTypeEnum {
        Product = <any> 'Product',
        Modifier = <any> 'Modifier'
    }
}
/**
* Catalog Item associated
*/
export class ProductReference {
    /**
    * Details of the referenced {Flipdish.Menus.PublicModels.V1.Catalog.Groups.ProductReference.Product}
    */
    'Item'?: Product;
    /**
    * Details of the referenced {Flipdish.Menus.PublicModels.V1.Catalog.Groups.ProductReference.Product}
    */
    'Product'?: Product;
    /**
    * Identifier of the CatalogItemId to use as SubProduct
    */
    'CatalogItemId': string;
    /**
    * Type of the SupProduct
    */
    'ProductType': ProductReference.ProductTypeEnum;
    /**
    * Quantity of the modifier that will be set when the parent product is placed in the basket
    */
    'PreselectedQuantity'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Item",
            "baseName": "Item",
            "type": "Product"
        },
        {
            "name": "Product",
            "baseName": "Product",
            "type": "Product"
        },
        {
            "name": "CatalogItemId",
            "baseName": "CatalogItemId",
            "type": "string"
        },
        {
            "name": "ProductType",
            "baseName": "ProductType",
            "type": "ProductReference.ProductTypeEnum"
        },
        {
            "name": "PreselectedQuantity",
            "baseName": "PreselectedQuantity",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ProductReference.attributeTypeMap;
    }
}

export namespace ProductReference {
    export enum ProductTypeEnum {
        Product = <any> 'Product',
        Modifier = <any> 'Modifier'
    }
}
/**
* Promotion
*/
export class PromotionAward {
    /**
    * Promotion Award Id
    */
    'PromotionAwardId'?: number;
    /**
    * The public id of the menu item that will be awarded
    */
    'MenuItemPublicId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PromotionAwardId",
            "baseName": "PromotionAwardId",
            "type": "number"
        },
        {
            "name": "MenuItemPublicId",
            "baseName": "MenuItemPublicId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PromotionAward.attributeTypeMap;
    }
}

/**
* Promotion
*/
export class PromotionDetails {
    /**
    * Promotion Id
    */
    'PromotionId'?: number;
    /**
    * The name of the promotion
    */
    'Name'?: string;
    /**
    * The items that this promotion will award
    */
    'PromotionAwards'?: Array<PromotionAward>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PromotionId",
            "baseName": "PromotionId",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "PromotionAwards",
            "baseName": "PromotionAwards",
            "type": "Array<PromotionAward>"
        }    ];

    static getAttributeTypeMap() {
        return PromotionDetails.attributeTypeMap;
    }
}

/**
* Publish Menu Changes
*/
export class PublishMenuChanges {
    /**
    * Optional Catalog item id
    */
    'CatalogItemId'?: string;
    /**
    * Optional Collection of Menu id
    */
    'MenuIds'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CatalogItemId",
            "baseName": "CatalogItemId",
            "type": "string"
        },
        {
            "name": "MenuIds",
            "baseName": "MenuIds",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return PublishMenuChanges.attributeTypeMap;
    }
}

/**
* 
*/
export class PushNotificationDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * 
    */
    'Description'?: string;
    /**
    * 
    */
    'PushNotification'?: PushNotificationRequest;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "PushNotification",
            "baseName": "PushNotification",
            "type": "PushNotificationRequest"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PushNotificationDeletedEvent.attributeTypeMap;
    }
}

/**
* Push Notification Details
*/
export class PushNotificationRequest {
    /**
    * UTC Time at which to send the push notification
    */
    'ScheduledTime'?: Date;
    /**
    * Title of the notification
    */
    'Title'?: string;
    /**
    * Message of the notification
    */
    'Message': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ScheduledTime",
            "baseName": "ScheduledTime",
            "type": "Date"
        },
        {
            "name": "Title",
            "baseName": "Title",
            "type": "string"
        },
        {
            "name": "Message",
            "baseName": "Message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PushNotificationRequest.attributeTypeMap;
    }
}

/**
* Push Notification
*/
export class PushNotificationResponse {
    /**
    * Sent
    */
    'Sent'?: boolean;
    /**
    * Push notification identifier
    */
    'ScheduledPushNotificationId'?: number;
    /**
    * UTC Time at which to send the push notification
    */
    'ScheduledTime'?: Date;
    /**
    * Title of the notification
    */
    'Title'?: string;
    /**
    * Message of the notification
    */
    'Message': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Sent",
            "baseName": "Sent",
            "type": "boolean"
        },
        {
            "name": "ScheduledPushNotificationId",
            "baseName": "ScheduledPushNotificationId",
            "type": "number"
        },
        {
            "name": "ScheduledTime",
            "baseName": "ScheduledTime",
            "type": "Date"
        },
        {
            "name": "Title",
            "baseName": "Title",
            "type": "string"
        },
        {
            "name": "Message",
            "baseName": "Message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PushNotificationResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class PushNotificationScheduledEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * 
    */
    'User'?: UserEventInfo;
    /**
    * 
    */
    'Description'?: string;
    /**
    * 
    */
    'PushNotification'?: PushNotificationRequest;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "PushNotification",
            "baseName": "PushNotification",
            "type": "PushNotificationRequest"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PushNotificationScheduledEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class PushNotificationSentEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * 
    */
    'PushNotification'?: PushNotificationRequest;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "PushNotification",
            "baseName": "PushNotification",
            "type": "PushNotificationRequest"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PushNotificationSentEvent.attributeTypeMap;
    }
}

/**
* A class that represents a single opening period in a day.  This starts 'StartTime' after midnight and runs for a 'Period'  after that, on the given DayOfWeek.
*/
export class Range {
    /**
    * Start time
    */
    'StartTime'?: string;
    /**
    * Period
    */
    'Period'?: string;
    /**
    * Day of week
    */
    'DayOfWeek'?: Range.DayOfWeekEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StartTime",
            "baseName": "StartTime",
            "type": "string"
        },
        {
            "name": "Period",
            "baseName": "Period",
            "type": "string"
        },
        {
            "name": "DayOfWeek",
            "baseName": "DayOfWeek",
            "type": "Range.DayOfWeekEnum"
        }    ];

    static getAttributeTypeMap() {
        return Range.attributeTypeMap;
    }
}

export namespace Range {
    export enum DayOfWeekEnum {
        Sunday = <any> 'Sunday',
        Monday = <any> 'Monday',
        Tuesday = <any> 'Tuesday',
        Wednesday = <any> 'Wednesday',
        Thursday = <any> 'Thursday',
        Friday = <any> 'Friday',
        Saturday = <any> 'Saturday'
    }
}
/**
* Card reader state information
*/
export class ReaderActionStateInfo {
    /**
    * Action state
    */
    'ActionState'?: string;
    /**
    * Failure code
    */
    'FailureCode'?: string;
    /**
    * Failure Message
    */
    'FailureMessage'?: string;
    /**
    * Type
    */
    'Type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ActionState",
            "baseName": "ActionState",
            "type": "string"
        },
        {
            "name": "FailureCode",
            "baseName": "FailureCode",
            "type": "string"
        },
        {
            "name": "FailureMessage",
            "baseName": "FailureMessage",
            "type": "string"
        },
        {
            "name": "Type",
            "baseName": "Type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ReaderActionStateInfo.attributeTypeMap;
    }
}

/**
* 
*/
export class RedeemInvitationResult {
    /**
    * Access level is for this App
    */
    'AppId'?: string;
    /**
    * Invitation status
    */
    'InvitationStatus'?: RedeemInvitationResult.InvitationStatusEnum;
    /**
    * Bool indicating if the user that redeemed the invitation is a new user
    */
    'IsNewUser'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "InvitationStatus",
            "baseName": "InvitationStatus",
            "type": "RedeemInvitationResult.InvitationStatusEnum"
        },
        {
            "name": "IsNewUser",
            "baseName": "IsNewUser",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return RedeemInvitationResult.attributeTypeMap;
    }
}

export namespace RedeemInvitationResult {
    export enum InvitationStatusEnum {
        Pending = <any> 'Pending',
        Accepted = <any> 'Accepted',
        Expired = <any> 'Expired'
    }
}
/**
* Refund
*/
export class Refund {
    /**
    * Refund reason
    */
    'RefundReason'?: string;
    /**
    * Refund amount
    */
    'RefundAmount': number;
    /**
    * If true, the system sends notification to the customer about the refund
    */
    'NotifyCustomer': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "RefundReason",
            "baseName": "RefundReason",
            "type": "string"
        },
        {
            "name": "RefundAmount",
            "baseName": "RefundAmount",
            "type": "number"
        },
        {
            "name": "NotifyCustomer",
            "baseName": "NotifyCustomer",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Refund.attributeTypeMap;
    }
}

/**
* Reject
*/
export class Reject {
    /**
    * Reject reason.
    */
    'RejectReason': Reject.RejectReasonEnum;
    /**
    * Notify customer. The server will not send and SMS to the customer if the value is true.
    */
    'DoNotNotifyCustomer'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "RejectReason",
            "baseName": "RejectReason",
            "type": "Reject.RejectReasonEnum"
        },
        {
            "name": "DoNotNotifyCustomer",
            "baseName": "DoNotNotifyCustomer",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Reject.attributeTypeMap;
    }
}

export namespace Reject {
    export enum RejectReasonEnum {
        TooBusy = <any> 'TooBusy',
        FoodUnavailable = <any> 'FoodUnavailable',
        UnableToDeliver = <any> 'UnableToDeliver',
        UnknownAddress = <any> 'UnknownAddress',
        UnknownReason = <any> 'UnknownReason',
        TooSoon = <any> 'TooSoon',
        TimeUnavailable = <any> 'TimeUnavailable',
        DontDeliverToArea = <any> 'DontDeliverToArea',
        StoreUncontactable = <any> 'StoreUncontactable'
    }
}
/**
* Request login PIN response
*/
export class RequestLoginPinModel {
    /**
    * Email address
    */
    'Email': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RequestLoginPinModel.attributeTypeMap;
    }
}

/**
* Request login PIN response
*/
export class RequestLoginPinResponse {
    /**
    * Login PIN sent via email to user
    */
    'LoginPinSentViaEmail'?: boolean;
    /**
    * All flipdishers must login via Okta
    */
    'ForceOktaLogin'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LoginPinSentViaEmail",
            "baseName": "LoginPinSentViaEmail",
            "type": "boolean"
        },
        {
            "name": "ForceOktaLogin",
            "baseName": "ForceOktaLogin",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return RequestLoginPinResponse.attributeTypeMap;
    }
}

/**
* 
*/
export class RequestPasswordResetModel {
    /**
    * Email address
    */
    'Email'?: string;
    /**
    * Google Recaptcha Token
    */
    'RecaptchaToken'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "RecaptchaToken",
            "baseName": "RecaptchaToken",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RequestPasswordResetModel.attributeTypeMap;
    }
}

/**
* Request Password Reset PIN response
*/
export class RequestPasswordResetPinResponse {
    /**
    * Password Reset PIN sent via email to user
    */
    'PasswordResetPinSentViaEmail'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PasswordResetPinSentViaEmail",
            "baseName": "PasswordResetPinSentViaEmail",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return RequestPasswordResetPinResponse.attributeTypeMap;
    }
}

export class Response {
    'Stores'?: Array<StoreItemHeader>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Stores",
            "baseName": "Stores",
            "type": "Array<StoreItemHeader>"
        }    ];

    static getAttributeTypeMap() {
        return Response.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultAllMetadataResult {
    /**
    * Generic data object.
    */
    'Data': Array<AllMetadataResult>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<AllMetadataResult>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultAllMetadataResult.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultAllergen {
    /**
    * Generic data object.
    */
    'Data': Array<Allergen>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<Allergen>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultAllergen.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultApmCurrencyDataPoint {
    /**
    * Generic data object.
    */
    'Data': Array<ApmCurrencyDataPoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<ApmCurrencyDataPoint>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultApmCurrencyDataPoint.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultApmDataPoint {
    /**
    * Generic data object.
    */
    'Data': Array<ApmDataPoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<ApmDataPoint>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultApmDataPoint.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultApmHourlyDataPoint {
    /**
    * Generic data object.
    */
    'Data': Array<ApmHourlyDataPoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<ApmHourlyDataPoint>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultApmHourlyDataPoint.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultAppStoreAppConfigurationSummary {
    /**
    * Generic data object.
    */
    'Data': Array<AppStoreAppConfigurationSummary>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<AppStoreAppConfigurationSummary>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultAppStoreAppConfigurationSummary.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultAppStoreAppSummary {
    /**
    * Generic data object.
    */
    'Data': Array<AppStoreAppSummary>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<AppStoreAppSummary>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultAppStoreAppSummary.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultBankAccountSummary {
    /**
    * Generic data object.
    */
    'Data': Array<BankAccountSummary>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<BankAccountSummary>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultBankAccountSummary.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultBusinessHoursPeriod {
    /**
    * Generic data object.
    */
    'Data': Array<BusinessHoursPeriod>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<BusinessHoursPeriod>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultBusinessHoursPeriod.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultChannel {
    /**
    * Generic data object.
    */
    'Data': Array<Channel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<Channel>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultChannel.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultClientDeviceSummary {
    /**
    * Generic data object.
    */
    'Data': Array<ClientDeviceSummary>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<ClientDeviceSummary>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultClientDeviceSummary.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultCountryWithAccountFieldsDefinitions {
    /**
    * Generic data object.
    */
    'Data': Array<CountryWithAccountFieldsDefinitions>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<CountryWithAccountFieldsDefinitions>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultCountryWithAccountFieldsDefinitions.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultDeliveryZone {
    /**
    * Generic data object.
    */
    'Data': Array<DeliveryZone>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<DeliveryZone>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultDeliveryZone.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultEmvTerminalWithAssignments {
    /**
    * Generic data object.
    */
    'Data': Array<EmvTerminalWithAssignments>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<EmvTerminalWithAssignments>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultEmvTerminalWithAssignments.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultFulfillmentStatesConfigurationSummary {
    /**
    * Generic data object.
    */
    'Data': Array<FulfillmentStatesConfigurationSummary>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<FulfillmentStatesConfigurationSummary>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultFulfillmentStatesConfigurationSummary.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultHomeAction {
    /**
    * Generic data object.
    */
    'Data': Array<HomeAction>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<HomeAction>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultHomeAction.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultKioskCashPaymentSettings {
    /**
    * Generic data object.
    */
    'Data': Array<KioskCashPaymentSettings>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<KioskCashPaymentSettings>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultKioskCashPaymentSettings.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultLocalisedTimeZone {
    /**
    * Generic data object.
    */
    'Data': Array<LocalisedTimeZone>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<LocalisedTimeZone>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultLocalisedTimeZone.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultLocationAreaLocation {
    /**
    * Generic data object.
    */
    'Data': Array<LocationAreaLocation>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<LocationAreaLocation>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultLocationAreaLocation.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultLocationAreaWithLocations {
    /**
    * Generic data object.
    */
    'Data': Array<LocationAreaWithLocations>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<LocationAreaWithLocations>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultLocationAreaWithLocations.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultLoyaltyCampaign {
    /**
    * Generic data object.
    */
    'Data': Array<LoyaltyCampaign>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<LoyaltyCampaign>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultLoyaltyCampaign.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuCheckpoint {
    /**
    * Generic data object.
    */
    'Data': Array<MenuCheckpoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MenuCheckpoint>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuCheckpoint.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuElementEditResponse {
    /**
    * Generic data object.
    */
    'Data': Array<MenuElementEditResponse>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MenuElementEditResponse>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuElementEditResponse.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuElementListResponse {
    /**
    * Generic data object.
    */
    'Data': Array<MenuElementListResponse>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MenuElementListResponse>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuElementListResponse.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuItemOptionSet {
    /**
    * Generic data object.
    */
    'Data': Array<MenuItemOptionSet>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MenuItemOptionSet>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuItemOptionSet.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuItemOptionSetItem {
    /**
    * Generic data object.
    */
    'Data': Array<MenuItemOptionSetItem>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MenuItemOptionSetItem>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuItemOptionSetItem.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuSection {
    /**
    * Generic data object.
    */
    'Data': Array<MenuSection>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MenuSection>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuSection.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuSectionItem {
    /**
    * Generic data object.
    */
    'Data': Array<MenuSectionItem>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MenuSectionItem>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuSectionItem.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuStoreNames {
    /**
    * Generic data object.
    */
    'Data': Array<MenuStoreNames>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MenuStoreNames>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuStoreNames.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuSummary {
    /**
    * Generic data object.
    */
    'Data': Array<MenuSummary>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MenuSummary>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuSummary.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuTaxDetails {
    /**
    * Generic data object.
    */
    'Data': Array<MenuTaxDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MenuTaxDetails>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuTaxDetails.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMenuZone {
    /**
    * Generic data object.
    */
    'Data': Array<MenuZone>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MenuZone>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMenuZone.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMetadata {
    /**
    * Generic data object.
    */
    'Data': Array<Metadata>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<Metadata>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMetadata.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultMobileAppsStatistics {
    /**
    * Generic data object.
    */
    'Data': Array<MobileAppsStatistics>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MobileAppsStatistics>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultMobileAppsStatistics.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultOAuthApp {
    /**
    * Generic data object.
    */
    'Data': Array<OAuthApp>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<OAuthApp>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultOAuthApp.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultOauthClientRedirectUri {
    /**
    * Generic data object.
    */
    'Data': Array<OauthClientRedirectUri>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<OauthClientRedirectUri>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultOauthClientRedirectUri.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultOrderBatch {
    /**
    * Generic data object.
    */
    'Data': Array<OrderBatch>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<OrderBatch>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultOrderBatch.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultOrderFulfillmentStatus {
    /**
    * Generic data object.
    */
    'Data': Array<OrderFulfillmentStatus>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<OrderFulfillmentStatus>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultOrderFulfillmentStatus.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultPayoutSummary {
    /**
    * Generic data object.
    */
    'Data': Array<PayoutSummary>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<PayoutSummary>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultPayoutSummary.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultPendingMenuChangesSummaries {
    /**
    * Generic data object.
    */
    'Data': Array<PendingMenuChangesSummaries>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<PendingMenuChangesSummaries>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultPendingMenuChangesSummaries.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultPreOrderTime {
    /**
    * Generic data object.
    */
    'Data': Array<PreOrderTime>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<PreOrderTime>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultPreOrderTime.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultProcessingFeeConfig {
    /**
    * Generic data object.
    */
    'Data': Array<ProcessingFeeConfig>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<ProcessingFeeConfig>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultProcessingFeeConfig.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultRestApiDefaultResponse {
    /**
    * Generic data object.
    */
    'Data': Array<RestApiDefaultResponse>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<RestApiDefaultResponse>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultRestApiDefaultResponse.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultRestaurantVoucherEligibleStore {
    /**
    * Generic data object.
    */
    'Data': Array<RestaurantVoucherEligibleStore>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<RestaurantVoucherEligibleStore>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultRestaurantVoucherEligibleStore.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultRestaurantVoucherPayGreenConfiguration {
    /**
    * Generic data object.
    */
    'Data': Array<RestaurantVoucherPayGreenConfiguration>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<RestaurantVoucherPayGreenConfiguration>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultRestaurantVoucherPayGreenConfiguration.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultRestaurantVoucherPayGreenConfigurationSummary {
    /**
    * Generic data object.
    */
    'Data': Array<RestaurantVoucherPayGreenConfigurationSummary>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<RestaurantVoucherPayGreenConfigurationSummary>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultRestaurantVoucherPayGreenConfigurationSummary.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultRetentionCampaign {
    /**
    * Generic data object.
    */
    'Data': Array<RetentionCampaign>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<RetentionCampaign>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultRetentionCampaign.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultStoreChannelAssignment {
    /**
    * Generic data object.
    */
    'Data': Array<StoreChannelAssignment>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<StoreChannelAssignment>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultStoreChannelAssignment.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultStoreChannelStoreMapping {
    /**
    * Generic data object.
    */
    'Data': Array<StoreChannelStoreMapping>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<StoreChannelStoreMapping>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultStoreChannelStoreMapping.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultStoreDeliveryZoneFeeConfig {
    /**
    * Generic data object.
    */
    'Data': Array<StoreDeliveryZoneFeeConfig>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<StoreDeliveryZoneFeeConfig>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultStoreDeliveryZoneFeeConfig.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultStoreListItem {
    /**
    * Generic data object.
    */
    'Data': Array<StoreListItem>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<StoreListItem>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultStoreListItem.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultStoreStatistics {
    /**
    * Generic data object.
    */
    'Data': Array<StoreStatistics>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<StoreStatistics>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultStoreStatistics.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultStripeCustomConnectedAccount {
    /**
    * Generic data object.
    */
    'Data': Array<StripeCustomConnectedAccount>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<StripeCustomConnectedAccount>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultStripeCustomConnectedAccount.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultSubscriptionSummary {
    /**
    * Generic data object.
    */
    'Data': Array<SubscriptionSummary>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<SubscriptionSummary>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultSubscriptionSummary.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultSupportedCountry {
    /**
    * Generic data object.
    */
    'Data': Array<SupportedCountry>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<SupportedCountry>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultSupportedCountry.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultTeammate {
    /**
    * Generic data object.
    */
    'Data': Array<Teammate>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<Teammate>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultTeammate.attributeTypeMap;
    }
}

/**
* Rest api array result
*/
export class RestApiArrayResultVoucherDataPoint {
    /**
    * Generic data object.
    */
    'Data': Array<VoucherDataPoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<VoucherDataPoint>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiArrayResultVoucherDataPoint.attributeTypeMap;
    }
}

/**
* Rest api default response
*/
export class RestApiDefaultResponse {
    /**
    * Data string
    */
    'Data'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RestApiDefaultResponse.attributeTypeMap;
    }
}

/**
* Rest api error result
*/
export class RestApiErrorResult {
    /**
    * Error message
    */
    'Message': string;
    /**
    * Error code
    */
    'ErrorCode'?: number;
    /**
    * Stack trace
    */
    'StackTrace'?: string;
    /**
    * List of errors grouped by field name
    */
    'Errors'?: Array<ValidationErrorResult>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Message",
            "baseName": "Message",
            "type": "string"
        },
        {
            "name": "ErrorCode",
            "baseName": "ErrorCode",
            "type": "number"
        },
        {
            "name": "StackTrace",
            "baseName": "StackTrace",
            "type": "string"
        },
        {
            "name": "Errors",
            "baseName": "Errors",
            "type": "Array<ValidationErrorResult>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiErrorResult.attributeTypeMap;
    }
}

/**
* 
*/
export class RestApiEventSearchPaginationResult {
    /**
    * Event results
    */
    'Data': EventSearchResult;
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "EventSearchResult"
        },
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RestApiEventSearchPaginationResult.attributeTypeMap;
    }
}

/**
* Rest api finance search pagination result
*/
export class RestApiFinanceSearchPaginationResultInvoice {
    /**
    * Next page
    */
    'NextPage': string;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<Invoice>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "NextPage",
            "baseName": "NextPage",
            "type": "string"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<Invoice>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiFinanceSearchPaginationResultInvoice.attributeTypeMap;
    }
}

/**
* Rest Api Forbidden Result
*/
export class RestApiForbiddenResult {
    /**
    * Message
    */
    'Message': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Message",
            "baseName": "Message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RestApiForbiddenResult.attributeTypeMap;
    }
}

/**
* Rest api integer result
*/
export class RestApiIntegerResult {
    /**
    * Data integer
    */
    'Data': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RestApiIntegerResult.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultApp {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<App>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<App>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultApp.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultAppStoreAppSummary {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<AppStoreAppSummary>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<AppStoreAppSummary>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultAppStoreAppSummary.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultBusinessHoursOverride {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<BusinessHoursOverride>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<BusinessHoursOverride>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultBusinessHoursOverride.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultCatalogItem {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<CatalogItem>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<CatalogItem>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultCatalogItem.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultGroup {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<Group>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<Group>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultGroup.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultHttpRequestAndResponseLog {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<HttpRequestAndResponseLog>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<HttpRequestAndResponseLog>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultHttpRequestAndResponseLog.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultHydraDeviceDetails {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<HydraDeviceDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<HydraDeviceDetails>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultHydraDeviceDetails.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultMetafieldDefinition {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<MetafieldDefinition>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MetafieldDefinition>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultMetafieldDefinition.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultMetafieldDefinitionRecommendation {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<MetafieldDefinitionRecommendation>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<MetafieldDefinitionRecommendation>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultMetafieldDefinitionRecommendation.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultOAuthTokenModel {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<OAuthTokenModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<OAuthTokenModel>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultOAuthTokenModel.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultOrder {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<Order>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<Order>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultOrder.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultOrderSummary {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<OrderSummary>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<OrderSummary>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultOrderSummary.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultPayout {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<Payout>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<Payout>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultPayout.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultPayoutChargeback {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<PayoutChargeback>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<PayoutChargeback>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultPayoutChargeback.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultPayoutOrder {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<PayoutOrder>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<PayoutOrder>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultPayoutOrder.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultPayoutOtherCharge {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<PayoutOtherCharge>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<PayoutOtherCharge>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultPayoutOtherCharge.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultPayoutRefund {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<PayoutRefund>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<PayoutRefund>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultPayoutRefund.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultPayoutReport3PayoutOrder {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<PayoutReport3PayoutOrder>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<PayoutReport3PayoutOrder>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultPayoutReport3PayoutOrder.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultPendingMenuChanges {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<PendingMenuChanges>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<PendingMenuChanges>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultPendingMenuChanges.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultPhoneCall {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<PhoneCall>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<PhoneCall>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultPhoneCall.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultProduct {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<Product>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<Product>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultProduct.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultPushNotificationResponse {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<PushNotificationResponse>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<PushNotificationResponse>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultPushNotificationResponse.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultStore {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<Store>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<Store>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultStore.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultStoreGroup {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<StoreGroup>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<StoreGroup>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultStoreGroup.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultStoreGroupExtended {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<StoreGroupExtended>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<StoreGroupExtended>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultStoreGroupExtended.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultStoreHeader {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<StoreHeader>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<StoreHeader>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultStoreHeader.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultStoreValidationConfig {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<StoreValidationConfig>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<StoreValidationConfig>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultStoreValidationConfig.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultVoucherSummary {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<VoucherSummary>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<VoucherSummary>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultVoucherSummary.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultWebhookLog {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<WebhookLog>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<WebhookLog>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultWebhookLog.attributeTypeMap;
    }
}

/**
* Rest api pagination result
*/
export class RestApiPaginationResultWebhookSubscription {
    /**
    * Current page index
    */
    'Page': number;
    /**
    * Current page size
    */
    'Limit': number;
    /**
    * Total record count
    */
    'TotalRecordCount': number;
    /**
    * Generic data object.
    */
    'Data': Array<WebhookSubscription>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "TotalRecordCount",
            "baseName": "TotalRecordCount",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<WebhookSubscription>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiPaginationResultWebhookSubscription.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultAccountDetail {
    /**
    * Generic data object.
    */
    'Data': AccountDetail;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "AccountDetail"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultAccountDetail.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultAccountFieldsDefinitions {
    /**
    * Generic data object.
    */
    'Data': AccountFieldsDefinitions;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "AccountFieldsDefinitions"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultAccountFieldsDefinitions.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultAddressFormResponse {
    /**
    * Generic data object.
    */
    'Data': AddressFormResponse;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "AddressFormResponse"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultAddressFormResponse.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultApmStatistics {
    /**
    * Generic data object.
    */
    'Data': ApmStatistics;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "ApmStatistics"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultApmStatistics.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultApmStatus {
    /**
    * Generic data object.
    */
    'Data': ApmStatus;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "ApmStatus"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultApmStatus.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultApp {
    /**
    * Generic data object.
    */
    'Data': App;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "App"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultApp.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultAppChannelAssignment {
    /**
    * Generic data object.
    */
    'Data': AppChannelAssignment;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "AppChannelAssignment"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultAppChannelAssignment.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultAppCompliance {
    /**
    * Generic data object.
    */
    'Data': AppCompliance;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "AppCompliance"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultAppCompliance.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultAppConfigSalesChannel {
    /**
    * Generic data object.
    */
    'Data': AppConfigSalesChannel;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "AppConfigSalesChannel"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultAppConfigSalesChannel.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultAppStoreApp {
    /**
    * Generic data object.
    */
    'Data': AppStoreApp;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "AppStoreApp"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultAppStoreApp.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultAppStoreAppConfiguration {
    /**
    * Generic data object.
    */
    'Data': AppStoreAppConfiguration;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "AppStoreAppConfiguration"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultAppStoreAppConfiguration.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultAppStoreAppConfigurationsWithSubscriptions {
    /**
    * Generic data object.
    */
    'Data': AppStoreAppConfigurationsWithSubscriptions;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "AppStoreAppConfigurationsWithSubscriptions"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultAppStoreAppConfigurationsWithSubscriptions.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultAppStoreAppEntitlements {
    /**
    * Generic data object.
    */
    'Data': AppStoreAppEntitlements;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "AppStoreAppEntitlements"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultAppStoreAppEntitlements.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultAssignedBankAccount {
    /**
    * Generic data object.
    */
    'Data': AssignedBankAccount;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "AssignedBankAccount"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultAssignedBankAccount.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultBankAccountDetail {
    /**
    * Generic data object.
    */
    'Data': BankAccountDetail;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "BankAccountDetail"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultBankAccountDetail.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultBluetoothTerminalStatus {
    /**
    * Generic data object.
    */
    'Data': BluetoothTerminalStatus;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "BluetoothTerminalStatus"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultBluetoothTerminalStatus.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultBusinessHoursOverride {
    /**
    * Generic data object.
    */
    'Data': BusinessHoursOverride;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "BusinessHoursOverride"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultBusinessHoursOverride.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultBusinessHoursPeriod {
    /**
    * Generic data object.
    */
    'Data': BusinessHoursPeriod;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "BusinessHoursPeriod"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultBusinessHoursPeriod.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultCardReader {
    /**
    * Generic data object.
    */
    'Data': CardReader;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "CardReader"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultCardReader.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultCatalogItem {
    /**
    * Generic data object.
    */
    'Data': CatalogItem;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "CatalogItem"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultCatalogItem.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultChannel {
    /**
    * Generic data object.
    */
    'Data': Channel;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Channel"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultChannel.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultClientDevice {
    /**
    * Generic data object.
    */
    'Data': ClientDevice;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "ClientDevice"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultClientDevice.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultClientDeviceEnrollmentResult {
    /**
    * Generic data object.
    */
    'Data': ClientDeviceEnrollmentResult;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "ClientDeviceEnrollmentResult"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultClientDeviceEnrollmentResult.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultCoordinates {
    /**
    * Generic data object.
    */
    'Data': Coordinates;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Coordinates"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultCoordinates.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultCountryFormResponse {
    /**
    * Generic data object.
    */
    'Data': CountryFormResponse;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "CountryFormResponse"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultCountryFormResponse.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultCreatedMenuSectionItems {
    /**
    * Generic data object.
    */
    'Data': CreatedMenuSectionItems;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "CreatedMenuSectionItems"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultCreatedMenuSectionItems.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultCrossSellMenuItems {
    /**
    * Generic data object.
    */
    'Data': CrossSellMenuItems;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "CrossSellMenuItems"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultCrossSellMenuItems.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultCustomer {
    /**
    * Generic data object.
    */
    'Data': Customer;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Customer"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultCustomer.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultDeliveryZone {
    /**
    * Generic data object.
    */
    'Data': DeliveryZone;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "DeliveryZone"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultDeliveryZone.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultDnsRecordInformation {
    /**
    * Generic data object.
    */
    'Data': DnsRecordInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "DnsRecordInformation"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultDnsRecordInformation.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultExecuteConfigurationActionResult {
    /**
    * Generic data object.
    */
    'Data': ExecuteConfigurationActionResult;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "ExecuteConfigurationActionResult"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultExecuteConfigurationActionResult.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultFileCreationResult {
    /**
    * Generic data object.
    */
    'Data': FileCreationResult;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FileCreationResult"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultFileCreationResult.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultFileDownloadResult {
    /**
    * Generic data object.
    */
    'Data': FileDownloadResult;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FileDownloadResult"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultFileDownloadResult.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultFulfillmentStatesConfiguration {
    /**
    * Generic data object.
    */
    'Data': FulfillmentStatesConfiguration;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "FulfillmentStatesConfiguration"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultFulfillmentStatesConfiguration.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultGroup {
    /**
    * Generic data object.
    */
    'Data': Group;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Group"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultGroup.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultHasPaymentMethodResponse {
    /**
    * Generic data object.
    */
    'Data': HasPaymentMethodResponse;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "HasPaymentMethodResponse"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultHasPaymentMethodResponse.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultHomeStatistics {
    /**
    * Generic data object.
    */
    'Data': HomeStatistics;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "HomeStatistics"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultHomeStatistics.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultHydraConfig {
    /**
    * Generic data object.
    */
    'Data': HydraConfig;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "HydraConfig"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultHydraConfig.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultHydraDeviceDetails {
    /**
    * Generic data object.
    */
    'Data': HydraDeviceDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "HydraDeviceDetails"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultHydraDeviceDetails.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultHydraStatus {
    /**
    * Generic data object.
    */
    'Data': HydraStatus;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "HydraStatus"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultHydraStatus.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultIndexPage {
    /**
    * Generic data object.
    */
    'Data': IndexPage;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "IndexPage"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultIndexPage.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultIndexPageBase {
    /**
    * Generic data object.
    */
    'Data': IndexPageBase;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "IndexPageBase"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultIndexPageBase.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultIntercomUserHash {
    /**
    * Generic data object.
    */
    'Data': IntercomUserHash;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "IntercomUserHash"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultIntercomUserHash.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultJobResponse {
    /**
    * Generic data object.
    */
    'Data': JobResponse;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "JobResponse"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultJobResponse.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultKioskEntitlementsResult {
    /**
    * Generic data object.
    */
    'Data': KioskEntitlementsResult;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "KioskEntitlementsResult"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultKioskEntitlementsResult.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultKioskIotConnectionParameters {
    /**
    * Generic data object.
    */
    'Data': KioskIotConnectionParameters;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "KioskIotConnectionParameters"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultKioskIotConnectionParameters.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultKioskSettings {
    /**
    * Generic data object.
    */
    'Data': KioskSettings;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "KioskSettings"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultKioskSettings.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultLightspeedSettings {
    /**
    * Generic data object.
    */
    'Data': LightspeedSettings;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "LightspeedSettings"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultLightspeedSettings.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultLocationArea {
    /**
    * Generic data object.
    */
    'Data': LocationArea;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "LocationArea"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultLocationArea.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultLocationAreaLocation {
    /**
    * Generic data object.
    */
    'Data': LocationAreaLocation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "LocationAreaLocation"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultLocationAreaLocation.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultLocationAreaWithLocations {
    /**
    * Generic data object.
    */
    'Data': LocationAreaWithLocations;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "LocationAreaWithLocations"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultLocationAreaWithLocations.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultLoyaltyCampaign {
    /**
    * Generic data object.
    */
    'Data': LoyaltyCampaign;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "LoyaltyCampaign"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultLoyaltyCampaign.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultMappedLocation {
    /**
    * Generic data object.
    */
    'Data': MappedLocation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "MappedLocation"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMappedLocation.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultMenu {
    /**
    * Generic data object.
    */
    'Data': Menu;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Menu"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMenu.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultMenuItemOptionSet {
    /**
    * Generic data object.
    */
    'Data': MenuItemOptionSet;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "MenuItemOptionSet"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMenuItemOptionSet.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultMenuItemOptionSetItem {
    /**
    * Generic data object.
    */
    'Data': MenuItemOptionSetItem;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "MenuItemOptionSetItem"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMenuItemOptionSetItem.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultMenuNutritionInfoHeader {
    /**
    * Generic data object.
    */
    'Data': MenuNutritionInfoHeader;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "MenuNutritionInfoHeader"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMenuNutritionInfoHeader.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultMenuSection {
    /**
    * Generic data object.
    */
    'Data': MenuSection;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "MenuSection"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMenuSection.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultMenuSectionAvailability {
    /**
    * Generic data object.
    */
    'Data': MenuSectionAvailability;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "MenuSectionAvailability"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMenuSectionAvailability.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultMenuSectionItem {
    /**
    * Generic data object.
    */
    'Data': MenuSectionItem;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "MenuSectionItem"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMenuSectionItem.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultMenuZone {
    /**
    * Generic data object.
    */
    'Data': MenuZone;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "MenuZone"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMenuZone.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultMetadata {
    /**
    * Generic data object.
    */
    'Data': Metadata;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Metadata"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMetadata.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultMetafieldDefinition {
    /**
    * Generic data object.
    */
    'Data': MetafieldDefinition;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "MetafieldDefinition"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMetafieldDefinition.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultMobileAppsImage {
    /**
    * Generic data object.
    */
    'Data': MobileAppsImage;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "MobileAppsImage"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMobileAppsImage.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultMobileAppsSubmission {
    /**
    * Generic data object.
    */
    'Data': MobileAppsSubmission;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "MobileAppsSubmission"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMobileAppsSubmission.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultMobileAppsSubmissionDetails {
    /**
    * Generic data object.
    */
    'Data': MobileAppsSubmissionDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "MobileAppsSubmissionDetails"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMobileAppsSubmissionDetails.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultMobileAppsSubmissionStatus {
    /**
    * Generic data object.
    */
    'Data': MobileAppsSubmissionStatus;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "MobileAppsSubmissionStatus"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultMobileAppsSubmissionStatus.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultModelBase {
    /**
    * Generic data object.
    */
    'Data': ModelBase;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "ModelBase"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultModelBase.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultNutritionInfo {
    /**
    * Generic data object.
    */
    'Data': NutritionInfo;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "NutritionInfo"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultNutritionInfo.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultNutritionInfoV2 {
    /**
    * Generic data object.
    */
    'Data': NutritionInfoV2;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "NutritionInfoV2"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultNutritionInfoV2.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultOAuthApp {
    /**
    * Generic data object.
    */
    'Data': OAuthApp;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "OAuthApp"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultOAuthApp.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultOauthClientRedirectUri {
    /**
    * Generic data object.
    */
    'Data': OauthClientRedirectUri;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "OauthClientRedirectUri"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultOauthClientRedirectUri.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultOktaPortalFeatureFlag {
    /**
    * Generic data object.
    */
    'Data': OktaPortalFeatureFlag;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "OktaPortalFeatureFlag"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultOktaPortalFeatureFlag.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultOrder {
    /**
    * Generic data object.
    */
    'Data': Order;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Order"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultOrder.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultOrderBatch {
    /**
    * Generic data object.
    */
    'Data': OrderBatch;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "OrderBatch"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultOrderBatch.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultOrderBatchingConfiguration {
    /**
    * Generic data object.
    */
    'Data': OrderBatchingConfiguration;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "OrderBatchingConfiguration"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultOrderBatchingConfiguration.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultOrderDeliveryInformation {
    /**
    * Generic data object.
    */
    'Data': OrderDeliveryInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "OrderDeliveryInformation"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultOrderDeliveryInformation.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultOrderFulfillmentStatus {
    /**
    * Generic data object.
    */
    'Data': OrderFulfillmentStatus;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "OrderFulfillmentStatus"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultOrderFulfillmentStatus.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultOrderFulfillmentStatusWithConfigurationActions {
    /**
    * Generic data object.
    */
    'Data': OrderFulfillmentStatusWithConfigurationActions;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "OrderFulfillmentStatusWithConfigurationActions"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultOrderFulfillmentStatusWithConfigurationActions.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultOrderIngestSubmitOrderResponse {
    /**
    * Generic data object.
    */
    'Data': OrderIngestSubmitOrderResponse;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "OrderIngestSubmitOrderResponse"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultOrderIngestSubmitOrderResponse.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultOrderLeadTimes {
    /**
    * Generic data object.
    */
    'Data': OrderLeadTimes;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "OrderLeadTimes"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultOrderLeadTimes.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultOrderPaymentInformation {
    /**
    * Generic data object.
    */
    'Data': OrderPaymentInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "OrderPaymentInformation"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultOrderPaymentInformation.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultPaymentIntent {
    /**
    * Generic data object.
    */
    'Data': PaymentIntent;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "PaymentIntent"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultPaymentIntent.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultPaymentTerminalDetails {
    /**
    * Generic data object.
    */
    'Data': PaymentTerminalDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "PaymentTerminalDetails"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultPaymentTerminalDetails.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultPaymentTerminalTransactionDetails {
    /**
    * Generic data object.
    */
    'Data': PaymentTerminalTransactionDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "PaymentTerminalTransactionDetails"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultPaymentTerminalTransactionDetails.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultPayoutReport3Details {
    /**
    * Generic data object.
    */
    'Data': PayoutReport3Details;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "PayoutReport3Details"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultPayoutReport3Details.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultPayoutReport3Overview {
    /**
    * Generic data object.
    */
    'Data': PayoutReport3Overview;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "PayoutReport3Overview"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultPayoutReport3Overview.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultPreOrderConfig {
    /**
    * Generic data object.
    */
    'Data': PreOrderConfig;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "PreOrderConfig"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultPreOrderConfig.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultProcessingFeeConfig {
    /**
    * Generic data object.
    */
    'Data': ProcessingFeeConfig;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "ProcessingFeeConfig"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultProcessingFeeConfig.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultProduct {
    /**
    * Generic data object.
    */
    'Data': Product;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Product"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultProduct.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultPushNotificationResponse {
    /**
    * Generic data object.
    */
    'Data': PushNotificationResponse;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "PushNotificationResponse"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultPushNotificationResponse.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultRedeemInvitationResult {
    /**
    * Generic data object.
    */
    'Data': RedeemInvitationResult;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "RedeemInvitationResult"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultRedeemInvitationResult.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultRestApiIntegerResult {
    /**
    * Generic data object.
    */
    'Data': RestApiIntegerResult;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "RestApiIntegerResult"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultRestApiIntegerResult.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultRestaurantVoucherPayGreenConfiguration {
    /**
    * Generic data object.
    */
    'Data': RestaurantVoucherPayGreenConfiguration;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "RestaurantVoucherPayGreenConfiguration"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultRestaurantVoucherPayGreenConfiguration.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultRestaurantVoucherPayGreenStoreConfiguration {
    /**
    * Generic data object.
    */
    'Data': RestaurantVoucherPayGreenStoreConfiguration;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "RestaurantVoucherPayGreenStoreConfiguration"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultRestaurantVoucherPayGreenStoreConfiguration.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultRetentionCampaign {
    /**
    * Generic data object.
    */
    'Data': RetentionCampaign;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "RetentionCampaign"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultRetentionCampaign.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultServiceCharge {
    /**
    * Generic data object.
    */
    'Data': ServiceCharge;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "ServiceCharge"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultServiceCharge.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultStore {
    /**
    * Generic data object.
    */
    'Data': Store;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Store"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStore.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultStoreAddress {
    /**
    * Generic data object.
    */
    'Data': StoreAddress;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "StoreAddress"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStoreAddress.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultStoreChannelAssignment {
    /**
    * Generic data object.
    */
    'Data': StoreChannelAssignment;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "StoreChannelAssignment"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStoreChannelAssignment.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultStoreEndOfDayReport {
    /**
    * Generic data object.
    */
    'Data': StoreEndOfDayReport;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "StoreEndOfDayReport"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStoreEndOfDayReport.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultStoreGroup {
    /**
    * Generic data object.
    */
    'Data': StoreGroup;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "StoreGroup"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStoreGroup.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultStoreGroupBase {
    /**
    * Generic data object.
    */
    'Data': StoreGroupBase;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "StoreGroupBase"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStoreGroupBase.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultStoreOrderCapacityConfig {
    /**
    * Generic data object.
    */
    'Data': StoreOrderCapacityConfig;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "StoreOrderCapacityConfig"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStoreOrderCapacityConfig.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultStripeConnectedAccount {
    /**
    * Generic data object.
    */
    'Data': StripeConnectedAccount;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "StripeConnectedAccount"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStripeConnectedAccount.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultStripeTerminalConnectionToken {
    /**
    * Generic data object.
    */
    'Data': StripeTerminalConnectionToken;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "StripeTerminalConnectionToken"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStripeTerminalConnectionToken.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultStripeTerminalLocation {
    /**
    * Generic data object.
    */
    'Data': StripeTerminalLocation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "StripeTerminalLocation"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStripeTerminalLocation.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultStuartSettings {
    /**
    * Generic data object.
    */
    'Data': StuartSettings;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "StuartSettings"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultStuartSettings.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultSubmitOrderResponseDm {
    /**
    * Generic data object.
    */
    'Data': SubmitOrderResponseDm;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "SubmitOrderResponseDm"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultSubmitOrderResponseDm.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultSubscription {
    /**
    * Generic data object.
    */
    'Data': Subscription;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Subscription"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultSubscription.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultTeammate {
    /**
    * Generic data object.
    */
    'Data': Teammate;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Teammate"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultTeammate.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultTelemetrySeriesResult {
    /**
    * Generic data object.
    */
    'Data': TelemetrySeriesResult;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "TelemetrySeriesResult"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultTelemetrySeriesResult.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultTipConfiguration {
    /**
    * Generic data object.
    */
    'Data': TipConfiguration;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "TipConfiguration"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultTipConfiguration.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultUpdateMobileAppsSubmissionStatus {
    /**
    * Generic data object.
    */
    'Data': UpdateMobileAppsSubmissionStatus;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "UpdateMobileAppsSubmissionStatus"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultUpdateMobileAppsSubmissionStatus.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultVoucherWithStats {
    /**
    * Generic data object.
    */
    'Data': VoucherWithStats;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "VoucherWithStats"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultVoucherWithStats.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultWebsiteImage {
    /**
    * Generic data object.
    */
    'Data': WebsiteImage;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "WebsiteImage"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultWebsiteImage.attributeTypeMap;
    }
}

/**
* Rest api result
*/
export class RestApiResultWebsiteTestimonial {
    /**
    * Generic data object.
    */
    'Data': WebsiteTestimonial;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "WebsiteTestimonial"
        }    ];

    static getAttributeTypeMap() {
        return RestApiResultWebsiteTestimonial.attributeTypeMap;
    }
}

/**
* Rest api string array result
*/
export class RestApiStringArrayResult {
    /**
    * Data string array
    */
    'Data': Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return RestApiStringArrayResult.attributeTypeMap;
    }
}

/**
* Rest api string result
*/
export class RestApiStringResult {
    /**
    * Data string
    */
    'Data': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Data",
            "baseName": "Data",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RestApiStringResult.attributeTypeMap;
    }
}

/**
* Rest api unauthorized result
*/
export class RestApiUnauthorizedResult {
    /**
    * Message
    */
    'Message': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Message",
            "baseName": "Message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RestApiUnauthorizedResult.attributeTypeMap;
    }
}

export class RestaurantVoucherAssignedStore {
    'StoreId'?: number;
    'Name'?: string;
    'Active'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Active",
            "baseName": "Active",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return RestaurantVoucherAssignedStore.attributeTypeMap;
    }
}

export class RestaurantVoucherEligibleStore {
    'StoreId'?: number;
    'Name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RestaurantVoucherEligibleStore.attributeTypeMap;
    }
}

export class RestaurantVoucherPayGreenConfiguration {
    'Name'?: string;
    'PayGreenId'?: string;
    'PayGreenConfigurationId'?: number;
    'AssignedStores'?: Array<RestaurantVoucherAssignedStore>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "PayGreenId",
            "baseName": "PayGreenId",
            "type": "string"
        },
        {
            "name": "PayGreenConfigurationId",
            "baseName": "PayGreenConfigurationId",
            "type": "number"
        },
        {
            "name": "AssignedStores",
            "baseName": "AssignedStores",
            "type": "Array<RestaurantVoucherAssignedStore>"
        }    ];

    static getAttributeTypeMap() {
        return RestaurantVoucherPayGreenConfiguration.attributeTypeMap;
    }
}

export class RestaurantVoucherPayGreenConfigurationSummary {
    'Name'?: string;
    'PayGreenConfigurationId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "PayGreenConfigurationId",
            "baseName": "PayGreenConfigurationId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RestaurantVoucherPayGreenConfigurationSummary.attributeTypeMap;
    }
}

export class RestaurantVoucherPayGreenStoreConfiguration {
    'Name'?: string;
    'Active'?: boolean;
    'PayGreenId'?: string;
    'PayGreenConfigurationId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Active",
            "baseName": "Active",
            "type": "boolean"
        },
        {
            "name": "PayGreenId",
            "baseName": "PayGreenId",
            "type": "string"
        },
        {
            "name": "PayGreenConfigurationId",
            "baseName": "PayGreenConfigurationId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RestaurantVoucherPayGreenStoreConfiguration.attributeTypeMap;
    }
}

/**
* Retention campaign
*/
export class RetentionCampaign {
    /**
    * Id of campaign
    */
    'CampaignId'?: number;
    /**
    * Statistics of campaign
    */
    'Statistics'?: CampaignStatistics;
    /**
    * Stores this campaign applies to with campaign start time in Utc
    */
    'Stores'?: Array<StoreCampaignStartTime>;
    /**
    * Permanent reference to the item.
    */
    'PublicId'?: string;
    /**
    * Time in minutes, after which customer will receive retention voucher if he/she does not order
    */
    'NotifyCustomerAfterMinutes'?: number;
    /**
    * Discount amount in percents
    */
    'PercentDiscountAmount'?: number;
    /**
    * Discount amount in sum of money
    */
    'LumpDiscountAmount'?: number;
    /**
    * Number of days for which the voucher will be valid.
    */
    'VoucherValidPeriodDays'?: number;
    /**
    * Discount will include delivery fee
    */
    'IncludeDeliveryFee'?: boolean;
    /**
    * Automatically apply resulting vouchers
    */
    'AutoApplyResultingVouchers'?: boolean;
    /**
    * Campaign will apply to existing orders
    */
    'IncludeExistingOrders'?: boolean;
    /**
    * Is campaign enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Ids of stores this campaign applies to
    */
    'StoreIds'?: Array<number>;
    /**
    * The app that this campaign belongs to.
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CampaignId",
            "baseName": "CampaignId",
            "type": "number"
        },
        {
            "name": "Statistics",
            "baseName": "Statistics",
            "type": "CampaignStatistics"
        },
        {
            "name": "Stores",
            "baseName": "Stores",
            "type": "Array<StoreCampaignStartTime>"
        },
        {
            "name": "PublicId",
            "baseName": "PublicId",
            "type": "string"
        },
        {
            "name": "NotifyCustomerAfterMinutes",
            "baseName": "NotifyCustomerAfterMinutes",
            "type": "number"
        },
        {
            "name": "PercentDiscountAmount",
            "baseName": "PercentDiscountAmount",
            "type": "number"
        },
        {
            "name": "LumpDiscountAmount",
            "baseName": "LumpDiscountAmount",
            "type": "number"
        },
        {
            "name": "VoucherValidPeriodDays",
            "baseName": "VoucherValidPeriodDays",
            "type": "number"
        },
        {
            "name": "IncludeDeliveryFee",
            "baseName": "IncludeDeliveryFee",
            "type": "boolean"
        },
        {
            "name": "AutoApplyResultingVouchers",
            "baseName": "AutoApplyResultingVouchers",
            "type": "boolean"
        },
        {
            "name": "IncludeExistingOrders",
            "baseName": "IncludeExistingOrders",
            "type": "boolean"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RetentionCampaign.attributeTypeMap;
    }
}

/**
* Retention campaign base
*/
export class RetentionCampaignBase {
    /**
    * Time in minutes, after which customer will receive retention voucher if he/she does not order
    */
    'NotifyCustomerAfterMinutes'?: number;
    /**
    * Discount amount in percents
    */
    'PercentDiscountAmount'?: number;
    /**
    * Discount amount in sum of money
    */
    'LumpDiscountAmount'?: number;
    /**
    * Number of days for which the voucher will be valid.
    */
    'VoucherValidPeriodDays'?: number;
    /**
    * Discount will include delivery fee
    */
    'IncludeDeliveryFee'?: boolean;
    /**
    * Automatically apply resulting vouchers
    */
    'AutoApplyResultingVouchers'?: boolean;
    /**
    * Campaign will apply to existing orders
    */
    'IncludeExistingOrders'?: boolean;
    /**
    * Is campaign enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Ids of stores this campaign applies to
    */
    'StoreIds'?: Array<number>;
    /**
    * The app that this campaign belongs to.
    */
    'AppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "NotifyCustomerAfterMinutes",
            "baseName": "NotifyCustomerAfterMinutes",
            "type": "number"
        },
        {
            "name": "PercentDiscountAmount",
            "baseName": "PercentDiscountAmount",
            "type": "number"
        },
        {
            "name": "LumpDiscountAmount",
            "baseName": "LumpDiscountAmount",
            "type": "number"
        },
        {
            "name": "VoucherValidPeriodDays",
            "baseName": "VoucherValidPeriodDays",
            "type": "number"
        },
        {
            "name": "IncludeDeliveryFee",
            "baseName": "IncludeDeliveryFee",
            "type": "boolean"
        },
        {
            "name": "AutoApplyResultingVouchers",
            "baseName": "AutoApplyResultingVouchers",
            "type": "boolean"
        },
        {
            "name": "IncludeExistingOrders",
            "baseName": "IncludeExistingOrders",
            "type": "boolean"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RetentionCampaignBase.attributeTypeMap;
    }
}

/**
* Retention campaign created event
*/
export class RetentionCampaignCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The retention campaign
    */
    'RetentionCampaign'?: RetentionCampaign;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "RetentionCampaign",
            "baseName": "RetentionCampaign",
            "type": "RetentionCampaign"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RetentionCampaignCreatedEvent.attributeTypeMap;
    }
}

/**
* Retention campaign deleted event
*/
export class RetentionCampaignDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The retention campaign
    */
    'RetentionCampaign'?: RetentionCampaign;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "RetentionCampaign",
            "baseName": "RetentionCampaign",
            "type": "RetentionCampaign"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RetentionCampaignDeletedEvent.attributeTypeMap;
    }
}

/**
* Retention campaign updated event
*/
export class RetentionCampaignUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Info User
    */
    'User'?: UserEventInfo;
    /**
    * The retention campaign
    */
    'RetentionCampaign'?: RetentionCampaign;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "RetentionCampaign",
            "baseName": "RetentionCampaign",
            "type": "RetentionCampaign"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RetentionCampaignUpdatedEvent.attributeTypeMap;
    }
}

/**
* Revenue Adjustments breakdown
*/
export class RevenueAdjustmentsDetails {
    /**
    * Online sales refunds
    */
    'OnlineSalesRefundedAmount'?: number;
    /**
    * POS Online sales refunds
    */
    'PosSalesRefundedAmount'?: number;
    /**
    * Cash sales refunds
    */
    'CashSalesRefundedAmount'?: number;
    /**
    * Customer cash fees
    */
    'CustomerCashFees'?: number;
    /**
    * Number of refunds
    */
    'RefundsCount'?: number;
    /**
    * PayGreen sales
    */
    'PayGreenSalesAmount'?: number;
    /**
    * PayGreen processing fees charged to end-user
    */
    'PayGreenProcessingFees'?: number;
    /**
    * Total revenue adjustments
    */
    'TotalOnlineRevenueAdjustments'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OnlineSalesRefundedAmount",
            "baseName": "OnlineSalesRefundedAmount",
            "type": "number"
        },
        {
            "name": "PosSalesRefundedAmount",
            "baseName": "PosSalesRefundedAmount",
            "type": "number"
        },
        {
            "name": "CashSalesRefundedAmount",
            "baseName": "CashSalesRefundedAmount",
            "type": "number"
        },
        {
            "name": "CustomerCashFees",
            "baseName": "CustomerCashFees",
            "type": "number"
        },
        {
            "name": "RefundsCount",
            "baseName": "RefundsCount",
            "type": "number"
        },
        {
            "name": "PayGreenSalesAmount",
            "baseName": "PayGreenSalesAmount",
            "type": "number"
        },
        {
            "name": "PayGreenProcessingFees",
            "baseName": "PayGreenProcessingFees",
            "type": "number"
        },
        {
            "name": "TotalOnlineRevenueAdjustments",
            "baseName": "TotalOnlineRevenueAdjustments",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RevenueAdjustmentsDetails.attributeTypeMap;
    }
}

/**
* Sales information
*/
export class RevenueDetail {
    /**
    * Online sales amount
    */
    'OnlineSalesAmount'?: number;
    /**
    * Online sales tax
    */
    'OnlineSalesTax'?: number;
    /**
    * Online sales amount plus online sales tax
    */
    'OnlineSalesIncludingTax'?: number;
    /**
    * Online sales base amount to calculate fees
    */
    'OnlineSalesFeesBaseAmount'?: number;
    /**
    * Cash sales amount
    */
    'CashSalesAmount'?: number;
    /**
    * Cash sales tax
    */
    'CashSalesTax'?: number;
    /**
    * Cash sales amount plus online sales tax
    */
    'CashSalesIncludingTax'?: number;
    /**
    * Online sales base amount to calculate fees
    */
    'CashSalesFeesBaseAmount'?: number;
    /**
    * Total Sales (online and cash) including tax
    */
    'TotalSalesIncludingTax'?: number;
    /**
    * Delivery charges on online sales
    */
    'OnlineSalesDeliveryCharges'?: number;
    /**
    * Tips for online sales
    */
    'OnlineSalesTips'?: number;
    /**
    * Online sales plus online delivery charges and tips
    */
    'TotalOnlineRevenue'?: number;
    /**
    * Service charge on online sales
    */
    'OnlineSalesServiceCharges'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OnlineSalesAmount",
            "baseName": "OnlineSalesAmount",
            "type": "number"
        },
        {
            "name": "OnlineSalesTax",
            "baseName": "OnlineSalesTax",
            "type": "number"
        },
        {
            "name": "OnlineSalesIncludingTax",
            "baseName": "OnlineSalesIncludingTax",
            "type": "number"
        },
        {
            "name": "OnlineSalesFeesBaseAmount",
            "baseName": "OnlineSalesFeesBaseAmount",
            "type": "number"
        },
        {
            "name": "CashSalesAmount",
            "baseName": "CashSalesAmount",
            "type": "number"
        },
        {
            "name": "CashSalesTax",
            "baseName": "CashSalesTax",
            "type": "number"
        },
        {
            "name": "CashSalesIncludingTax",
            "baseName": "CashSalesIncludingTax",
            "type": "number"
        },
        {
            "name": "CashSalesFeesBaseAmount",
            "baseName": "CashSalesFeesBaseAmount",
            "type": "number"
        },
        {
            "name": "TotalSalesIncludingTax",
            "baseName": "TotalSalesIncludingTax",
            "type": "number"
        },
        {
            "name": "OnlineSalesDeliveryCharges",
            "baseName": "OnlineSalesDeliveryCharges",
            "type": "number"
        },
        {
            "name": "OnlineSalesTips",
            "baseName": "OnlineSalesTips",
            "type": "number"
        },
        {
            "name": "TotalOnlineRevenue",
            "baseName": "TotalOnlineRevenue",
            "type": "number"
        },
        {
            "name": "OnlineSalesServiceCharges",
            "baseName": "OnlineSalesServiceCharges",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RevenueDetail.attributeTypeMap;
    }
}

export class SafeWaitHandle {
    'IsInvalid'?: boolean;
    'IsClosed'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IsInvalid",
            "baseName": "IsInvalid",
            "type": "boolean"
        },
        {
            "name": "IsClosed",
            "baseName": "IsClosed",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return SafeWaitHandle.attributeTypeMap;
    }
}

/**
* Search Criteria for Audit Logs
*/
export class SearchCriteria {
    /**
    * The maximum elements to return
    */
    'Limit'?: number;
    /**
    * The index of the page to return, starting by 1
    */
    'Page'?: number;
    /**
    * Start date
    */
    'Start'?: Date;
    /**
    * End date
    */
    'End'?: Date;
    /**
    * Events that have Order Id
    */
    'OrderId'?: number;
    /**
    * Events that have Store Id
    */
    'StoreId'?: number;
    /**
    * Events that have Store Id List
    */
    'StoreIdList'?: Array<number>;
    /**
    * Events that have Store Group Id
    */
    'StoreGroupId'?: number;
    /**
    * Events that have User Id
    */
    'UserId'?: number;
    /**
    * Events that have Menu Id
    */
    'MenuId'?: number;
    /**
    * Events that have Campaign Id
    */
    'CampaignId'?: number;
    /**
    * Events that have User Email
    */
    'UserEmail'?: string;
    /**
    * Events that have User Name
    */
    'UserName'?: string;
    /**
    * Events that have voucher code
    */
    'VoucherCode'?: string;
    /**
    * Events that have event type\\s
    */
    'EventType'?: Array<string>;
    /**
    * Unique Identifier of Event, if this is specified, all other criteria are ignored.
    */
    'FlipdishEventId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Limit",
            "baseName": "Limit",
            "type": "number"
        },
        {
            "name": "Page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "Start",
            "baseName": "Start",
            "type": "Date"
        },
        {
            "name": "End",
            "baseName": "End",
            "type": "Date"
        },
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreIdList",
            "baseName": "StoreIdList",
            "type": "Array<number>"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "UserId",
            "baseName": "UserId",
            "type": "number"
        },
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "CampaignId",
            "baseName": "CampaignId",
            "type": "number"
        },
        {
            "name": "UserEmail",
            "baseName": "UserEmail",
            "type": "string"
        },
        {
            "name": "UserName",
            "baseName": "UserName",
            "type": "string"
        },
        {
            "name": "VoucherCode",
            "baseName": "VoucherCode",
            "type": "string"
        },
        {
            "name": "EventType",
            "baseName": "EventType",
            "type": "Array<string>"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SearchCriteria.attributeTypeMap;
    }
}

/**
* Store Service Charge
*/
export class ServiceCharge {
    /**
    * Store identifier
    */
    'StoreId'?: number;
    /**
    * The Default Service Charge Value
    */
    'PercentageValue'?: number;
    /**
    * Enable Service Charge for store true(on) / false(off)
    */
    'Enabled'?: boolean;
    /**
    * Sets the service charge to be optional
    */
    'IsOptional'?: boolean;
    /**
    * Display service charge together with processing fee
    */
    'DisplayWithProcessingFee'?: boolean;
    /**
    * If true, will include voucher value in calculation   i.e 10E order with 1E service charge and 5E voucher would have service charge at 0.5E
    */
    'IncludesVouchers'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "PercentageValue",
            "baseName": "PercentageValue",
            "type": "number"
        },
        {
            "name": "Enabled",
            "baseName": "Enabled",
            "type": "boolean"
        },
        {
            "name": "IsOptional",
            "baseName": "IsOptional",
            "type": "boolean"
        },
        {
            "name": "DisplayWithProcessingFee",
            "baseName": "DisplayWithProcessingFee",
            "type": "boolean"
        },
        {
            "name": "IncludesVouchers",
            "baseName": "IncludesVouchers",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ServiceCharge.attributeTypeMap;
    }
}

/**
* Describes the configuration of OrderBatching
*/
export class SetOrderBatchingConfiguration {
    /**
    * Batch sending interval in seconds
    */
    'BatchIntervalInSeconds'?: number;
    /**
    * OrderBatching is enabled or not
    */
    'Enabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "BatchIntervalInSeconds",
            "baseName": "BatchIntervalInSeconds",
            "type": "number"
        },
        {
            "name": "Enabled",
            "baseName": "Enabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return SetOrderBatchingConfiguration.attributeTypeMap;
    }
}

/**
* Set password with PIN model
*/
export class SetPasswordWithPinModel {
    /**
    * PIN code (received via email)
    */
    'Pin': number;
    /**
    * New Password
    */
    'NewPassword': string;
    /**
    * Google Recaptcha Token
    */
    'RecaptchaToken'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Pin",
            "baseName": "Pin",
            "type": "number"
        },
        {
            "name": "NewPassword",
            "baseName": "NewPassword",
            "type": "string"
        },
        {
            "name": "RecaptchaToken",
            "baseName": "RecaptchaToken",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SetPasswordWithPinModel.attributeTypeMap;
    }
}

/**
* Set the validity periods of a voucher.
*/
export class SetVoucherValidityPeriodsSimplifiedRequest {
    /**
    * Days of week when the voucher is valid
    */
    'DaysOfWeek'?: Array<SetVoucherValidityPeriodsSimplifiedRequest.DaysOfWeekEnum>;
    /**
    * Start time of the day when the voucher is valid
    */
    'StartTime'?: string;
    /**
    * End time of the day when the voucher is valid.  If the end time is before the start time, the end time is assumed to be the next day.
    */
    'EndTime'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DaysOfWeek",
            "baseName": "DaysOfWeek",
            "type": "Array<SetVoucherValidityPeriodsSimplifiedRequest.DaysOfWeekEnum>"
        },
        {
            "name": "StartTime",
            "baseName": "StartTime",
            "type": "string"
        },
        {
            "name": "EndTime",
            "baseName": "EndTime",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SetVoucherValidityPeriodsSimplifiedRequest.attributeTypeMap;
    }
}

export namespace SetVoucherValidityPeriodsSimplifiedRequest {
    export enum DaysOfWeekEnum {
        Sunday = <any> 'Sunday',
        Monday = <any> 'Monday',
        Tuesday = <any> 'Tuesday',
        Wednesday = <any> 'Wednesday',
        Thursday = <any> 'Thursday',
        Friday = <any> 'Friday',
        Saturday = <any> 'Saturday'
    }
}
export class Setting {
    'Key'?: string;
    'Value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Key",
            "baseName": "Key",
            "type": "string"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Setting.attributeTypeMap;
    }
}

/**
* 
*/
export class SignupStep {
    /**
    * Action needs to take
    */
    'Action'?: SignupStep.ActionEnum;
    /**
    * Question in case Action == Question
    */
    'Question'?: string;
    /**
    * Predefined answer in case Action == Question
    */
    'PredefinedAnswers'?: Array<PredefinedAnswer>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Action",
            "baseName": "Action",
            "type": "SignupStep.ActionEnum"
        },
        {
            "name": "Question",
            "baseName": "Question",
            "type": "string"
        },
        {
            "name": "PredefinedAnswers",
            "baseName": "PredefinedAnswers",
            "type": "Array<PredefinedAnswer>"
        }    ];

    static getAttributeTypeMap() {
        return SignupStep.attributeTypeMap;
    }
}

export namespace SignupStep {
    export enum ActionEnum {
        Question = <any> 'Question',
        StoreLocation = <any> 'StoreLocation',
        PaymentSubscription = <any> 'PaymentSubscription',
        StoreName = <any> 'StoreName'
    }
}
/**
* Sms Info
*/
export class SmsInfo {
    /**
    * Origin phone number
    */
    'From'?: string;
    /**
    * Destination phone number
    */
    'To'?: string;
    /**
    * Text message
    */
    'Text'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "From",
            "baseName": "From",
            "type": "string"
        },
        {
            "name": "To",
            "baseName": "To",
            "type": "string"
        },
        {
            "name": "Text",
            "baseName": "Text",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SmsInfo.attributeTypeMap;
    }
}

/**
* Sms received event
*/
export class SmsReceivedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The sms info
    */
    'SmsInfo'?: SmsInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "SmsInfo",
            "baseName": "SmsInfo",
            "type": "SmsInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SmsReceivedEvent.attributeTypeMap;
    }
}

/**
* A single currency data point, with no date
*/
export class StatisticsCurrencyDataPoint {
    /**
    * Currency
    */
    'Currency'?: StatisticsCurrencyDataPoint.CurrencyEnum;
    /**
    * Amount of users for this currency
    */
    'UserCount'?: number;
    /**
    * Amount of orders for this currency
    */
    'OrderCount'?: number;
    /**
    * Value of orders for this currency
    */
    'OrderValue'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "StatisticsCurrencyDataPoint.CurrencyEnum"
        },
        {
            "name": "UserCount",
            "baseName": "UserCount",
            "type": "number"
        },
        {
            "name": "OrderCount",
            "baseName": "OrderCount",
            "type": "number"
        },
        {
            "name": "OrderValue",
            "baseName": "OrderValue",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StatisticsCurrencyDataPoint.attributeTypeMap;
    }
}

export namespace StatisticsCurrencyDataPoint {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Store
*/
export class Store {
    /**
    * Store identifier
    */
    'StoreId'?: number;
    /**
    * Store group id to which this store belongs
    */
    'StoreGroupId'?: number;
    /**
    * Store address
    */
    'Address'?: StoreAddress;
    /**
    * Delivery zones
    */
    'DeliveryZones'?: Array<DeliveryZone>;
    /**
    * Automated Phone Marketing number
    */
    'ApmPhoneNumber'?: string;
    /**
    * Pickup hours
    */
    'PickupHours'?: Array<BusinessHoursPeriod>;
    /**
    * Delivery hours
    */
    'DeliveryHours'?: Array<BusinessHoursPeriod>;
    /**
    * Menu identifier
    */
    'MenuId'?: number;
    /**
    * Overridden confirmation message for delivery orders
    */
    'OrderConfirmationMessageOverrideDelivery'?: string;
    /**
    * Overridden confirmation message for pickup orders
    */
    'OrderConfirmationMessageOverridePickup'?: string;
    /**
    * Printout layout
    */
    'PrintoutLayoutType'?: Store.PrintoutLayoutTypeEnum;
    /**
    * Store notes
    */
    'StoreNotes'?: Array<StoreNote>;
    /**
    * Microsoft Time Zone Index Values (https://msdn.microsoft.com/en-us/library/ms912391)  (Editable through store coordinate change)
    */
    'MicrosoftTimeZone'?: string;
    /**
    * IANA Time Zone (https://www.iana.org/time-zones)  (Editable through store coordinate change)
    */
    'IanaTimeZone'?: string;
    /**
    * Currency (derived from Store Group)
    */
    'Currency'?: Store.CurrencyEnum;
    /**
    * Is PerOrder Enabled for Delivery
    */
    'PreOrderDeliveryEnabled'?: boolean;
    /**
    * Is PerOrder Enabled for Pickup
    */
    'PreOrderPickupEnabled'?: boolean;
    /**
    * Url for logo image
    */
    'LogoUrl'?: string;
    /**
    * Fraud Prevention Strategy
    */
    'FraudPreventionStrategy'?: string;
    /**
    * Store's app ids
    */
    'AppIds'?: Array<string>;
    /**
    * Phone number
    */
    'PhoneNumber'?: string;
    /**
    * True if the store always appears open
    */
    'AlwaysAppearOpen'?: boolean;
    /**
    * True if the store accepts pre-orders
    */
    'PreOrderEnabled'?: boolean;
    /**
    * True if the store accepts take-out orders
    */
    'TakeOutEnabled'?: boolean;
    /**
    * True if the store has table service
    */
    'TableServiceEnabled'?: boolean;
    /**
    * True if the store accepts dine-in orders
    */
    'DineInEnabled'?: boolean;
    /**
    * True if both pre-orders and talbe service can be enabled
    */
    'AllowPreOrdersAndTableService'?: boolean;
    /**
    * True if the store accepts pickup orders
    */
    'PickupEnabled'?: boolean;
    /**
    * True if the store accepts delivery orders
    */
    'DeliveryEnabled'?: boolean;
    /**
    * True if the store accepts card payment for delivery orders
    */
    'CardOrderDeliveryEnabled'?: boolean;
    /**
    * True if the store accepts cash payment for delivery orders
    */
    'CashOrdersDeliveryEnabled'?: boolean;
    /**
    * True if the store accepts card payment for pickup orders
    */
    'CardOrdersPickupEnabled'?: boolean;
    /**
    * True if the store accepts cash payment for pickup orders
    */
    'CashOrdersPickupEnabled'?: boolean;
    /**
    * True if the store accepts tips
    */
    'TipsEnabled'?: boolean;
    /**
    * True if the stores orders are automatically accepted in Flipdish
    */
    'AutomaticallyAcceptOrders'?: boolean;
    /**
    * True if the store is open for delivery
    */
    'OpenForDelivery'?: boolean;
    /**
    * True if the store is open for pickup
    */
    'OpenForPickup'?: boolean;
    /**
    * Minimum pickup order amount
    */
    'MinimumPickupOrderAmount'?: number;
    /**
    * True if customer name required for pickup orders
    */
    'RequireCustomerNameForPickup'?: boolean;
    /**
    * Mask your customers phone numbers printed on receipts and reduce the amout of personally identifiable customer information that is exposed.
    */
    'GdprCustomerPhoneNumbers'?: boolean;
    /**
    * True if customer name required for delivery orders
    */
    'RequireCustomerNameForDelivery'?: boolean;
    /**
    * True if the customer is allowed enter custom notes with their orders
    */
    'AllowChefNotes'?: boolean;
    /**
    * True if order confirmation sms includes estimated time when order will be ready for collection
    */
    'EtaInPickupConfirmationSmsEnabled'?: boolean;
    /**
    * True if order confirmation sms includes estimated time when order will delivered
    */
    'EtaInDeliveryConfirmationSmsEnabled'?: boolean;
    /**
    * Is the Store Archived
    */
    'IsArchived'?: boolean;
    /**
    * Is the Store Published
    */
    'IsPublished'?: boolean;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Email address (visible to customers)
    */
    'EmailAddress'?: string;
    /**
    * Staff Language (used for communication with the staff)  Emails, Printouts etc
    */
    'StaffLanguage'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "Address",
            "baseName": "Address",
            "type": "StoreAddress"
        },
        {
            "name": "DeliveryZones",
            "baseName": "DeliveryZones",
            "type": "Array<DeliveryZone>"
        },
        {
            "name": "ApmPhoneNumber",
            "baseName": "ApmPhoneNumber",
            "type": "string"
        },
        {
            "name": "PickupHours",
            "baseName": "PickupHours",
            "type": "Array<BusinessHoursPeriod>"
        },
        {
            "name": "DeliveryHours",
            "baseName": "DeliveryHours",
            "type": "Array<BusinessHoursPeriod>"
        },
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "OrderConfirmationMessageOverrideDelivery",
            "baseName": "OrderConfirmationMessageOverrideDelivery",
            "type": "string"
        },
        {
            "name": "OrderConfirmationMessageOverridePickup",
            "baseName": "OrderConfirmationMessageOverridePickup",
            "type": "string"
        },
        {
            "name": "PrintoutLayoutType",
            "baseName": "PrintoutLayoutType",
            "type": "Store.PrintoutLayoutTypeEnum"
        },
        {
            "name": "StoreNotes",
            "baseName": "StoreNotes",
            "type": "Array<StoreNote>"
        },
        {
            "name": "MicrosoftTimeZone",
            "baseName": "MicrosoftTimeZone",
            "type": "string"
        },
        {
            "name": "IanaTimeZone",
            "baseName": "IanaTimeZone",
            "type": "string"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "Store.CurrencyEnum"
        },
        {
            "name": "PreOrderDeliveryEnabled",
            "baseName": "PreOrderDeliveryEnabled",
            "type": "boolean"
        },
        {
            "name": "PreOrderPickupEnabled",
            "baseName": "PreOrderPickupEnabled",
            "type": "boolean"
        },
        {
            "name": "LogoUrl",
            "baseName": "LogoUrl",
            "type": "string"
        },
        {
            "name": "FraudPreventionStrategy",
            "baseName": "FraudPreventionStrategy",
            "type": "string"
        },
        {
            "name": "AppIds",
            "baseName": "AppIds",
            "type": "Array<string>"
        },
        {
            "name": "PhoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        },
        {
            "name": "AlwaysAppearOpen",
            "baseName": "AlwaysAppearOpen",
            "type": "boolean"
        },
        {
            "name": "PreOrderEnabled",
            "baseName": "PreOrderEnabled",
            "type": "boolean"
        },
        {
            "name": "TakeOutEnabled",
            "baseName": "TakeOutEnabled",
            "type": "boolean"
        },
        {
            "name": "TableServiceEnabled",
            "baseName": "TableServiceEnabled",
            "type": "boolean"
        },
        {
            "name": "DineInEnabled",
            "baseName": "DineInEnabled",
            "type": "boolean"
        },
        {
            "name": "AllowPreOrdersAndTableService",
            "baseName": "AllowPreOrdersAndTableService",
            "type": "boolean"
        },
        {
            "name": "PickupEnabled",
            "baseName": "PickupEnabled",
            "type": "boolean"
        },
        {
            "name": "DeliveryEnabled",
            "baseName": "DeliveryEnabled",
            "type": "boolean"
        },
        {
            "name": "CardOrderDeliveryEnabled",
            "baseName": "CardOrderDeliveryEnabled",
            "type": "boolean"
        },
        {
            "name": "CashOrdersDeliveryEnabled",
            "baseName": "CashOrdersDeliveryEnabled",
            "type": "boolean"
        },
        {
            "name": "CardOrdersPickupEnabled",
            "baseName": "CardOrdersPickupEnabled",
            "type": "boolean"
        },
        {
            "name": "CashOrdersPickupEnabled",
            "baseName": "CashOrdersPickupEnabled",
            "type": "boolean"
        },
        {
            "name": "TipsEnabled",
            "baseName": "TipsEnabled",
            "type": "boolean"
        },
        {
            "name": "AutomaticallyAcceptOrders",
            "baseName": "AutomaticallyAcceptOrders",
            "type": "boolean"
        },
        {
            "name": "OpenForDelivery",
            "baseName": "OpenForDelivery",
            "type": "boolean"
        },
        {
            "name": "OpenForPickup",
            "baseName": "OpenForPickup",
            "type": "boolean"
        },
        {
            "name": "MinimumPickupOrderAmount",
            "baseName": "MinimumPickupOrderAmount",
            "type": "number"
        },
        {
            "name": "RequireCustomerNameForPickup",
            "baseName": "RequireCustomerNameForPickup",
            "type": "boolean"
        },
        {
            "name": "GdprCustomerPhoneNumbers",
            "baseName": "GdprCustomerPhoneNumbers",
            "type": "boolean"
        },
        {
            "name": "RequireCustomerNameForDelivery",
            "baseName": "RequireCustomerNameForDelivery",
            "type": "boolean"
        },
        {
            "name": "AllowChefNotes",
            "baseName": "AllowChefNotes",
            "type": "boolean"
        },
        {
            "name": "EtaInPickupConfirmationSmsEnabled",
            "baseName": "EtaInPickupConfirmationSmsEnabled",
            "type": "boolean"
        },
        {
            "name": "EtaInDeliveryConfirmationSmsEnabled",
            "baseName": "EtaInDeliveryConfirmationSmsEnabled",
            "type": "boolean"
        },
        {
            "name": "IsArchived",
            "baseName": "IsArchived",
            "type": "boolean"
        },
        {
            "name": "IsPublished",
            "baseName": "IsPublished",
            "type": "boolean"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "EmailAddress",
            "baseName": "EmailAddress",
            "type": "string"
        },
        {
            "name": "StaffLanguage",
            "baseName": "StaffLanguage",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Store.attributeTypeMap;
    }
}

export namespace Store {
    export enum PrintoutLayoutTypeEnum {
        Default = <any> 'Default',
        Centra = <any> 'Centra',
        SmallChefNotes = <any> 'SmallChefNotes',
        SmallChefNotesAndCentra = <any> 'SmallChefNotesAndCentra'
    }
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Store address
*/
export class StoreAddress {
    /**
    * Address identifier
    */
    'AddressId'?: number;
    /**
    * Coordinate
    */
    'Coordinates'?: Coordinates;
    /**
    * Address line 1
    */
    'Line1'?: string;
    /**
    * Postcode
    */
    'Postcode'?: string;
    /**
    * City
    */
    'City'?: string;
    /**
    * Country code (ISO-alpha2)
    */
    'CountryCode'?: string;
    /**
    * Display for customer
    */
    'DisplayForCustomer'?: string;
    /**
    * Dyanmic field/value pairs, defined by the form assigned to the given country code.
    */
    'AddressFields'?: { [key: string]: any; };
    /**
    * Single line display i18n, may be empty for not supported countries
    */
    'SingleLineDisplay'?: string;
    /**
    * Two line display i18n, may be empty for not supported countries
    */
    'TwoLinesDisplay'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AddressId",
            "baseName": "AddressId",
            "type": "number"
        },
        {
            "name": "Coordinates",
            "baseName": "Coordinates",
            "type": "Coordinates"
        },
        {
            "name": "Line1",
            "baseName": "Line1",
            "type": "string"
        },
        {
            "name": "Postcode",
            "baseName": "Postcode",
            "type": "string"
        },
        {
            "name": "City",
            "baseName": "City",
            "type": "string"
        },
        {
            "name": "CountryCode",
            "baseName": "CountryCode",
            "type": "string"
        },
        {
            "name": "DisplayForCustomer",
            "baseName": "DisplayForCustomer",
            "type": "string"
        },
        {
            "name": "AddressFields",
            "baseName": "AddressFields",
            "type": "{ [key: string]: any; }"
        },
        {
            "name": "SingleLineDisplay",
            "baseName": "SingleLineDisplay",
            "type": "string"
        },
        {
            "name": "TwoLinesDisplay",
            "baseName": "TwoLinesDisplay",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return StoreAddress.attributeTypeMap;
    }
}

/**
* Store address base
*/
export class StoreAddressBase {
    /**
    * Address line 1
    */
    'Line1'?: string;
    /**
    * Postcode
    */
    'Postcode'?: string;
    /**
    * City
    */
    'City'?: string;
    /**
    * Country code (ISO-alpha2)
    */
    'CountryCode'?: string;
    /**
    * Display for customer
    */
    'DisplayForCustomer'?: string;
    /**
    * Dyanmic field/value pairs, defined by the form assigned to the given country code.
    */
    'AddressFields'?: { [key: string]: any; };
    /**
    * Single line display i18n, may be empty for not supported countries
    */
    'SingleLineDisplay'?: string;
    /**
    * Two line display i18n, may be empty for not supported countries
    */
    'TwoLinesDisplay'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Line1",
            "baseName": "Line1",
            "type": "string"
        },
        {
            "name": "Postcode",
            "baseName": "Postcode",
            "type": "string"
        },
        {
            "name": "City",
            "baseName": "City",
            "type": "string"
        },
        {
            "name": "CountryCode",
            "baseName": "CountryCode",
            "type": "string"
        },
        {
            "name": "DisplayForCustomer",
            "baseName": "DisplayForCustomer",
            "type": "string"
        },
        {
            "name": "AddressFields",
            "baseName": "AddressFields",
            "type": "{ [key: string]: any; }"
        },
        {
            "name": "SingleLineDisplay",
            "baseName": "SingleLineDisplay",
            "type": "string"
        },
        {
            "name": "TwoLinesDisplay",
            "baseName": "TwoLinesDisplay",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return StoreAddressBase.attributeTypeMap;
    }
}

/**
* Address form payload.
*/
export class StoreAddressForm {
    /**
    * The dynamic fields generated by the address form.
    */
    'AddressFields': { [key: string]: any; };
    /**
    * ISO 2 letters code for the country, should be the same as the form that generates the fields.
    */
    'CountryCode': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AddressFields",
            "baseName": "AddressFields",
            "type": "{ [key: string]: any; }"
        },
        {
            "name": "CountryCode",
            "baseName": "CountryCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreAddressForm.attributeTypeMap;
    }
}

/**
* Store Address Updated Event
*/
export class StoreAddressUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which updated this store address
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Updated store address
    */
    'StoreAddress'?: StoreAddress;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreAddress",
            "baseName": "StoreAddress",
            "type": "StoreAddress"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreAddressUpdatedEvent.attributeTypeMap;
    }
}

/**
* Store Archived Event
*/
export class StoreArchivedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which archived this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Archived Store
    */
    'Store'?: Store;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Store",
            "baseName": "Store",
            "type": "Store"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreArchivedEvent.attributeTypeMap;
    }
}

/**
* Store Base
*/
export class StoreBase {
    /**
    * Phone number
    */
    'PhoneNumber'?: string;
    /**
    * True if the store always appears open
    */
    'AlwaysAppearOpen'?: boolean;
    /**
    * True if the store accepts pre-orders
    */
    'PreOrderEnabled'?: boolean;
    /**
    * True if the store accepts take-out orders
    */
    'TakeOutEnabled'?: boolean;
    /**
    * True if the store has table service
    */
    'TableServiceEnabled'?: boolean;
    /**
    * True if the store accepts dine-in orders
    */
    'DineInEnabled'?: boolean;
    /**
    * True if both pre-orders and talbe service can be enabled
    */
    'AllowPreOrdersAndTableService'?: boolean;
    /**
    * True if the store accepts pickup orders
    */
    'PickupEnabled'?: boolean;
    /**
    * True if the store accepts delivery orders
    */
    'DeliveryEnabled'?: boolean;
    /**
    * True if the store accepts card payment for delivery orders
    */
    'CardOrderDeliveryEnabled'?: boolean;
    /**
    * True if the store accepts cash payment for delivery orders
    */
    'CashOrdersDeliveryEnabled'?: boolean;
    /**
    * True if the store accepts card payment for pickup orders
    */
    'CardOrdersPickupEnabled'?: boolean;
    /**
    * True if the store accepts cash payment for pickup orders
    */
    'CashOrdersPickupEnabled'?: boolean;
    /**
    * True if the store accepts tips
    */
    'TipsEnabled'?: boolean;
    /**
    * True if the stores orders are automatically accepted in Flipdish
    */
    'AutomaticallyAcceptOrders'?: boolean;
    /**
    * True if the store is open for delivery
    */
    'OpenForDelivery'?: boolean;
    /**
    * True if the store is open for pickup
    */
    'OpenForPickup'?: boolean;
    /**
    * Minimum pickup order amount
    */
    'MinimumPickupOrderAmount'?: number;
    /**
    * True if customer name required for pickup orders
    */
    'RequireCustomerNameForPickup'?: boolean;
    /**
    * Mask your customers phone numbers printed on receipts and reduce the amout of personally identifiable customer information that is exposed.
    */
    'GdprCustomerPhoneNumbers'?: boolean;
    /**
    * True if customer name required for delivery orders
    */
    'RequireCustomerNameForDelivery'?: boolean;
    /**
    * True if the customer is allowed enter custom notes with their orders
    */
    'AllowChefNotes'?: boolean;
    /**
    * True if order confirmation sms includes estimated time when order will be ready for collection
    */
    'EtaInPickupConfirmationSmsEnabled'?: boolean;
    /**
    * True if order confirmation sms includes estimated time when order will delivered
    */
    'EtaInDeliveryConfirmationSmsEnabled'?: boolean;
    /**
    * Is the Store Archived
    */
    'IsArchived'?: boolean;
    /**
    * Is the Store Published
    */
    'IsPublished'?: boolean;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Email address (visible to customers)
    */
    'EmailAddress'?: string;
    /**
    * Staff Language (used for communication with the staff)  Emails, Printouts etc
    */
    'StaffLanguage'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PhoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        },
        {
            "name": "AlwaysAppearOpen",
            "baseName": "AlwaysAppearOpen",
            "type": "boolean"
        },
        {
            "name": "PreOrderEnabled",
            "baseName": "PreOrderEnabled",
            "type": "boolean"
        },
        {
            "name": "TakeOutEnabled",
            "baseName": "TakeOutEnabled",
            "type": "boolean"
        },
        {
            "name": "TableServiceEnabled",
            "baseName": "TableServiceEnabled",
            "type": "boolean"
        },
        {
            "name": "DineInEnabled",
            "baseName": "DineInEnabled",
            "type": "boolean"
        },
        {
            "name": "AllowPreOrdersAndTableService",
            "baseName": "AllowPreOrdersAndTableService",
            "type": "boolean"
        },
        {
            "name": "PickupEnabled",
            "baseName": "PickupEnabled",
            "type": "boolean"
        },
        {
            "name": "DeliveryEnabled",
            "baseName": "DeliveryEnabled",
            "type": "boolean"
        },
        {
            "name": "CardOrderDeliveryEnabled",
            "baseName": "CardOrderDeliveryEnabled",
            "type": "boolean"
        },
        {
            "name": "CashOrdersDeliveryEnabled",
            "baseName": "CashOrdersDeliveryEnabled",
            "type": "boolean"
        },
        {
            "name": "CardOrdersPickupEnabled",
            "baseName": "CardOrdersPickupEnabled",
            "type": "boolean"
        },
        {
            "name": "CashOrdersPickupEnabled",
            "baseName": "CashOrdersPickupEnabled",
            "type": "boolean"
        },
        {
            "name": "TipsEnabled",
            "baseName": "TipsEnabled",
            "type": "boolean"
        },
        {
            "name": "AutomaticallyAcceptOrders",
            "baseName": "AutomaticallyAcceptOrders",
            "type": "boolean"
        },
        {
            "name": "OpenForDelivery",
            "baseName": "OpenForDelivery",
            "type": "boolean"
        },
        {
            "name": "OpenForPickup",
            "baseName": "OpenForPickup",
            "type": "boolean"
        },
        {
            "name": "MinimumPickupOrderAmount",
            "baseName": "MinimumPickupOrderAmount",
            "type": "number"
        },
        {
            "name": "RequireCustomerNameForPickup",
            "baseName": "RequireCustomerNameForPickup",
            "type": "boolean"
        },
        {
            "name": "GdprCustomerPhoneNumbers",
            "baseName": "GdprCustomerPhoneNumbers",
            "type": "boolean"
        },
        {
            "name": "RequireCustomerNameForDelivery",
            "baseName": "RequireCustomerNameForDelivery",
            "type": "boolean"
        },
        {
            "name": "AllowChefNotes",
            "baseName": "AllowChefNotes",
            "type": "boolean"
        },
        {
            "name": "EtaInPickupConfirmationSmsEnabled",
            "baseName": "EtaInPickupConfirmationSmsEnabled",
            "type": "boolean"
        },
        {
            "name": "EtaInDeliveryConfirmationSmsEnabled",
            "baseName": "EtaInDeliveryConfirmationSmsEnabled",
            "type": "boolean"
        },
        {
            "name": "IsArchived",
            "baseName": "IsArchived",
            "type": "boolean"
        },
        {
            "name": "IsPublished",
            "baseName": "IsPublished",
            "type": "boolean"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "EmailAddress",
            "baseName": "EmailAddress",
            "type": "string"
        },
        {
            "name": "StaffLanguage",
            "baseName": "StaffLanguage",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreBase.attributeTypeMap;
    }
}

/**
* Store Business Hours Override Created
*/
export class StoreBusinessHoursOverrideCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which deleted delivery zone for this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Business Hours Override
    */
    'BusinessHoursOverride'?: BusinessHoursOverride;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "BusinessHoursOverride",
            "baseName": "BusinessHoursOverride",
            "type": "BusinessHoursOverride"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreBusinessHoursOverrideCreatedEvent.attributeTypeMap;
    }
}

/**
* Store Business Hours Override Deleted
*/
export class StoreBusinessHoursOverrideDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which deleted delivery zone for this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Business Hours Override
    */
    'BusinessHoursOverride'?: BusinessHoursOverride;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "BusinessHoursOverride",
            "baseName": "BusinessHoursOverride",
            "type": "BusinessHoursOverride"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreBusinessHoursOverrideDeletedEvent.attributeTypeMap;
    }
}

/**
* Store campaign start time
*/
export class StoreCampaignStartTime {
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Campaign start time in Utc
    */
    'TsStart'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "TsStart",
            "baseName": "TsStart",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return StoreCampaignStartTime.attributeTypeMap;
    }
}

/**
* Represents a store that is assigned to a Sales Channel
*/
export class StoreChannelAssignment {
    /**
    * Channel ID
    */
    'ChannelId'?: number;
    /**
    * Store ID
    */
    'StoreId'?: number;
    /**
    * Store Name
    */
    'StoreName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ChannelId",
            "baseName": "ChannelId",
            "type": "number"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreName",
            "baseName": "StoreName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreChannelAssignment.attributeTypeMap;
    }
}

/**
* Describes an ID mapping between Flipdish Store and Channel Store
*/
export class StoreChannelStoreMapping {
    /**
    * Channel Id
    */
    'ChannelId'?: number;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Channel Store Id
    */
    'ChannelStoreId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ChannelId",
            "baseName": "ChannelId",
            "type": "number"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "ChannelStoreId",
            "baseName": "ChannelStoreId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreChannelStoreMapping.attributeTypeMap;
    }
}

/**
* Settings for cloning a store
*/
export class StoreCloneSettings {
    /**
    * If specified will clone to a specific store group, otherwise will clone to the store group of the Store which is being cloned
    */
    'TargetStoreGroupId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TargetStoreGroupId",
            "baseName": "TargetStoreGroupId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StoreCloneSettings.attributeTypeMap;
    }
}

export class StoreConfig {
    /**
    * True if the store accepts pickup orders
    */
    'PickupEnabled'?: boolean;
    /**
    * True if the store has a Bank Account attached
    */
    'BankAccountAttached'?: boolean;
    /**
    * True if the store is assigned to a Menu
    */
    'MenuAssigned'?: boolean;
    /**
    * True if the store has a valid Address
    */
    'HasFullAddress'?: boolean;
    /**
    * True if the store has Pickup hours
    */
    'PickupHours'?: boolean;
    /**
    * Is the Store Published
    */
    'IsPublished'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PickupEnabled",
            "baseName": "PickupEnabled",
            "type": "boolean"
        },
        {
            "name": "BankAccountAttached",
            "baseName": "BankAccountAttached",
            "type": "boolean"
        },
        {
            "name": "MenuAssigned",
            "baseName": "MenuAssigned",
            "type": "boolean"
        },
        {
            "name": "HasFullAddress",
            "baseName": "HasFullAddress",
            "type": "boolean"
        },
        {
            "name": "PickupHours",
            "baseName": "PickupHours",
            "type": "boolean"
        },
        {
            "name": "IsPublished",
            "baseName": "IsPublished",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return StoreConfig.attributeTypeMap;
    }
}

/**
* Store Create Base
*/
export class StoreCreateBase {
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Email address (visible to customers)
    */
    'EmailAddress'?: string;
    /**
    * Staff Language (used for communication with the staff)  Emails, Printouts etc
    */
    'StaffLanguage'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "EmailAddress",
            "baseName": "EmailAddress",
            "type": "string"
        },
        {
            "name": "StaffLanguage",
            "baseName": "StaffLanguage",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreCreateBase.attributeTypeMap;
    }
}

/**
* Store Created Event
*/
export class StoreCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * User which created this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Created Store
    */
    'Store'?: Store;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Store",
            "baseName": "Store",
            "type": "Store"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreCreatedEvent.attributeTypeMap;
    }
}

/**
* Store Data Point
*/
export class StoreDataPoint {
    /**
    * Day
    */
    'Day'?: Date;
    /**
    * Value for the day
    */
    'Value'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Day",
            "baseName": "Day",
            "type": "Date"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StoreDataPoint.attributeTypeMap;
    }
}

/**
* Store Deleted Event
*/
export class StoreDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which deleted this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Deleted Store
    */
    'Store'?: Store;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Store",
            "baseName": "Store",
            "type": "Store"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreDeletedEvent.attributeTypeMap;
    }
}

/**
* Store delivery zone fee config
*/
export class StoreDeliveryZoneFeeConfig {
    /**
    * ID of the delivery zone this fee corresponds to
    */
    'DeliveryZoneId'?: number;
    /**
    * Fee for delivery within this zone
    */
    'Fee'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeliveryZoneId",
            "baseName": "DeliveryZoneId",
            "type": "number"
        },
        {
            "name": "Fee",
            "baseName": "Fee",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StoreDeliveryZoneFeeConfig.attributeTypeMap;
    }
}

/**
* Request to update store delivery zone fee config
*/
export class StoreDeliveryZoneFeeConfigUpdateRequest {
    /**
    * Delivery zone fees to update
    */
    'DeliveryZoneFees'?: Array<StoreDeliveryZoneFeeConfig>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeliveryZoneFees",
            "baseName": "DeliveryZoneFees",
            "type": "Array<StoreDeliveryZoneFeeConfig>"
        }    ];

    static getAttributeTypeMap() {
        return StoreDeliveryZoneFeeConfigUpdateRequest.attributeTypeMap;
    }
}

/**
* Store end of day report
*/
export class StoreEndOfDayReport {
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store name
    */
    'StoreName'?: string;
    /**
    * Currency
    */
    'Currency'?: StoreEndOfDayReport.CurrencyEnum;
    /**
    * Order Count
    */
    'OrderCount'?: number;
    /**
    * Order Value
    */
    'OrderValue'?: number;
    /**
    * Order Value Excluding Delivery Fees
    */
    'OrderValueExcludingDeliveryFees'?: number;
    /**
    * Collection Order Count
    */
    'CollectionOrderCount'?: number;
    /**
    * Collection Cash Order Count
    */
    'CollectionCashOrderCount'?: number;
    /**
    * Collection Paid Online Order Count
    */
    'CollectionPaidOnlineOrderCount'?: number;
    /**
    * Collection Order Value
    */
    'CollectionOrderValue'?: number;
    /**
    * Collection Cash Order Value
    */
    'CollectionCashOrderValue'?: number;
    /**
    * Collection Paid Online Order Value
    */
    'CollectionPaidOnlineOrderValue'?: number;
    /**
    * Delivery Order Count
    */
    'DeliveryOrderCount'?: number;
    /**
    * Delivery Cash Order Count
    */
    'DeliveryCashOrderCount'?: number;
    /**
    * Delivery Paid Online Order Count
    */
    'DeliveryPaidOnlineOrderCount'?: number;
    /**
    * Delivery Order Value
    */
    'DeliveryOrderValue'?: number;
    /**
    * Delivery Cash Order Value
    */
    'DeliveryCashOrderValue'?: number;
    /**
    * Delivery Paid Online Order Value
    */
    'DeliveryPaidOnlineOrderValue'?: number;
    /**
    * Paid Online Order Count
    */
    'PaidOnlineOrderCount'?: number;
    /**
    * Cash Order Count
    */
    'CashOrderCount'?: number;
    /**
    * Paid Online Order Value
    */
    'PaidOnlineOrderValue'?: number;
    /**
    * Cash Order Value
    */
    'CashOrderValue'?: number;
    /**
    * Paid Online Order Value Excluding Delivery Fees
    */
    'PaidOnlineOrderValueExcludingDeliveryFees'?: number;
    /**
    * Cash Order Value Excluding Delivery Fees
    */
    'CashOrderValueExcludingDeliveryFees'?: number;
    /**
    * Start Time
    */
    'StartTime'?: Date;
    /**
    * End Time
    */
    'EndTime'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreName",
            "baseName": "StoreName",
            "type": "string"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "StoreEndOfDayReport.CurrencyEnum"
        },
        {
            "name": "OrderCount",
            "baseName": "OrderCount",
            "type": "number"
        },
        {
            "name": "OrderValue",
            "baseName": "OrderValue",
            "type": "number"
        },
        {
            "name": "OrderValueExcludingDeliveryFees",
            "baseName": "OrderValueExcludingDeliveryFees",
            "type": "number"
        },
        {
            "name": "CollectionOrderCount",
            "baseName": "CollectionOrderCount",
            "type": "number"
        },
        {
            "name": "CollectionCashOrderCount",
            "baseName": "CollectionCashOrderCount",
            "type": "number"
        },
        {
            "name": "CollectionPaidOnlineOrderCount",
            "baseName": "CollectionPaidOnlineOrderCount",
            "type": "number"
        },
        {
            "name": "CollectionOrderValue",
            "baseName": "CollectionOrderValue",
            "type": "number"
        },
        {
            "name": "CollectionCashOrderValue",
            "baseName": "CollectionCashOrderValue",
            "type": "number"
        },
        {
            "name": "CollectionPaidOnlineOrderValue",
            "baseName": "CollectionPaidOnlineOrderValue",
            "type": "number"
        },
        {
            "name": "DeliveryOrderCount",
            "baseName": "DeliveryOrderCount",
            "type": "number"
        },
        {
            "name": "DeliveryCashOrderCount",
            "baseName": "DeliveryCashOrderCount",
            "type": "number"
        },
        {
            "name": "DeliveryPaidOnlineOrderCount",
            "baseName": "DeliveryPaidOnlineOrderCount",
            "type": "number"
        },
        {
            "name": "DeliveryOrderValue",
            "baseName": "DeliveryOrderValue",
            "type": "number"
        },
        {
            "name": "DeliveryCashOrderValue",
            "baseName": "DeliveryCashOrderValue",
            "type": "number"
        },
        {
            "name": "DeliveryPaidOnlineOrderValue",
            "baseName": "DeliveryPaidOnlineOrderValue",
            "type": "number"
        },
        {
            "name": "PaidOnlineOrderCount",
            "baseName": "PaidOnlineOrderCount",
            "type": "number"
        },
        {
            "name": "CashOrderCount",
            "baseName": "CashOrderCount",
            "type": "number"
        },
        {
            "name": "PaidOnlineOrderValue",
            "baseName": "PaidOnlineOrderValue",
            "type": "number"
        },
        {
            "name": "CashOrderValue",
            "baseName": "CashOrderValue",
            "type": "number"
        },
        {
            "name": "PaidOnlineOrderValueExcludingDeliveryFees",
            "baseName": "PaidOnlineOrderValueExcludingDeliveryFees",
            "type": "number"
        },
        {
            "name": "CashOrderValueExcludingDeliveryFees",
            "baseName": "CashOrderValueExcludingDeliveryFees",
            "type": "number"
        },
        {
            "name": "StartTime",
            "baseName": "StartTime",
            "type": "Date"
        },
        {
            "name": "EndTime",
            "baseName": "EndTime",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return StoreEndOfDayReport.attributeTypeMap;
    }
}

export namespace StoreEndOfDayReport {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* 
*/
export class StoreFeeConfig {
    /**
    * 
    */
    'FeeConfigId'?: number;
    /**
    * 
    */
    'StoreId'?: number;
    /**
    * 
    */
    'StartTime'?: Date;
    /**
    * 
    */
    'PercentFeeCardOrders'?: number;
    /**
    * 
    */
    'PercentFeeCashOrders'?: number;
    /**
    * 
    */
    'PercentFeeCardOrdersWeb'?: number;
    /**
    * 
    */
    'PercentFeeCashOrdersWeb'?: number;
    /**
    * 
    */
    'PercentFeeCardOrdersKiosk'?: number;
    /**
    * 
    */
    'PercentFeeCashOrdersKiosk'?: number;
    /**
    * 
    */
    'FixedFeeCardOrdersKiosk'?: number;
    /**
    * 
    */
    'FixedFeeCashOrdersKiosk'?: number;
    /**
    * 
    */
    'PercentFeeCardOrdersKioskChargedToCustomerIncludingVat'?: number;
    /**
    * 
    */
    'FixedFeeCardOrdersKioskChargedToCustomerIncludingVat'?: number;
    /**
    * 
    */
    'PercentFeeCashOrdersKioskChargedToCustomerIncludingVat'?: number;
    /**
    * 
    */
    'FixedFeeCashOrdersKioskChargedToCustomerIncludingVat'?: number;
    /**
    * 
    */
    'FixedFeeCardOrders'?: number;
    /**
    * 
    */
    'FixedFeeCashOrders'?: number;
    /**
    * 
    */
    'PercentFeeCardOrdersChargedToCustomerIncludingVat'?: number;
    /**
    * 
    */
    'FixedFeeCardOrdersChargedToCustomerIncludingVat'?: number;
    /**
    * 
    */
    'PercentFeeCashOrdersChargedToCustomerIncludingVat'?: number;
    /**
    * 
    */
    'FixedFeeCashOrdersChargedToCustomerIncludingVat'?: number;
    /**
    * Gets or sets the percent fee tips.
    */
    'PercentFeeTips'?: number;
    /**
    * Gets or sets the percent fee tips for collection.
    */
    'PercentFeeTipsCollection'?: number;
    /**
    * Gets or sets the percent fee tips for delivery.
    */
    'PercentFeeTipsDelivery'?: number;
    /**
    * Gets or sets the tax rate percent.
    */
    'TaxRatePercent'?: number;
    /**
    * Gets or sets the percent fee card orders location service.
    */
    'PercentFeeCardOrdersLocationService'?: number;
    /**
    * Gets or sets the percent fee cash orders location service.
    */
    'PercentFeeCashOrdersLocationService'?: number;
    /**
    * Gets or sets the fixed fee card orders location service.
    */
    'FixedFeeCardOrdersLocationService'?: number;
    /**
    * Gets or sets the fixed fee cash orders location service.
    */
    'FixedFeeCashOrdersLocationService'?: number;
    /**
    * Gets or sets the percent fee card orders location service charged to customer including vat.
    */
    'PercentFeeCardOrdersLocationServiceChargedToCustomerIncludingVat'?: number;
    /**
    * Gets or sets the percent fee cash orders location service charged to customer including vat.
    */
    'PercentFeeCashOrdersLocationServiceChargedToCustomerIncludingVat'?: number;
    /**
    * Gets or sets the fixed fee card orders location service charged to customer including vat.
    */
    'FixedFeeCardOrdersLocationServiceChargedToCustomerIncludingVat'?: number;
    /**
    * Gets or sets the fixed fee cash orders location service charged to customer including vat.
    */
    'FixedFeeCashOrdersLocationServiceChargedToCustomerIncludingVat'?: number;
    /**
    * Gets or sets the percent fee card orders ingest.
    */
    'PercentFeeCardOrdersIngest'?: number;
    /**
    * Gets or sets the percent fee cash orders ingest.
    */
    'PercentFeeCashOrdersIngest'?: number;
    /**
    * Gets or sets the fixed fee card orders ingest.
    */
    'FixedFeeCardOrdersIngest'?: number;
    /**
    * Gets or sets the fixed fee cash orders ingest.
    */
    'FixedFeeCashOrdersIngest'?: number;
    /**
    * Gets or sets the percent fee for delivery orders.
    */
    'PercentFeeDelivery'?: number;
    /**
    * Gets or sets the fixed fee for delivery orders.
    */
    'FixedFeeDelivery'?: number;
    /**
    * Gets or sets the percent fee for POS transactions.
    */
    'PercentFeeCardPosTransaction'?: number;
    /**
    * Gets or sets the fixed fee for POS transactions.
    */
    'FixedFeeCardPosTransaction'?: number;
    /**
    * Additional percentage fee charged on orders submitted through Order With Google
    */
    'PercentFeeOrderWithGoogle'?: number;
    /**
    * Additional fixed fee charged on orders submitted through Order With Google
    */
    'FixedFeeOrderWithGoogle'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "FeeConfigId",
            "baseName": "FeeConfigId",
            "type": "number"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StartTime",
            "baseName": "StartTime",
            "type": "Date"
        },
        {
            "name": "PercentFeeCardOrders",
            "baseName": "PercentFeeCardOrders",
            "type": "number"
        },
        {
            "name": "PercentFeeCashOrders",
            "baseName": "PercentFeeCashOrders",
            "type": "number"
        },
        {
            "name": "PercentFeeCardOrdersWeb",
            "baseName": "PercentFeeCardOrdersWeb",
            "type": "number"
        },
        {
            "name": "PercentFeeCashOrdersWeb",
            "baseName": "PercentFeeCashOrdersWeb",
            "type": "number"
        },
        {
            "name": "PercentFeeCardOrdersKiosk",
            "baseName": "PercentFeeCardOrdersKiosk",
            "type": "number"
        },
        {
            "name": "PercentFeeCashOrdersKiosk",
            "baseName": "PercentFeeCashOrdersKiosk",
            "type": "number"
        },
        {
            "name": "FixedFeeCardOrdersKiosk",
            "baseName": "FixedFeeCardOrdersKiosk",
            "type": "number"
        },
        {
            "name": "FixedFeeCashOrdersKiosk",
            "baseName": "FixedFeeCashOrdersKiosk",
            "type": "number"
        },
        {
            "name": "PercentFeeCardOrdersKioskChargedToCustomerIncludingVat",
            "baseName": "PercentFeeCardOrdersKioskChargedToCustomerIncludingVat",
            "type": "number"
        },
        {
            "name": "FixedFeeCardOrdersKioskChargedToCustomerIncludingVat",
            "baseName": "FixedFeeCardOrdersKioskChargedToCustomerIncludingVat",
            "type": "number"
        },
        {
            "name": "PercentFeeCashOrdersKioskChargedToCustomerIncludingVat",
            "baseName": "PercentFeeCashOrdersKioskChargedToCustomerIncludingVat",
            "type": "number"
        },
        {
            "name": "FixedFeeCashOrdersKioskChargedToCustomerIncludingVat",
            "baseName": "FixedFeeCashOrdersKioskChargedToCustomerIncludingVat",
            "type": "number"
        },
        {
            "name": "FixedFeeCardOrders",
            "baseName": "FixedFeeCardOrders",
            "type": "number"
        },
        {
            "name": "FixedFeeCashOrders",
            "baseName": "FixedFeeCashOrders",
            "type": "number"
        },
        {
            "name": "PercentFeeCardOrdersChargedToCustomerIncludingVat",
            "baseName": "PercentFeeCardOrdersChargedToCustomerIncludingVat",
            "type": "number"
        },
        {
            "name": "FixedFeeCardOrdersChargedToCustomerIncludingVat",
            "baseName": "FixedFeeCardOrdersChargedToCustomerIncludingVat",
            "type": "number"
        },
        {
            "name": "PercentFeeCashOrdersChargedToCustomerIncludingVat",
            "baseName": "PercentFeeCashOrdersChargedToCustomerIncludingVat",
            "type": "number"
        },
        {
            "name": "FixedFeeCashOrdersChargedToCustomerIncludingVat",
            "baseName": "FixedFeeCashOrdersChargedToCustomerIncludingVat",
            "type": "number"
        },
        {
            "name": "PercentFeeTips",
            "baseName": "PercentFeeTips",
            "type": "number"
        },
        {
            "name": "PercentFeeTipsCollection",
            "baseName": "PercentFeeTipsCollection",
            "type": "number"
        },
        {
            "name": "PercentFeeTipsDelivery",
            "baseName": "PercentFeeTipsDelivery",
            "type": "number"
        },
        {
            "name": "TaxRatePercent",
            "baseName": "TaxRatePercent",
            "type": "number"
        },
        {
            "name": "PercentFeeCardOrdersLocationService",
            "baseName": "PercentFeeCardOrdersLocationService",
            "type": "number"
        },
        {
            "name": "PercentFeeCashOrdersLocationService",
            "baseName": "PercentFeeCashOrdersLocationService",
            "type": "number"
        },
        {
            "name": "FixedFeeCardOrdersLocationService",
            "baseName": "FixedFeeCardOrdersLocationService",
            "type": "number"
        },
        {
            "name": "FixedFeeCashOrdersLocationService",
            "baseName": "FixedFeeCashOrdersLocationService",
            "type": "number"
        },
        {
            "name": "PercentFeeCardOrdersLocationServiceChargedToCustomerIncludingVat",
            "baseName": "PercentFeeCardOrdersLocationServiceChargedToCustomerIncludingVat",
            "type": "number"
        },
        {
            "name": "PercentFeeCashOrdersLocationServiceChargedToCustomerIncludingVat",
            "baseName": "PercentFeeCashOrdersLocationServiceChargedToCustomerIncludingVat",
            "type": "number"
        },
        {
            "name": "FixedFeeCardOrdersLocationServiceChargedToCustomerIncludingVat",
            "baseName": "FixedFeeCardOrdersLocationServiceChargedToCustomerIncludingVat",
            "type": "number"
        },
        {
            "name": "FixedFeeCashOrdersLocationServiceChargedToCustomerIncludingVat",
            "baseName": "FixedFeeCashOrdersLocationServiceChargedToCustomerIncludingVat",
            "type": "number"
        },
        {
            "name": "PercentFeeCardOrdersIngest",
            "baseName": "PercentFeeCardOrdersIngest",
            "type": "number"
        },
        {
            "name": "PercentFeeCashOrdersIngest",
            "baseName": "PercentFeeCashOrdersIngest",
            "type": "number"
        },
        {
            "name": "FixedFeeCardOrdersIngest",
            "baseName": "FixedFeeCardOrdersIngest",
            "type": "number"
        },
        {
            "name": "FixedFeeCashOrdersIngest",
            "baseName": "FixedFeeCashOrdersIngest",
            "type": "number"
        },
        {
            "name": "PercentFeeDelivery",
            "baseName": "PercentFeeDelivery",
            "type": "number"
        },
        {
            "name": "FixedFeeDelivery",
            "baseName": "FixedFeeDelivery",
            "type": "number"
        },
        {
            "name": "PercentFeeCardPosTransaction",
            "baseName": "PercentFeeCardPosTransaction",
            "type": "number"
        },
        {
            "name": "FixedFeeCardPosTransaction",
            "baseName": "FixedFeeCardPosTransaction",
            "type": "number"
        },
        {
            "name": "PercentFeeOrderWithGoogle",
            "baseName": "PercentFeeOrderWithGoogle",
            "type": "number"
        },
        {
            "name": "FixedFeeOrderWithGoogle",
            "baseName": "FixedFeeOrderWithGoogle",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StoreFeeConfig.attributeTypeMap;
    }
}

/**
* Fee Config Updated Event
*/
export class StoreFeeConfigUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which updated this store address
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Diff between before and after
    */
    'Changes'?: string;
    /**
    * Store fee config
    */
    'StoreFeeConfig'?: StoreFeeConfig;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Changes",
            "baseName": "Changes",
            "type": "string"
        },
        {
            "name": "StoreFeeConfig",
            "baseName": "StoreFeeConfig",
            "type": "StoreFeeConfig"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreFeeConfigUpdatedEvent.attributeTypeMap;
    }
}

/**
* Store Group
*/
export class StoreGroup {
    /**
    * Unique Store Group Identifier
    */
    'StoreGroupId'?: number;
    /**
    * Store Group rating
    */
    'GeneralRating'?: number;
    /**
    * Store Group rating count
    */
    'GeneralRatingCount'?: number;
    /**
    * Store Group Name
    */
    'Name'?: string;
    /**
    * Currency used by the stores in this group
    */
    'Currency'?: StoreGroup.CurrencyEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "GeneralRating",
            "baseName": "GeneralRating",
            "type": "number"
        },
        {
            "name": "GeneralRatingCount",
            "baseName": "GeneralRatingCount",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "StoreGroup.CurrencyEnum"
        }    ];

    static getAttributeTypeMap() {
        return StoreGroup.attributeTypeMap;
    }
}

export namespace StoreGroup {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Update Store Group
*/
export class StoreGroupBase {
    /**
    * Store Group Name
    */
    'Name'?: string;
    /**
    * Currency used by the stores in this group
    */
    'Currency'?: StoreGroupBase.CurrencyEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "StoreGroupBase.CurrencyEnum"
        }    ];

    static getAttributeTypeMap() {
        return StoreGroupBase.attributeTypeMap;
    }
}

export namespace StoreGroupBase {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Store Group Created Event
*/
export class StoreGroupCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which created this store group
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Created store group
    */
    'StoreGroup'?: StoreGroup;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreGroup",
            "baseName": "StoreGroup",
            "type": "StoreGroup"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreGroupCreatedEvent.attributeTypeMap;
    }
}

/**
* Store Group Deleted Event
*/
export class StoreGroupDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which deleted this store group
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Deleted store group
    */
    'StoreGroup'?: StoreGroup;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreGroup",
            "baseName": "StoreGroup",
            "type": "StoreGroup"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreGroupDeletedEvent.attributeTypeMap;
    }
}

/**
* Store Group Extended
*/
export class StoreGroupExtended {
    /**
    * Delivery Menu Message
    */
    'DeliveryMenuMessage'?: string;
    /**
    * Pickup Menu Message
    */
    'PickupMenuMessage'?: string;
    /**
    * Total Amount of Stores
    */
    'TotalStores'?: number;
    /**
    * Grouped store coordinates
    */
    'GroupedCoordinates'?: Array<GroupedCoordinates>;
    /**
    * Store Headers associated with Store Group
    */
    'StoreHeaders'?: Array<StoreHeader>;
    /**
    * Unique Store Group Identifier
    */
    'StoreGroupId'?: number;
    /**
    * Store Group rating
    */
    'GeneralRating'?: number;
    /**
    * Store Group rating count
    */
    'GeneralRatingCount'?: number;
    /**
    * Store Group Name
    */
    'Name'?: string;
    /**
    * Currency used by the stores in this group
    */
    'Currency'?: StoreGroupExtended.CurrencyEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeliveryMenuMessage",
            "baseName": "DeliveryMenuMessage",
            "type": "string"
        },
        {
            "name": "PickupMenuMessage",
            "baseName": "PickupMenuMessage",
            "type": "string"
        },
        {
            "name": "TotalStores",
            "baseName": "TotalStores",
            "type": "number"
        },
        {
            "name": "GroupedCoordinates",
            "baseName": "GroupedCoordinates",
            "type": "Array<GroupedCoordinates>"
        },
        {
            "name": "StoreHeaders",
            "baseName": "StoreHeaders",
            "type": "Array<StoreHeader>"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "GeneralRating",
            "baseName": "GeneralRating",
            "type": "number"
        },
        {
            "name": "GeneralRatingCount",
            "baseName": "GeneralRatingCount",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "StoreGroupExtended.CurrencyEnum"
        }    ];

    static getAttributeTypeMap() {
        return StoreGroupExtended.attributeTypeMap;
    }
}

export namespace StoreGroupExtended {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Store Group Updated Event
*/
export class StoreGroupUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which updated this store group
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Updated store group
    */
    'StoreGroup'?: StoreGroup;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreGroup",
            "baseName": "StoreGroup",
            "type": "StoreGroup"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreGroupUpdatedEvent.attributeTypeMap;
    }
}

/**
* Represents the most basic store information, used mostly for searches
*/
export class StoreHeader {
    /**
    * Store identifier
    */
    'StoreId'?: number;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Name
    */
    'Category'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Category",
            "baseName": "Category",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreHeader.attributeTypeMap;
    }
}

export class StoreItemHeader {
    'StoreId'?: number;
    'Name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreItemHeader.attributeTypeMap;
    }
}

/**
* Store Kiosk Settings
*/
export class StoreKioskSetting {
    /**
    * Kiosk setting id
    */
    'KioskSettingId'?: number;
    /**
    * Store kiosk name
    */
    'KioskName'?: string;
    /**
    * Require customer name flag
    */
    'RequireCustomerName'?: boolean;
    /**
    * Require customer phone number flag
    */
    'RequireCustomerPhoneNumber'?: boolean;
    /**
    * Request customer phone number flag (Option to Skip)
    */
    'RequestCustomerPhoneNumber'?: boolean;
    /**
    * Request table number flag
    */
    'RequestTableNumber'?: boolean;
    /**
    * Offer Dine-In/Takeaway option flag
    */
    'OfferDineInOrTakeawayOption'?: boolean;
    /**
    * Physical restaurant id
    */
    'PhysicalRestaurantId'?: number;
    /**
    * Hydra config id
    */
    'HydraConfigId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "KioskSettingId",
            "baseName": "KioskSettingId",
            "type": "number"
        },
        {
            "name": "KioskName",
            "baseName": "KioskName",
            "type": "string"
        },
        {
            "name": "RequireCustomerName",
            "baseName": "RequireCustomerName",
            "type": "boolean"
        },
        {
            "name": "RequireCustomerPhoneNumber",
            "baseName": "RequireCustomerPhoneNumber",
            "type": "boolean"
        },
        {
            "name": "RequestCustomerPhoneNumber",
            "baseName": "RequestCustomerPhoneNumber",
            "type": "boolean"
        },
        {
            "name": "RequestTableNumber",
            "baseName": "RequestTableNumber",
            "type": "boolean"
        },
        {
            "name": "OfferDineInOrTakeawayOption",
            "baseName": "OfferDineInOrTakeawayOption",
            "type": "boolean"
        },
        {
            "name": "PhysicalRestaurantId",
            "baseName": "PhysicalRestaurantId",
            "type": "number"
        },
        {
            "name": "HydraConfigId",
            "baseName": "HydraConfigId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StoreKioskSetting.attributeTypeMap;
    }
}

/**
* Store kiosk setting updated
*/
export class StoreKioskSettingUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * User which deleted delivery zone for this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store kiosk settings
    */
    'StoreKioskSetting'?: StoreKioskSetting;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreKioskSetting",
            "baseName": "StoreKioskSetting",
            "type": "StoreKioskSetting"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreKioskSettingUpdatedEvent.attributeTypeMap;
    }
}

/**
* Store id and name
*/
export class StoreListItem {
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store Name
    */
    'StoreName'?: string;
    /**
    * Store Group Id
    */
    'StoreGroupId'?: number;
    /**
    * Store Group Name
    */
    'StoreGroupName'?: string;
    /**
    * Store has loyalty campaign
    */
    'HasLoyaltyCampaign'?: boolean;
    /**
    * Store has retention campaign
    */
    'HasRetentionCampaign'?: boolean;
    /**
    * Is Published store
    */
    'IsPublished'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreName",
            "baseName": "StoreName",
            "type": "string"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "StoreGroupName",
            "baseName": "StoreGroupName",
            "type": "string"
        },
        {
            "name": "HasLoyaltyCampaign",
            "baseName": "HasLoyaltyCampaign",
            "type": "boolean"
        },
        {
            "name": "HasRetentionCampaign",
            "baseName": "HasRetentionCampaign",
            "type": "boolean"
        },
        {
            "name": "IsPublished",
            "baseName": "IsPublished",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return StoreListItem.attributeTypeMap;
    }
}

/**
* Store logo created
*/
export class StoreLogoCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * ID of store that the logo has been added to
    */
    'StoreId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who added the logo
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreLogoCreatedEvent.attributeTypeMap;
    }
}

/**
* Store logo deleted
*/
export class StoreLogoDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * ID of store that the logo has been added to
    */
    'StoreId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who removed the logo
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreLogoDeletedEvent.attributeTypeMap;
    }
}

/**
* Store logo updated
*/
export class StoreLogoUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * ID of store that the logo has been added to
    */
    'StoreId'?: number;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who updated the logo
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreLogoUpdatedEvent.attributeTypeMap;
    }
}

/**
* Menu Assigned To Store Event
*/
export class StoreMenuAssignedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * MenuId Id
    */
    'MenuId'?: number;
    /**
    * User who assigned the menu to the store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreMenuAssignedEvent.attributeTypeMap;
    }
}

/**
* Store note
*/
export class StoreNote {
    /**
    * User identifier
    */
    'UserId'?: number;
    /**
    * Create time
    */
    'CreateTime'?: Date;
    /**
    * Note
    */
    'Note'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "UserId",
            "baseName": "UserId",
            "type": "number"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Note",
            "baseName": "Note",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreNote.attributeTypeMap;
    }
}

/**
* Store Opening Hours Updated Event
*/
export class StoreOpeningHoursUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which updated opening hours for this store
    */
    'User'?: UserEventInfo;
    /**
    * Type of opening hours Delivery / Pickup
    */
    'DeliveryType'?: StoreOpeningHoursUpdatedEvent.DeliveryTypeEnum;
    /**
    * The period that was updated
    */
    'BusinessHoursPeriodOld'?: BusinessHoursPeriod;
    /**
    * The new values of the period
    */
    'BusinessHoursPeriod'?: BusinessHoursPeriod;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "DeliveryType",
            "baseName": "DeliveryType",
            "type": "StoreOpeningHoursUpdatedEvent.DeliveryTypeEnum"
        },
        {
            "name": "BusinessHoursPeriodOld",
            "baseName": "BusinessHoursPeriodOld",
            "type": "BusinessHoursPeriod"
        },
        {
            "name": "BusinessHoursPeriod",
            "baseName": "BusinessHoursPeriod",
            "type": "BusinessHoursPeriod"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreOpeningHoursUpdatedEvent.attributeTypeMap;
    }
}

export namespace StoreOpeningHoursUpdatedEvent {
    export enum DeliveryTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
}
/**
* Represents one store's order capacity configuration
*/
export class StoreOrderCapacityConfig {
    /**
    * Store identifier
    */
    'StoreId'?: number;
    /**
    * Signifies whether the order capacity configuration is for Delivery / Pickup
    */
    'DeliveryType'?: StoreOrderCapacityConfig.DeliveryTypeEnum;
    /**
    * Store Interval - time between orders, e.g. 10 minutes between each order time available to customer
    */
    'StoreIntervalInMinutes'?: number;
    /**
    * Order capacity periods
    */
    'OrderCapacityPeriods'?: Array<StoreOrderCapacityPeriod>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "DeliveryType",
            "baseName": "DeliveryType",
            "type": "StoreOrderCapacityConfig.DeliveryTypeEnum"
        },
        {
            "name": "StoreIntervalInMinutes",
            "baseName": "StoreIntervalInMinutes",
            "type": "number"
        },
        {
            "name": "OrderCapacityPeriods",
            "baseName": "OrderCapacityPeriods",
            "type": "Array<StoreOrderCapacityPeriod>"
        }    ];

    static getAttributeTypeMap() {
        return StoreOrderCapacityConfig.attributeTypeMap;
    }
}

export namespace StoreOrderCapacityConfig {
    export enum DeliveryTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
}
/**
* Represents one store's order capacity configuration edit
*/
export class StoreOrderCapacityConfigEditModel {
    /**
    * Order capacity periods
    */
    'OrderCapacityPeriods'?: Array<StoreOrderCapacityPeriod>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderCapacityPeriods",
            "baseName": "OrderCapacityPeriods",
            "type": "Array<StoreOrderCapacityPeriod>"
        }    ];

    static getAttributeTypeMap() {
        return StoreOrderCapacityConfigEditModel.attributeTypeMap;
    }
}

/**
* Represents a single order capacity period
*/
export class StoreOrderCapacityPeriod {
    /**
    * The maximum number of orders per each store order interval in this order capacity period.  E.g. for a period from 9:00 till 11:00, if the store's interval is 10 minutes, and MaxOrderNumberPerStoreInterval is set to 5,  it means that within each 10-minute interval between 9:00 and 11:00 (i.e. 9:00-9:10, 9:10-9:20, .. , 10:50-11:00) it will be possible to  request at most 5 orders.
    */
    'MaxOrderNumberPerStoreInterval'?: number;
    /**
    * Day of the week the period pertains to
    */
    'DayOfTheWeek'?: StoreOrderCapacityPeriod.DayOfTheWeekEnum;
    /**
    * The hour the period starts at
    */
    'PeriodStartHour'?: number;
    /**
    * The minutes after the hour the period starts at
    */
    'PeriodStartMinutes'?: number;
    /**
    * The hour the period ends at
    */
    'PeriodEndHour'?: number;
    /**
    * The minutes after the hour the period ends at
    */
    'PeriodEndMinutes'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MaxOrderNumberPerStoreInterval",
            "baseName": "MaxOrderNumberPerStoreInterval",
            "type": "number"
        },
        {
            "name": "DayOfTheWeek",
            "baseName": "DayOfTheWeek",
            "type": "StoreOrderCapacityPeriod.DayOfTheWeekEnum"
        },
        {
            "name": "PeriodStartHour",
            "baseName": "PeriodStartHour",
            "type": "number"
        },
        {
            "name": "PeriodStartMinutes",
            "baseName": "PeriodStartMinutes",
            "type": "number"
        },
        {
            "name": "PeriodEndHour",
            "baseName": "PeriodEndHour",
            "type": "number"
        },
        {
            "name": "PeriodEndMinutes",
            "baseName": "PeriodEndMinutes",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StoreOrderCapacityPeriod.attributeTypeMap;
    }
}

export namespace StoreOrderCapacityPeriod {
    export enum DayOfTheWeekEnum {
        Sunday = <any> 'Sunday',
        Monday = <any> 'Monday',
        Tuesday = <any> 'Tuesday',
        Wednesday = <any> 'Wednesday',
        Thursday = <any> 'Thursday',
        Friday = <any> 'Friday',
        Saturday = <any> 'Saturday'
    }
}
/**
* Store Pre order config updated
*/
export class StorePreOrderConfigUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * User which deleted delivery zone for this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Pre Order Configuration
    */
    'PreOrderConfig'?: PreOrderConfig;
    /**
    * Old Pre Order Configuration
    */
    'OldPreOrderConfig'?: PreOrderConfig;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "PreOrderConfig",
            "baseName": "PreOrderConfig",
            "type": "PreOrderConfig"
        },
        {
            "name": "OldPreOrderConfig",
            "baseName": "OldPreOrderConfig",
            "type": "PreOrderConfig"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StorePreOrderConfigUpdatedEvent.attributeTypeMap;
    }
}

/**
* Store Published Event
*/
export class StorePublishedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which published this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Published Store
    */
    'Store'?: Store;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Store",
            "baseName": "Store",
            "type": "Store"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StorePublishedEvent.attributeTypeMap;
    }
}

/**
* Service Charge Updated Event
*/
export class StoreServiceChargeUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * User which made the update
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Service Charge Configuration
    */
    'ServiceCharge'?: ServiceCharge;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "ServiceCharge",
            "baseName": "ServiceCharge",
            "type": "ServiceCharge"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreServiceChargeUpdatedEvent.attributeTypeMap;
    }
}

/**
* Store statistics
*/
export class StoreStatistics {
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store Data Points
    */
    'Data'?: Array<StoreDataPoint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "Data",
            "baseName": "Data",
            "type": "Array<StoreDataPoint>"
        }    ];

    static getAttributeTypeMap() {
        return StoreStatistics.attributeTypeMap;
    }
}

/**
* Store summary
*/
export class StoreSummary {
    /**
    * Store identifier
    */
    'Id'?: number;
    /**
    * Store name
    */
    'Name'?: string;
    /**
    * Stores menu identifier
    */
    'MenuId'?: number;
    /**
    * Store metadata
    */
    'Metadata'?: { [key: string]: string; };
    /**
    * Currency which used by the Store
    */
    'Currency'?: StoreSummary.CurrencyEnum;
    /**
    * Latitude and longitude of the store
    */
    'Coordinates'?: Coordinates;
    /**
    * Timezone of store
    */
    'StoreTimezone'?: string;
    /**
    * Store group id of store
    */
    'StoreGroupId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "MenuId",
            "baseName": "MenuId",
            "type": "number"
        },
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "StoreSummary.CurrencyEnum"
        },
        {
            "name": "Coordinates",
            "baseName": "Coordinates",
            "type": "Coordinates"
        },
        {
            "name": "StoreTimezone",
            "baseName": "StoreTimezone",
            "type": "string"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StoreSummary.attributeTypeMap;
    }
}

export namespace StoreSummary {
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Store Tip Updated
*/
export class StoreTipUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * User which made the update
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Configuration change
    */
    'Config'?: UpdateTipConfiguration;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Config",
            "baseName": "Config",
            "type": "UpdateTipConfiguration"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreTipUpdatedEvent.attributeTypeMap;
    }
}

/**
* Store Unarchived Event
*/
export class StoreUnarchivedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which unarchived this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Unarchived Store
    */
    'Store'?: Store;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Store",
            "baseName": "Store",
            "type": "Store"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreUnarchivedEvent.attributeTypeMap;
    }
}

/**
* Store Unpublished Event
*/
export class StoreUnpublishedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which unpublished this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Unpublished Store
    */
    'Store'?: Store;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Store",
            "baseName": "Store",
            "type": "Store"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreUnpublishedEvent.attributeTypeMap;
    }
}

/**
* Store Updated Event
*/
export class StoreUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * User which updated this store
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Updated Store
    */
    'Store'?: Store;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Store",
            "baseName": "Store",
            "type": "Store"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StoreUpdatedEvent.attributeTypeMap;
    }
}

/**
* Hey
*/
export class StoreValidationConfig {
    /**
    * Store identifier
    */
    'StoreId'?: number;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Is Store Valid for Kiosk
    */
    'IsValid'?: boolean;
    /**
    * Store group Id
    */
    'StoreGroupId'?: number;
    /**
    * Store list of validations
    */
    'ConfigValidation'?: StoreConfig;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "IsValid",
            "baseName": "IsValid",
            "type": "boolean"
        },
        {
            "name": "StoreGroupId",
            "baseName": "StoreGroupId",
            "type": "number"
        },
        {
            "name": "ConfigValidation",
            "baseName": "ConfigValidation",
            "type": "StoreConfig"
        }    ];

    static getAttributeTypeMap() {
        return StoreValidationConfig.attributeTypeMap;
    }
}

export class Stream {
    'CanRead'?: boolean;
    'CanSeek'?: boolean;
    'CanTimeout'?: boolean;
    'CanWrite'?: boolean;
    'Length'?: number;
    'Position'?: number;
    'ReadTimeout'?: number;
    'WriteTimeout'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CanRead",
            "baseName": "CanRead",
            "type": "boolean"
        },
        {
            "name": "CanSeek",
            "baseName": "CanSeek",
            "type": "boolean"
        },
        {
            "name": "CanTimeout",
            "baseName": "CanTimeout",
            "type": "boolean"
        },
        {
            "name": "CanWrite",
            "baseName": "CanWrite",
            "type": "boolean"
        },
        {
            "name": "Length",
            "baseName": "Length",
            "type": "number"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "ReadTimeout",
            "baseName": "ReadTimeout",
            "type": "number"
        },
        {
            "name": "WriteTimeout",
            "baseName": "WriteTimeout",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Stream.attributeTypeMap;
    }
}

/**
* Represents a request for Stripe account link creation
*/
export class StripeAccountLinkRequest {
    /**
    * Stripe's own connected account identifier
    */
    'StripeId'?: string;
    /**
    * URL to be hit if link creation succeeds
    */
    'ReturnUrl'?: string;
    /**
    * Which information to collect from users at this stage
    */
    'Collect'?: StripeAccountLinkRequest.CollectEnum;
    /**
    * Either onboarding or edit user information
    */
    'Type'?: StripeAccountLinkRequest.TypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StripeId",
            "baseName": "StripeId",
            "type": "string"
        },
        {
            "name": "ReturnUrl",
            "baseName": "ReturnUrl",
            "type": "string"
        },
        {
            "name": "Collect",
            "baseName": "Collect",
            "type": "StripeAccountLinkRequest.CollectEnum"
        },
        {
            "name": "Type",
            "baseName": "Type",
            "type": "StripeAccountLinkRequest.TypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return StripeAccountLinkRequest.attributeTypeMap;
    }
}

export namespace StripeAccountLinkRequest {
    export enum CollectEnum {
        CurrentlyDue = <any> 'CurrentlyDue',
        EventuallyDue = <any> 'EventuallyDue'
    }
    export enum TypeEnum {
        Onboarding = <any> 'Onboarding',
        Update = <any> 'Update'
    }
}
/**
* Represents a Stripe custom connected account
*/
export class StripeConnectedAccount {
    /**
    * Flipdish connected account identifier
    */
    'FlipdishConnectedAccountId'?: number;
    /**
    * Stripe's own connected account identifier
    */
    'StripeId'?: string;
    /**
    * Id of the WhitelabelConfig the connected account is assigned to
    */
    'WhitelabelConfigId'?: number;
    /**
    * Card payments capability status (Inactive, Pending, Active, Unrequested)
    */
    'CardPaymentsStatus'?: StripeConnectedAccount.CardPaymentsStatusEnum;
    /**
    * Transfers capability status (Inactive, Pending, Active, Unrequested)
    */
    'TransfersStatus'?: StripeConnectedAccount.TransfersStatusEnum;
    /**
    * Current status of the account
    */
    'AccountStatus'?: StripeConnectedAccount.AccountStatusEnum;
    /**
    * Payouts Enabled status
    */
    'PayoutsEnabled'?: boolean;
    /**
    * Payments Enabled status
    */
    'PaymentsEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "FlipdishConnectedAccountId",
            "baseName": "FlipdishConnectedAccountId",
            "type": "number"
        },
        {
            "name": "StripeId",
            "baseName": "StripeId",
            "type": "string"
        },
        {
            "name": "WhitelabelConfigId",
            "baseName": "WhitelabelConfigId",
            "type": "number"
        },
        {
            "name": "CardPaymentsStatus",
            "baseName": "CardPaymentsStatus",
            "type": "StripeConnectedAccount.CardPaymentsStatusEnum"
        },
        {
            "name": "TransfersStatus",
            "baseName": "TransfersStatus",
            "type": "StripeConnectedAccount.TransfersStatusEnum"
        },
        {
            "name": "AccountStatus",
            "baseName": "AccountStatus",
            "type": "StripeConnectedAccount.AccountStatusEnum"
        },
        {
            "name": "PayoutsEnabled",
            "baseName": "PayoutsEnabled",
            "type": "boolean"
        },
        {
            "name": "PaymentsEnabled",
            "baseName": "PaymentsEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return StripeConnectedAccount.attributeTypeMap;
    }
}

export namespace StripeConnectedAccount {
    export enum CardPaymentsStatusEnum {
        Inactive = <any> 'Inactive',
        Pending = <any> 'Pending',
        Active = <any> 'Active',
        Unrequested = <any> 'Unrequested'
    }
    export enum TransfersStatusEnum {
        Inactive = <any> 'Inactive',
        Pending = <any> 'Pending',
        Active = <any> 'Active',
        Unrequested = <any> 'Unrequested'
    }
    export enum AccountStatusEnum {
        Disabled = <any> 'Disabled',
        Enabled = <any> 'Enabled',
        AdditionalInformationRequired = <any> 'AdditionalInformationRequired',
        PendingVerification = <any> 'PendingVerification',
        Unverified = <any> 'Unverified',
        Rejected = <any> 'Rejected',
        UpdateExternalAccount = <any> 'UpdateExternalAccount',
        PlatformPaused = <any> 'PlatformPaused'
    }
}
/**
* Represents information about a Stripe connected account associated with a bank account
*/
export class StripeConnectedAccountInfo {
    /**
    * Stripe connected account status
    */
    'AccountStatus'?: StripeConnectedAccountInfo.AccountStatusEnum;
    /**
    * Stripe connected account id
    */
    'StripeId'?: string;
    /**
    * Current status of the Card Payment capability of the account
    */
    'CardPaymentStatus'?: StripeConnectedAccountInfo.CardPaymentStatusEnum;
    /**
    * Payouts Schedule Interval
    */
    'PayoutScheduleInterval'?: StripeConnectedAccountInfo.PayoutScheduleIntervalEnum;
    /**
    * Payouts Enabled status
    */
    'PayoutsEnabled'?: boolean;
    /**
    * Flag indicating if payouts are paused
    */
    'PayoutsPaused'?: boolean;
    /**
    * Flag indicating if payments are enabled
    */
    'PaymentsEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AccountStatus",
            "baseName": "AccountStatus",
            "type": "StripeConnectedAccountInfo.AccountStatusEnum"
        },
        {
            "name": "StripeId",
            "baseName": "StripeId",
            "type": "string"
        },
        {
            "name": "CardPaymentStatus",
            "baseName": "CardPaymentStatus",
            "type": "StripeConnectedAccountInfo.CardPaymentStatusEnum"
        },
        {
            "name": "PayoutScheduleInterval",
            "baseName": "PayoutScheduleInterval",
            "type": "StripeConnectedAccountInfo.PayoutScheduleIntervalEnum"
        },
        {
            "name": "PayoutsEnabled",
            "baseName": "PayoutsEnabled",
            "type": "boolean"
        },
        {
            "name": "PayoutsPaused",
            "baseName": "PayoutsPaused",
            "type": "boolean"
        },
        {
            "name": "PaymentsEnabled",
            "baseName": "PaymentsEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return StripeConnectedAccountInfo.attributeTypeMap;
    }
}

export namespace StripeConnectedAccountInfo {
    export enum AccountStatusEnum {
        Disabled = <any> 'Disabled',
        Enabled = <any> 'Enabled',
        AdditionalInformationRequired = <any> 'AdditionalInformationRequired',
        PendingVerification = <any> 'PendingVerification',
        Unverified = <any> 'Unverified',
        Rejected = <any> 'Rejected',
        UpdateExternalAccount = <any> 'UpdateExternalAccount',
        PlatformPaused = <any> 'PlatformPaused'
    }
    export enum CardPaymentStatusEnum {
        Inactive = <any> 'Inactive',
        Pending = <any> 'Pending',
        Active = <any> 'Active',
        Unrequested = <any> 'Unrequested'
    }
    export enum PayoutScheduleIntervalEnum {
        Manual = <any> 'Manual',
        Daily = <any> 'Daily',
        Weekly = <any> 'Weekly',
        Monthly = <any> 'Monthly'
    }
}
/**
* Flipdish Stripe Custom Connected Account associated to the Store
*/
export class StripeCustomConnectedAccount {
    /**
    * Physical Restaurant Id
    */
    'StoreId'?: number;
    /**
    * Stripe's own connected account identifier
    */
    'StripeId'?: string;
    /**
    * Card payments capability status (Inactive, Pending, Active, Unrequested)
    */
    'CardPaymentsStatus'?: StripeCustomConnectedAccount.CardPaymentsStatusEnum;
    /**
    * Transfers capability status (Inactive, Pending, Active, Unrequested)
    */
    'TransfersStatus'?: StripeCustomConnectedAccount.TransfersStatusEnum;
    /**
    * Current status of the account
    */
    'AccountStatus'?: StripeCustomConnectedAccount.AccountStatusEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "StripeId",
            "baseName": "StripeId",
            "type": "string"
        },
        {
            "name": "CardPaymentsStatus",
            "baseName": "CardPaymentsStatus",
            "type": "StripeCustomConnectedAccount.CardPaymentsStatusEnum"
        },
        {
            "name": "TransfersStatus",
            "baseName": "TransfersStatus",
            "type": "StripeCustomConnectedAccount.TransfersStatusEnum"
        },
        {
            "name": "AccountStatus",
            "baseName": "AccountStatus",
            "type": "StripeCustomConnectedAccount.AccountStatusEnum"
        }    ];

    static getAttributeTypeMap() {
        return StripeCustomConnectedAccount.attributeTypeMap;
    }
}

export namespace StripeCustomConnectedAccount {
    export enum CardPaymentsStatusEnum {
        Inactive = <any> 'Inactive',
        Pending = <any> 'Pending',
        Active = <any> 'Active',
        Unrequested = <any> 'Unrequested'
    }
    export enum TransfersStatusEnum {
        Inactive = <any> 'Inactive',
        Pending = <any> 'Pending',
        Active = <any> 'Active',
        Unrequested = <any> 'Unrequested'
    }
    export enum AccountStatusEnum {
        Disabled = <any> 'Disabled',
        Enabled = <any> 'Enabled',
        AdditionalInformationRequired = <any> 'AdditionalInformationRequired',
        PendingVerification = <any> 'PendingVerification',
        Unverified = <any> 'Unverified',
        Rejected = <any> 'Rejected',
        UpdateExternalAccount = <any> 'UpdateExternalAccount',
        PlatformPaused = <any> 'PlatformPaused'
    }
}
/**
* Stripe Terminal Connection Token
*/
export class StripeTerminalConnectionToken {
    /**
    * Connection Token
    */
    'Token'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Token",
            "baseName": "Token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StripeTerminalConnectionToken.attributeTypeMap;
    }
}

/**
* Stripe Terminal Private Key
*/
export class StripeTerminalLocation {
    /**
    * Registered location of the terminal
    */
    'Location'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Location",
            "baseName": "Location",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StripeTerminalLocation.attributeTypeMap;
    }
}

/**
* Stuart settings
*/
export class StuartSettings {
    /**
    * Client Id
    */
    'ClientId'?: string;
    /**
    * Client Secret
    */
    'ClientSecret'?: string;
    /**
    * Enabled
    */
    'Enabled'?: boolean;
    /**
    * Webhook url to settle in the Stuart portal
    */
    'WebhookUrlBasicAuthentication'?: string;
    /**
    * Override Flipdish Webhook Url
    */
    'OverrideWebhookUrl'?: boolean;
    /**
    * MinutesToPickupBeforeThanDeliveryTime
    */
    'MinutesToPickupBeforeThanDeliveryTime'?: number;
    /**
    * Package type
    */
    'PackageType'?: StuartSettings.PackageTypeEnum;
    /**
    * Transport type
    */
    'TransportType'?: StuartSettings.TransportTypeEnum;
    /**
    * Determines if Flipdish order should be cancel when Stuart cancels delivery
    */
    'CancelOrderIfStuartCancelDelivery'?: boolean;
    'TransportPrices'?: StuartSettingsTransportPrices;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ClientId",
            "baseName": "ClientId",
            "type": "string"
        },
        {
            "name": "ClientSecret",
            "baseName": "ClientSecret",
            "type": "string"
        },
        {
            "name": "Enabled",
            "baseName": "Enabled",
            "type": "boolean"
        },
        {
            "name": "WebhookUrlBasicAuthentication",
            "baseName": "WebhookUrlBasicAuthentication",
            "type": "string"
        },
        {
            "name": "OverrideWebhookUrl",
            "baseName": "OverrideWebhookUrl",
            "type": "boolean"
        },
        {
            "name": "MinutesToPickupBeforeThanDeliveryTime",
            "baseName": "MinutesToPickupBeforeThanDeliveryTime",
            "type": "number"
        },
        {
            "name": "PackageType",
            "baseName": "PackageType",
            "type": "StuartSettings.PackageTypeEnum"
        },
        {
            "name": "TransportType",
            "baseName": "TransportType",
            "type": "StuartSettings.TransportTypeEnum"
        },
        {
            "name": "CancelOrderIfStuartCancelDelivery",
            "baseName": "CancelOrderIfStuartCancelDelivery",
            "type": "boolean"
        },
        {
            "name": "TransportPrices",
            "baseName": "TransportPrices",
            "type": "StuartSettingsTransportPrices"
        }    ];

    static getAttributeTypeMap() {
        return StuartSettings.attributeTypeMap;
    }
}

export namespace StuartSettings {
    export enum PackageTypeEnum {
        Xsmall = <any> 'Xsmall',
        Small = <any> 'Small',
        Medium = <any> 'Medium',
        Large = <any> 'Large',
        Xlarge = <any> 'Xlarge'
    }
    export enum TransportTypeEnum {
        Bike = <any> 'Bike',
        Cargobike = <any> 'Cargobike',
        Cargobikexl = <any> 'Cargobikexl',
        Motorbike = <any> 'Motorbike',
        Motorbikexl = <any> 'Motorbikexl',
        Car = <any> 'Car',
        Van = <any> 'Van'
    }
}
/**
* If the order exceeds are certain amount this configuration will determine a new vehicle type
*/
export class StuartSettingsTransportPrices {
    'Bike'?: number;
    'Cargobike'?: number;
    'Cargobikexl'?: number;
    'Motorbike'?: number;
    'Motorbikexl'?: number;
    'Car'?: number;
    'Van'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Bike",
            "baseName": "Bike",
            "type": "number"
        },
        {
            "name": "Cargobike",
            "baseName": "Cargobike",
            "type": "number"
        },
        {
            "name": "Cargobikexl",
            "baseName": "Cargobikexl",
            "type": "number"
        },
        {
            "name": "Motorbike",
            "baseName": "Motorbike",
            "type": "number"
        },
        {
            "name": "Motorbikexl",
            "baseName": "Motorbikexl",
            "type": "number"
        },
        {
            "name": "Car",
            "baseName": "Car",
            "type": "number"
        },
        {
            "name": "Van",
            "baseName": "Van",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StuartSettingsTransportPrices.attributeTypeMap;
    }
}

export class SubmitOrderRequest {
    'PaymentToken'?: string;
    'PhoneNumber'?: string;
    'ChefNote'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PaymentToken",
            "baseName": "PaymentToken",
            "type": "string"
        },
        {
            "name": "PhoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        },
        {
            "name": "ChefNote",
            "baseName": "ChefNote",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SubmitOrderRequest.attributeTypeMap;
    }
}

export class SubmitOrderResponseDm {
    'OrderId'?: number;
    'LocalOrderId'?: string;
    'DeliveryTimeEstimateMinutes'?: number;
    'OrderPlacedMessage'?: string;
    'DisplayTipControl'?: boolean;
    'DisplayRateAppControl'?: boolean;
    'CancelOrderPeriodSeconds'?: number;
    'RestaurantName'?: string;
    'LinkText'?: string;
    'LinkUrl'?: string;
    'DeliveryType'?: SubmitOrderResponseDm.DeliveryTypeEnum;
    'DuringOrderPromotionOptions'?: DuringOrderPromotionOptionsDm;
    'RedirectUri'?: string;
    'PickupCode'?: string;
    'RestaurantAddress'?: string;
    'PaymentIntentClientSecret'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OrderId",
            "baseName": "OrderId",
            "type": "number"
        },
        {
            "name": "LocalOrderId",
            "baseName": "LocalOrderId",
            "type": "string"
        },
        {
            "name": "DeliveryTimeEstimateMinutes",
            "baseName": "DeliveryTimeEstimateMinutes",
            "type": "number"
        },
        {
            "name": "OrderPlacedMessage",
            "baseName": "OrderPlacedMessage",
            "type": "string"
        },
        {
            "name": "DisplayTipControl",
            "baseName": "DisplayTipControl",
            "type": "boolean"
        },
        {
            "name": "DisplayRateAppControl",
            "baseName": "DisplayRateAppControl",
            "type": "boolean"
        },
        {
            "name": "CancelOrderPeriodSeconds",
            "baseName": "CancelOrderPeriodSeconds",
            "type": "number"
        },
        {
            "name": "RestaurantName",
            "baseName": "RestaurantName",
            "type": "string"
        },
        {
            "name": "LinkText",
            "baseName": "LinkText",
            "type": "string"
        },
        {
            "name": "LinkUrl",
            "baseName": "LinkUrl",
            "type": "string"
        },
        {
            "name": "DeliveryType",
            "baseName": "DeliveryType",
            "type": "SubmitOrderResponseDm.DeliveryTypeEnum"
        },
        {
            "name": "DuringOrderPromotionOptions",
            "baseName": "DuringOrderPromotionOptions",
            "type": "DuringOrderPromotionOptionsDm"
        },
        {
            "name": "RedirectUri",
            "baseName": "RedirectUri",
            "type": "string"
        },
        {
            "name": "PickupCode",
            "baseName": "PickupCode",
            "type": "string"
        },
        {
            "name": "RestaurantAddress",
            "baseName": "RestaurantAddress",
            "type": "string"
        },
        {
            "name": "PaymentIntentClientSecret",
            "baseName": "PaymentIntentClientSecret",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SubmitOrderResponseDm.attributeTypeMap;
    }
}

export namespace SubmitOrderResponseDm {
    export enum DeliveryTypeEnum {
        Delivery = <any> 'Delivery',
        Pickup = <any> 'Pickup'
    }
}
/**
* Subscription
*/
export class Subscription {
    /**
    * Products
    */
    'Products': Array<SubscriptionProduct>;
    /**
    * Next invoice amount
    */
    'NextInvoiceAmount'?: number;
    /**
    * Next invoice billing date
    */
    'NextInvoiceBillingDate'?: Date;
    /**
    * Upcoming invoice items
    */
    'UpcomingInvoiceItems'?: Array<InvoiceItem>;
    /**
    * Upcoming invoice discounts
    */
    'UpcomingInvoiceDiscounts'?: Array<InvoiceDiscount>;
    /**
    * Upcoming invoice
    */
    'UpcomingInvoice'?: UpcomingInvoice;
    /**
    * The subscription identifier
    */
    'SubscriptionId': string;
    'Name': string;
    /**
    * Status
    */
    'Status': Subscription.StatusEnum;
    /**
    * Currency
    */
    'Currency': Subscription.CurrencyEnum;
    /**
    * User
    */
    'User': string;
    /**
    * Default payment description
    */
    'DefaultPaymentDescription'?: string;
    /**
    * Cancellation Date
    */
    'CancellationRequestDate'?: Date;
    /**
    * Cancel Date
    */
    'CancellationDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Products",
            "baseName": "Products",
            "type": "Array<SubscriptionProduct>"
        },
        {
            "name": "NextInvoiceAmount",
            "baseName": "NextInvoiceAmount",
            "type": "number"
        },
        {
            "name": "NextInvoiceBillingDate",
            "baseName": "NextInvoiceBillingDate",
            "type": "Date"
        },
        {
            "name": "UpcomingInvoiceItems",
            "baseName": "UpcomingInvoiceItems",
            "type": "Array<InvoiceItem>"
        },
        {
            "name": "UpcomingInvoiceDiscounts",
            "baseName": "UpcomingInvoiceDiscounts",
            "type": "Array<InvoiceDiscount>"
        },
        {
            "name": "UpcomingInvoice",
            "baseName": "UpcomingInvoice",
            "type": "UpcomingInvoice"
        },
        {
            "name": "SubscriptionId",
            "baseName": "SubscriptionId",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "Subscription.StatusEnum"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "Subscription.CurrencyEnum"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "string"
        },
        {
            "name": "DefaultPaymentDescription",
            "baseName": "DefaultPaymentDescription",
            "type": "string"
        },
        {
            "name": "CancellationRequestDate",
            "baseName": "CancellationRequestDate",
            "type": "Date"
        },
        {
            "name": "CancellationDate",
            "baseName": "CancellationDate",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return Subscription.attributeTypeMap;
    }
}

export namespace Subscription {
    export enum StatusEnum {
        Incomplete = <any> 'Incomplete',
        IncompleteExpired = <any> 'IncompleteExpired',
        Trialing = <any> 'Trialing',
        Active = <any> 'Active',
        PastDue = <any> 'PastDue',
        Canceled = <any> 'Canceled',
        Unpaid = <any> 'Unpaid'
    }
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Product
*/
export class SubscriptionProduct {
    /**
    * Product Identifier
    */
    'ProductId': string;
    /**
    * Name
    */
    'Name': string;
    /**
    * Quantity
    */
    'Quantity': number;
    /**
    * Price Per Unit
    */
    'PricePerUnit'?: number;
    /**
    * Price Total
    */
    'PriceTotal'?: number;
    /**
    * Payment Frequency
    */
    'PaymentFrequency': SubscriptionProduct.PaymentFrequencyEnum;
    /**
    * Stores
    */
    'Stores'?: Array<SubscriptionStore>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ProductId",
            "baseName": "ProductId",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Quantity",
            "baseName": "Quantity",
            "type": "number"
        },
        {
            "name": "PricePerUnit",
            "baseName": "PricePerUnit",
            "type": "number"
        },
        {
            "name": "PriceTotal",
            "baseName": "PriceTotal",
            "type": "number"
        },
        {
            "name": "PaymentFrequency",
            "baseName": "PaymentFrequency",
            "type": "SubscriptionProduct.PaymentFrequencyEnum"
        },
        {
            "name": "Stores",
            "baseName": "Stores",
            "type": "Array<SubscriptionStore>"
        }    ];

    static getAttributeTypeMap() {
        return SubscriptionProduct.attributeTypeMap;
    }
}

export namespace SubscriptionProduct {
    export enum PaymentFrequencyEnum {
        Day = <any> 'day',
        Week = <any> 'week',
        Month = <any> 'month',
        Year = <any> 'year'
    }
}
export class SubscriptionProductPriceInfo {
    'Amount'?: number;
    'Currency'?: string;
    'Scope'?: SubscriptionProductPriceInfo.ScopeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "string"
        },
        {
            "name": "Scope",
            "baseName": "Scope",
            "type": "SubscriptionProductPriceInfo.ScopeEnum"
        }    ];

    static getAttributeTypeMap() {
        return SubscriptionProductPriceInfo.attributeTypeMap;
    }
}

export namespace SubscriptionProductPriceInfo {
    export enum ScopeEnum {
        Store = <any> 'Store',
        Whitelabel = <any> 'Whitelabel'
    }
}
/**
* Subscription Store
*/
export class SubscriptionStore {
    /**
    * Store Id
    */
    'Id': number;
    /**
    * Name
    */
    'Name': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SubscriptionStore.attributeTypeMap;
    }
}

/**
* Subscription Summary
*/
export class SubscriptionSummary {
    /**
    * Next invoice amount
    */
    'NextInvoiceAmount'?: number;
    /**
    * Next invoice billing date
    */
    'NextInvoiceBillingDate'?: Date;
    /**
    * The subscription identifier
    */
    'SubscriptionId': string;
    'Name': string;
    /**
    * Status
    */
    'Status': SubscriptionSummary.StatusEnum;
    /**
    * Currency
    */
    'Currency': SubscriptionSummary.CurrencyEnum;
    /**
    * User
    */
    'User': string;
    /**
    * Default payment description
    */
    'DefaultPaymentDescription'?: string;
    /**
    * Cancellation Date
    */
    'CancellationRequestDate'?: Date;
    /**
    * Cancel Date
    */
    'CancellationDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "NextInvoiceAmount",
            "baseName": "NextInvoiceAmount",
            "type": "number"
        },
        {
            "name": "NextInvoiceBillingDate",
            "baseName": "NextInvoiceBillingDate",
            "type": "Date"
        },
        {
            "name": "SubscriptionId",
            "baseName": "SubscriptionId",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "SubscriptionSummary.StatusEnum"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "SubscriptionSummary.CurrencyEnum"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "string"
        },
        {
            "name": "DefaultPaymentDescription",
            "baseName": "DefaultPaymentDescription",
            "type": "string"
        },
        {
            "name": "CancellationRequestDate",
            "baseName": "CancellationRequestDate",
            "type": "Date"
        },
        {
            "name": "CancellationDate",
            "baseName": "CancellationDate",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return SubscriptionSummary.attributeTypeMap;
    }
}

export namespace SubscriptionSummary {
    export enum StatusEnum {
        Incomplete = <any> 'Incomplete',
        IncompleteExpired = <any> 'IncompleteExpired',
        Trialing = <any> 'Trialing',
        Active = <any> 'Active',
        PastDue = <any> 'PastDue',
        Canceled = <any> 'Canceled',
        Unpaid = <any> 'Unpaid'
    }
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
}
/**
* Describes a supported country
*/
export class SupportedCountry {
    /**
    * Country code
    */
    'CountryCode'?: string;
    /**
    * Nice display name for a country
    */
    'Name'?: string;
    /**
    * Country internatinoal phone code prefix
    */
    'PhoneCode'?: number;
    /**
    * Language code
    */
    'LanguageCode'?: string;
    /**
    * Language name
    */
    'LanguageName'?: string;
    /**
    * The phone number provided to Store staff which, in conjunction with a one-time-code, will connect them to the customer.
    */
    'OtpNumber'?: string;
    /**
    * The store's support phone number, displayed to customers.
    */
    'SupportNumber'?: string;
    /**
    * Address layout format. This changes the layout of address entry forms on the web app, iOS and Android app and should be set based on local custom.
    */
    'AddressLayout'?: SupportedCountry.AddressLayoutEnum;
    /**
    * Post code type
    */
    'PostCodeType'?: SupportedCountry.PostCodeTypeEnum;
    /**
    * Supported region. This is not used.
    */
    'SupportRegion'?: SupportedCountry.SupportRegionEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CountryCode",
            "baseName": "CountryCode",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "PhoneCode",
            "baseName": "PhoneCode",
            "type": "number"
        },
        {
            "name": "LanguageCode",
            "baseName": "LanguageCode",
            "type": "string"
        },
        {
            "name": "LanguageName",
            "baseName": "LanguageName",
            "type": "string"
        },
        {
            "name": "OtpNumber",
            "baseName": "OtpNumber",
            "type": "string"
        },
        {
            "name": "SupportNumber",
            "baseName": "SupportNumber",
            "type": "string"
        },
        {
            "name": "AddressLayout",
            "baseName": "AddressLayout",
            "type": "SupportedCountry.AddressLayoutEnum"
        },
        {
            "name": "PostCodeType",
            "baseName": "PostCodeType",
            "type": "SupportedCountry.PostCodeTypeEnum"
        },
        {
            "name": "SupportRegion",
            "baseName": "SupportRegion",
            "type": "SupportedCountry.SupportRegionEnum"
        }    ];

    static getAttributeTypeMap() {
        return SupportedCountry.attributeTypeMap;
    }
}

export namespace SupportedCountry {
    export enum AddressLayoutEnum {
        BuildingFirst = <any> 'BuildingFirst',
        AddressFirst = <any> 'AddressFirst',
        FullStreetAddressFirst = <any> 'FullStreetAddressFirst'
    }
    export enum PostCodeTypeEnum {
        None = <any> 'None',
        PostCode = <any> 'PostCode',
        Zip = <any> 'Zip'
    }
    export enum SupportRegionEnum {
        Default = <any> 'Default',
        Spain = <any> 'Spain',
        Benelux = <any> 'Benelux'
    }
}
export class TaxRate {
    'Name'?: string;
    'Percentage'?: number;
    'Total'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Percentage",
            "baseName": "Percentage",
            "type": "number"
        },
        {
            "name": "Total",
            "baseName": "Total",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TaxRate.attributeTypeMap;
    }
}

/**
* 
*/
export class Teammate {
    /**
    * Unique indentifier
    */
    'TeammateId'?: string;
    /**
    * Name
    */
    'Name'?: string;
    /**
    * Last activity
    */
    'LastActivity'?: Date;
    /**
    * Access level is for this App
    */
    'AppId'?: string;
    /**
    * Invitation status
    */
    'InvitationStatus'?: Teammate.InvitationStatusEnum;
    /**
    * Email address
    */
    'Email'?: string;
    /**
    * App access level
    */
    'AppAccessLevel'?: Teammate.AppAccessLevelEnum;
    /**
    * The user has access to all stores for the app (including new stores that added later)
    */
    'HasAccessToAllStores'?: boolean;
    /**
    * Store IDs the user has access to (if HasAccessToAllStores is false)
    */
    'StoreIds'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TeammateId",
            "baseName": "TeammateId",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "LastActivity",
            "baseName": "LastActivity",
            "type": "Date"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "InvitationStatus",
            "baseName": "InvitationStatus",
            "type": "Teammate.InvitationStatusEnum"
        },
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "AppAccessLevel",
            "baseName": "AppAccessLevel",
            "type": "Teammate.AppAccessLevelEnum"
        },
        {
            "name": "HasAccessToAllStores",
            "baseName": "HasAccessToAllStores",
            "type": "boolean"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return Teammate.attributeTypeMap;
    }
}

export namespace Teammate {
    export enum InvitationStatusEnum {
        Pending = <any> 'Pending',
        Accepted = <any> 'Accepted',
        Expired = <any> 'Expired'
    }
    export enum AppAccessLevelEnum {
        None = <any> 'None',
        Owner = <any> 'Owner',
        StoreOwner = <any> 'StoreOwner',
        ManagedOwner = <any> 'ManagedOwner',
        Integrator = <any> 'Integrator',
        StoreManager = <any> 'StoreManager',
        StoreStaff = <any> 'StoreStaff',
        StoreReadOnlyAccess = <any> 'StoreReadOnlyAccess',
        FinanceManger = <any> 'FinanceManger',
        Onboarding = <any> 'Onboarding',
        Support = <any> 'Support'
    }
}
/**
* 
*/
export class TeammateBase {
    /**
    * App access level
    */
    'AppAccessLevel'?: TeammateBase.AppAccessLevelEnum;
    /**
    * The user has access to all stores for the app (including new stores that added later)
    */
    'HasAccessToAllStores'?: boolean;
    /**
    * Store IDs the user has access to (if HasAccessToAllStores is false)
    */
    'StoreIds'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AppAccessLevel",
            "baseName": "AppAccessLevel",
            "type": "TeammateBase.AppAccessLevelEnum"
        },
        {
            "name": "HasAccessToAllStores",
            "baseName": "HasAccessToAllStores",
            "type": "boolean"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return TeammateBase.attributeTypeMap;
    }
}

export namespace TeammateBase {
    export enum AppAccessLevelEnum {
        None = <any> 'None',
        Owner = <any> 'Owner',
        StoreOwner = <any> 'StoreOwner',
        ManagedOwner = <any> 'ManagedOwner',
        Integrator = <any> 'Integrator',
        StoreManager = <any> 'StoreManager',
        StoreStaff = <any> 'StoreStaff',
        StoreReadOnlyAccess = <any> 'StoreReadOnlyAccess',
        FinanceManger = <any> 'FinanceManger',
        Onboarding = <any> 'Onboarding',
        Support = <any> 'Support'
    }
}
/**
* 
*/
export class TeammateDeletedEvent {
    /**
    * The deleted teammate
    */
    'Teammate'?: Teammate;
    /**
    * User who deleted the teammate
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Teammate",
            "baseName": "Teammate",
            "type": "Teammate"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TeammateDeletedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class TeammateInviteAcceptedEvent {
    /**
    * The deleted teammate
    */
    'Teammate'?: Teammate;
    /**
    * User who accepted the invitation
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Teammate",
            "baseName": "Teammate",
            "type": "Teammate"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TeammateInviteAcceptedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class TeammateInviteSentEvent {
    /**
    * The deleted teammate
    */
    'Teammate'?: Teammate;
    /**
    * User who sent the invitation
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Teammate",
            "baseName": "Teammate",
            "type": "Teammate"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TeammateInviteSentEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class TeammateUpdatedEvent {
    /**
    * The deleted teammate
    */
    'Teammate'?: Teammate;
    /**
    * User who updated the teammate
    */
    'User'?: UserEventInfo;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Teammate",
            "baseName": "Teammate",
            "type": "Teammate"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TeammateUpdatedEvent.attributeTypeMap;
    }
}

export class TelemetrySeriesProperty {
    'Name'?: string;
    'Type'?: string;
    'IntValues'?: Array<number>;
    'StringValues'?: Array<string>;
    'DoubleValues'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Type",
            "baseName": "Type",
            "type": "string"
        },
        {
            "name": "IntValues",
            "baseName": "IntValues",
            "type": "Array<number>"
        },
        {
            "name": "StringValues",
            "baseName": "StringValues",
            "type": "Array<string>"
        },
        {
            "name": "DoubleValues",
            "baseName": "DoubleValues",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return TelemetrySeriesProperty.attributeTypeMap;
    }
}

export class TelemetrySeriesQueryParameters {
    'KioskId'?: string;
    'Variables'?: Array<string>;
    'StartDate'?: Date;
    'EndDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "KioskId",
            "baseName": "KioskId",
            "type": "string"
        },
        {
            "name": "Variables",
            "baseName": "Variables",
            "type": "Array<string>"
        },
        {
            "name": "StartDate",
            "baseName": "StartDate",
            "type": "Date"
        },
        {
            "name": "EndDate",
            "baseName": "EndDate",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return TelemetrySeriesQueryParameters.attributeTypeMap;
    }
}

export class TelemetrySeriesResult {
    'Timestamps'?: Array<Date>;
    'Properties'?: Array<TelemetrySeriesProperty>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Timestamps",
            "baseName": "Timestamps",
            "type": "Array<Date>"
        },
        {
            "name": "Properties",
            "baseName": "Properties",
            "type": "Array<TelemetrySeriesProperty>"
        }    ];

    static getAttributeTypeMap() {
        return TelemetrySeriesResult.attributeTypeMap;
    }
}

/**
* Phone call
*/
export class TelephonyConfig {
    /**
    * ID of the phone call
    */
    'TelephonyConfigId'?: number;
    /**
    * APM enabled flag
    */
    'ApmEnabled'?: boolean;
    /**
    * Consent enabled flag
    */
    'ConsentEnabled'?: boolean;
    /**
    * APM phone number of the store
    */
    'PhoneNumber'?: string;
    /**
    * Send app link SMS flag
    */
    'SendAppLinkSms'?: boolean;
    /**
    * Use custom app link SMS message flag
    */
    'UseCustomAppLinkSmsMessage'?: boolean;
    /**
    * Use custom voice message flag
    */
    'UseCustomVoiceMessage'?: boolean;
    /**
    * App link SMS message
    */
    'AppLinkSmsMessage'?: string;
    /**
    * Amount of days to resend APM message
    */
    'ResendApmMessageAfterDays'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TelephonyConfigId",
            "baseName": "TelephonyConfigId",
            "type": "number"
        },
        {
            "name": "ApmEnabled",
            "baseName": "ApmEnabled",
            "type": "boolean"
        },
        {
            "name": "ConsentEnabled",
            "baseName": "ConsentEnabled",
            "type": "boolean"
        },
        {
            "name": "PhoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        },
        {
            "name": "SendAppLinkSms",
            "baseName": "SendAppLinkSms",
            "type": "boolean"
        },
        {
            "name": "UseCustomAppLinkSmsMessage",
            "baseName": "UseCustomAppLinkSmsMessage",
            "type": "boolean"
        },
        {
            "name": "UseCustomVoiceMessage",
            "baseName": "UseCustomVoiceMessage",
            "type": "boolean"
        },
        {
            "name": "AppLinkSmsMessage",
            "baseName": "AppLinkSmsMessage",
            "type": "string"
        },
        {
            "name": "ResendApmMessageAfterDays",
            "baseName": "ResendApmMessageAfterDays",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TelephonyConfig.attributeTypeMap;
    }
}

/**
* Telephony Config Updated Event
*/
export class TelephonyConfigUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Store Id
    */
    'StoreId'?: number;
    /**
    * The telephony config
    */
    'TelephonyConfig'?: TelephonyConfig;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "TelephonyConfig",
            "baseName": "TelephonyConfig",
            "type": "TelephonyConfig"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TelephonyConfigUpdatedEvent.attributeTypeMap;
    }
}

/**
* Breakdown of third party integration fees
*/
export class ThirdPartyFeesDetails {
    /**
    * Third party integration delivery fee
    */
    'DeliveryIntegrationFee'?: number;
    /**
    * Third party integration delivery tip fee
    */
    'DeliveryTipFee'?: number;
    /**
    * Total third party integration fees
    */
    'TotalThirdPartyFees'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DeliveryIntegrationFee",
            "baseName": "DeliveryIntegrationFee",
            "type": "number"
        },
        {
            "name": "DeliveryTipFee",
            "baseName": "DeliveryTipFee",
            "type": "number"
        },
        {
            "name": "TotalThirdPartyFees",
            "baseName": "TotalThirdPartyFees",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ThirdPartyFeesDetails.attributeTypeMap;
    }
}

/**
* Describes the configuration of tipping
*/
export class TipConfiguration {
    /**
    * Configuration is for this StoreId
    */
    'StoreId'?: number;
    /**
    * Are tips enabled?
    */
    'IsEnabled'?: boolean;
    /**
    * Are custom tips allowed?
    */
    'AllowCustomTips'?: boolean;
    /**
    * Is round up allowed?
    */
    'AllowRoundUp'?: boolean;
    /**
    * Are emojis allowed?
    */
    'AllowEmojis'?: boolean;
    /**
    * Ordered list of tip breakpoints (smallest -&gt; largest)
    */
    'Percentages'?: Array<number>;
    /**
    * Defines a default percentage, it must be in the list of Percentages
    */
    'DefaultPercentage'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "StoreId",
            "baseName": "StoreId",
            "type": "number"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "AllowCustomTips",
            "baseName": "AllowCustomTips",
            "type": "boolean"
        },
        {
            "name": "AllowRoundUp",
            "baseName": "AllowRoundUp",
            "type": "boolean"
        },
        {
            "name": "AllowEmojis",
            "baseName": "AllowEmojis",
            "type": "boolean"
        },
        {
            "name": "Percentages",
            "baseName": "Percentages",
            "type": "Array<number>"
        },
        {
            "name": "DefaultPercentage",
            "baseName": "DefaultPercentage",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TipConfiguration.attributeTypeMap;
    }
}

/**
* Un-Register card reader request
*/
export class UnRegisterCardReaderRequest {
    /**
    * Device card readerid
    */
    'ReaderId': string;
    /**
    * The kiosk device id
    */
    'KioskDeviceId': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ReaderId",
            "baseName": "ReaderId",
            "type": "string"
        },
        {
            "name": "KioskDeviceId",
            "baseName": "KioskDeviceId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UnRegisterCardReaderRequest.attributeTypeMap;
    }
}

export class UpcomingInvoice {
    /**
    * Amount
    */
    'Amount'?: number;
    /**
    * Next billing date
    */
    'NextBillingDate'?: Date;
    /**
    * Subtotal
    */
    'Subtotal': number;
    /**
    * Total excluding tax
    */
    'TotalExcludingTax'?: number;
    /**
    * Amount due
    */
    'AmountDue': number;
    /**
    * Tax
    */
    'Tax': number;
    /**
    * Items
    */
    'Items'?: Array<InvoiceItem>;
    /**
    * Discounts
    */
    'Discounts'?: Array<InvoiceDiscount>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "NextBillingDate",
            "baseName": "NextBillingDate",
            "type": "Date"
        },
        {
            "name": "Subtotal",
            "baseName": "Subtotal",
            "type": "number"
        },
        {
            "name": "TotalExcludingTax",
            "baseName": "TotalExcludingTax",
            "type": "number"
        },
        {
            "name": "AmountDue",
            "baseName": "AmountDue",
            "type": "number"
        },
        {
            "name": "Tax",
            "baseName": "Tax",
            "type": "number"
        },
        {
            "name": "Items",
            "baseName": "Items",
            "type": "Array<InvoiceItem>"
        },
        {
            "name": "Discounts",
            "baseName": "Discounts",
            "type": "Array<InvoiceDiscount>"
        }    ];

    static getAttributeTypeMap() {
        return UpcomingInvoice.attributeTypeMap;
    }
}

export class UpdateAppStoreApp {
    'Details': string;
    'ConfigurationType': UpdateAppStoreApp.ConfigurationTypeEnum;
    'StoreSelectorType': UpdateAppStoreApp.StoreSelectorTypeEnum;
    'FieldGroups'?: Array<FieldGroup>;
    'SetupInstructions'?: string;
    'ExternalSetupLink'?: string;
    'TeammateAppAccessLevel'?: UpdateAppStoreApp.TeammateAppAccessLevelEnum;
    'PermissionsType': UpdateAppStoreApp.PermissionsTypeEnum;
    'Support'?: AppStoreAppSupportInfo;
    'ExternalFunctionActionUrl'?: string;
    'ExternalFunctionSignatureKey'?: string;
    'IsPaid'?: boolean;
    'Name': string;
    'Description': string;
    'IsEnabled'?: boolean;
    'Categories': Array<UpdateAppStoreApp.CategoriesEnum>;
    'Countries': Array<UpdateAppStoreApp.CountriesEnum>;
    'DeveloperName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Details",
            "baseName": "Details",
            "type": "string"
        },
        {
            "name": "ConfigurationType",
            "baseName": "ConfigurationType",
            "type": "UpdateAppStoreApp.ConfigurationTypeEnum"
        },
        {
            "name": "StoreSelectorType",
            "baseName": "StoreSelectorType",
            "type": "UpdateAppStoreApp.StoreSelectorTypeEnum"
        },
        {
            "name": "FieldGroups",
            "baseName": "FieldGroups",
            "type": "Array<FieldGroup>"
        },
        {
            "name": "SetupInstructions",
            "baseName": "SetupInstructions",
            "type": "string"
        },
        {
            "name": "ExternalSetupLink",
            "baseName": "ExternalSetupLink",
            "type": "string"
        },
        {
            "name": "TeammateAppAccessLevel",
            "baseName": "TeammateAppAccessLevel",
            "type": "UpdateAppStoreApp.TeammateAppAccessLevelEnum"
        },
        {
            "name": "PermissionsType",
            "baseName": "PermissionsType",
            "type": "UpdateAppStoreApp.PermissionsTypeEnum"
        },
        {
            "name": "Support",
            "baseName": "Support",
            "type": "AppStoreAppSupportInfo"
        },
        {
            "name": "ExternalFunctionActionUrl",
            "baseName": "ExternalFunctionActionUrl",
            "type": "string"
        },
        {
            "name": "ExternalFunctionSignatureKey",
            "baseName": "ExternalFunctionSignatureKey",
            "type": "string"
        },
        {
            "name": "IsPaid",
            "baseName": "IsPaid",
            "type": "boolean"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "Categories",
            "baseName": "Categories",
            "type": "Array<UpdateAppStoreApp.CategoriesEnum>"
        },
        {
            "name": "Countries",
            "baseName": "Countries",
            "type": "Array<UpdateAppStoreApp.CountriesEnum>"
        },
        {
            "name": "DeveloperName",
            "baseName": "DeveloperName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateAppStoreApp.attributeTypeMap;
    }
}

export namespace UpdateAppStoreApp {
    export enum ConfigurationTypeEnum {
        ExternalLink = <any> 'ExternalLink',
        FlipdishHosted = <any> 'FlipdishHosted'
    }
    export enum StoreSelectorTypeEnum {
        None = <any> 'None',
        Single = <any> 'Single',
        Multiple = <any> 'Multiple'
    }
    export enum TeammateAppAccessLevelEnum {
        Owner = <any> 'Owner',
        StoreOwner = <any> 'StoreOwner',
        ManagedOwner = <any> 'ManagedOwner',
        Integrator = <any> 'Integrator',
        StoreManager = <any> 'StoreManager',
        StoreStaff = <any> 'StoreStaff',
        StoreReadOnlyAccess = <any> 'StoreReadOnlyAccess',
        FinanceManger = <any> 'FinanceManger'
    }
    export enum PermissionsTypeEnum {
        Teammate = <any> 'Teammate'
    }
    export enum CategoriesEnum {
        PointOfSale = <any> 'PointOfSale',
        DeliveryAndLogistics = <any> 'DeliveryAndLogistics',
        CRM = <any> 'CRM',
        GiftCard = <any> 'GiftCard',
        Accounting = <any> 'Accounting',
        LoyaltyAndMarketing = <any> 'LoyaltyAndMarketing',
        Other = <any> 'Other'
    }
    export enum CountriesEnum {
        GB = <any> 'GB',
        IE = <any> 'IE',
        FR = <any> 'FR',
        ES = <any> 'ES',
        PT = <any> 'PT',
        IT = <any> 'IT',
        DE = <any> 'DE',
        PL = <any> 'PL',
        BE = <any> 'BE',
        LU = <any> 'LU',
        NL = <any> 'NL',
        US = <any> 'US',
        CA = <any> 'CA',
        BG = <any> 'BG',
        MX = <any> 'MX',
        AU = <any> 'AU',
        NZ = <any> 'NZ'
    }
}
export class UpdateAppStoreAppConfiguration {
    'IsEnabled': boolean;
    'StoreIds'?: Array<number>;
    'Settings'?: Array<Setting>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "Settings",
            "baseName": "Settings",
            "type": "Array<Setting>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateAppStoreAppConfiguration.attributeTypeMap;
    }
}

export class UpdateAppStoreAppConfigurationValuesBatch {
    'Settings'?: Array<Setting>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Settings",
            "baseName": "Settings",
            "type": "Array<Setting>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateAppStoreAppConfigurationValuesBatch.attributeTypeMap;
    }
}

export class UpdateAppStoreAppConfigurationWebhookDTO {
    'Id': string;
    'IsEnabled': boolean;
    'StoreIds'?: Array<number>;
    'Settings'?: Array<Setting>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "string"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "Settings",
            "baseName": "Settings",
            "type": "Array<Setting>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateAppStoreAppConfigurationWebhookDTO.attributeTypeMap;
    }
}

export class UpdateAppStoreAppExternalProduct {
    'ExternalProductId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ExternalProductId",
            "baseName": "ExternalProductId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateAppStoreAppExternalProduct.attributeTypeMap;
    }
}

/**
* Data to update a {Flipdish.Menus.PublicModels.V1.Catalog.Items.CatalogGroupReference}
*/
export class UpdateCatalogGroupReference {
    /**
    * Identifier of the ProductId to use as SubProduct
    */
    'CatalogGroupId': string;
    /**
    * Identifier of the ProductId to use as SubProduct
    */
    'CatalogItemId'?: string;
    /**
    * Type of the SupProduct
    */
    'GroupType': UpdateCatalogGroupReference.GroupTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CatalogGroupId",
            "baseName": "CatalogGroupId",
            "type": "string"
        },
        {
            "name": "CatalogItemId",
            "baseName": "CatalogItemId",
            "type": "string"
        },
        {
            "name": "GroupType",
            "baseName": "GroupType",
            "type": "UpdateCatalogGroupReference.GroupTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return UpdateCatalogGroupReference.attributeTypeMap;
    }
}

export namespace UpdateCatalogGroupReference {
    export enum GroupTypeEnum {
        ModifierGroup = <any> 'ModifierGroup'
    }
}
/**
* Update Catalog Item
*/
export class UpdateCatalogItem {
    /**
    * Stock Keeping Unit (SKU)
    */
    'Sku'?: string;
    /**
    * Product name
    */
    'Name'?: string;
    /**
    * Product description
    */
    'Description'?: string;
    /**
    * Product price
    */
    'Price'?: number;
    /**
    * Image File Name
    */
    'ImageFileName'?: string;
    /**
    * Product contains alcohol
    */
    'Alcohol'?: boolean;
    /**
    * Collection of groups associated with this item
    */
    'Groups'?: Array<UpdateCatalogGroupReference>;
    /**
    * Collection of metafields
    */
    'Metafields'?: Array<Metafield>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Sku",
            "baseName": "Sku",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "ImageFileName",
            "baseName": "ImageFileName",
            "type": "string"
        },
        {
            "name": "Alcohol",
            "baseName": "Alcohol",
            "type": "boolean"
        },
        {
            "name": "Groups",
            "baseName": "Groups",
            "type": "Array<UpdateCatalogGroupReference>"
        },
        {
            "name": "Metafields",
            "baseName": "Metafields",
            "type": "Array<Metafield>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateCatalogItem.attributeTypeMap;
    }
}

/**
* UpdateDriver Push Notification Token
*/
export class UpdateDriverNotificationToken {
    /**
    * Push notifications token, cannot be null
    */
    'PushNotificationsToken': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PushNotificationsToken",
            "baseName": "PushNotificationsToken",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateDriverNotificationToken.attributeTypeMap;
    }
}

/**
* Update Driver Profile
*/
export class UpdateDriverProfileModel {
    /**
    * The new name of the Driver.
    */
    'Name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateDriverProfileModel.attributeTypeMap;
    }
}

/**
* Update fulfillment states configuration
*/
export class UpdateFulfillmentStatesConfiguration {
    /**
    * Set to true if a system configuration template is to be updated (permissions also needed)
    */
    'OverwriteSystemTemplate'?: boolean;
    /**
    * Stores id's
    */
    'StoreIds'?: Array<number>;
    /**
    * Store Selector Type
    */
    'StoreSelectorType'?: UpdateFulfillmentStatesConfiguration.StoreSelectorTypeEnum;
    /**
    * Settings
    */
    'States'?: Array<FulfillmentStatusConfigurationItem>;
    /**
    * Enable automatic transitions
    */
    'AutomaticTransitionsEnabled'?: boolean;
    /**
    * Name
    */
    'Name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OverwriteSystemTemplate",
            "baseName": "OverwriteSystemTemplate",
            "type": "boolean"
        },
        {
            "name": "StoreIds",
            "baseName": "StoreIds",
            "type": "Array<number>"
        },
        {
            "name": "StoreSelectorType",
            "baseName": "StoreSelectorType",
            "type": "UpdateFulfillmentStatesConfiguration.StoreSelectorTypeEnum"
        },
        {
            "name": "States",
            "baseName": "States",
            "type": "Array<FulfillmentStatusConfigurationItem>"
        },
        {
            "name": "AutomaticTransitionsEnabled",
            "baseName": "AutomaticTransitionsEnabled",
            "type": "boolean"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateFulfillmentStatesConfiguration.attributeTypeMap;
    }
}

export namespace UpdateFulfillmentStatesConfiguration {
    export enum StoreSelectorTypeEnum {
        None = <any> 'None',
        Single = <any> 'Single',
        Multiple = <any> 'Multiple'
    }
}
/**
* Update Catalog Group
*/
export class UpdateGroup {
    /**
    * Stock Keeping Unit (SKU)
    */
    'Sku'?: string;
    /**
    * Group name
    */
    'Name'?: string;
    /**
    * Autogenerate display text in ordering applications
    */
    'AutogenerateDisplayText'?: boolean;
    /**
    * Image File Name
    */
    'ImageFileName'?: string;
    /**
    * Minimum number of items that the user has to select
    */
    'MinSelectCount'?: number;
    /**
    * Maximum number of items that the user has to select
    */
    'MaxSelectCount'?: number;
    /**
    * Collection of items associated with this group
    */
    'Products'?: Array<UpdateProductReference>;
    /**
    * Collection of metafields
    */
    'Metafields'?: Array<Metafield>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Sku",
            "baseName": "Sku",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "AutogenerateDisplayText",
            "baseName": "AutogenerateDisplayText",
            "type": "boolean"
        },
        {
            "name": "ImageFileName",
            "baseName": "ImageFileName",
            "type": "string"
        },
        {
            "name": "MinSelectCount",
            "baseName": "MinSelectCount",
            "type": "number"
        },
        {
            "name": "MaxSelectCount",
            "baseName": "MaxSelectCount",
            "type": "number"
        },
        {
            "name": "Products",
            "baseName": "Products",
            "type": "Array<UpdateProductReference>"
        },
        {
            "name": "Metafields",
            "baseName": "Metafields",
            "type": "Array<Metafield>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateGroup.attributeTypeMap;
    }
}

/**
* Data to update a {Flipdish.Menus.PublicModels.V1.Catalog.Products.GroupReference}
*/
export class UpdateGroupReference {
    /**
    * Identifier of the ProductId to use as SubProduct
    */
    'CatalogItemId': string;
    /**
    * Type of the SupProduct
    */
    'GroupType': UpdateGroupReference.GroupTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CatalogItemId",
            "baseName": "CatalogItemId",
            "type": "string"
        },
        {
            "name": "GroupType",
            "baseName": "GroupType",
            "type": "UpdateGroupReference.GroupTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return UpdateGroupReference.attributeTypeMap;
    }
}

export namespace UpdateGroupReference {
    export enum GroupTypeEnum {
        ModifierGroup = <any> 'ModifierGroup'
    }
}
/**
* Input model for updating a LocationArea
*/
export class UpdateLocationArea {
    /**
    * Location Area Id
    */
    'LocationAreaId': number;
    /**
    * Descriptive LocationArea name
    */
    'LocationAreaName': string;
    /**
    * Sets if the Location Area should be soft deleted or not
    */
    'IsDeleted'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "LocationAreaId",
            "baseName": "LocationAreaId",
            "type": "number"
        },
        {
            "name": "LocationAreaName",
            "baseName": "LocationAreaName",
            "type": "string"
        },
        {
            "name": "IsDeleted",
            "baseName": "IsDeleted",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return UpdateLocationArea.attributeTypeMap;
    }
}

/**
* Information to update a {Flipdish.Metafields.PublicModels.V1.MetafieldDefinition}
*/
export class UpdateMetafieldDefinition {
    /**
    * Field Name
    */
    'Name'?: string;
    /**
    * Field Description
    */
    'Description'?: string;
    /**
    * Enable Metafield Behaviors
    */
    'Behaviors'?: Array<UpdateMetafieldDefinition.BehaviorsEnum>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Behaviors",
            "baseName": "Behaviors",
            "type": "Array<UpdateMetafieldDefinition.BehaviorsEnum>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateMetafieldDefinition.attributeTypeMap;
    }
}

export namespace UpdateMetafieldDefinition {
    export enum BehaviorsEnum {
        SendToOrder = <any> 'SendToOrder',
        SendToMenu = <any> 'SendToMenu'
    }
}
/**
* Update Mobile Apps Status
*/
export class UpdateMobileAppsSubmissionStatus {
    /**
    * Mobile Apps Submission Status Id
    */
    'MobileAppsSubmissionStatusId'?: number;
    /**
    * Mobile Type
    */
    'Type'?: UpdateMobileAppsSubmissionStatus.TypeEnum;
    /**
    * Mobile App Status
    */
    'AppStatus'?: UpdateMobileAppsSubmissionStatus.AppStatusEnum;
    /**
    * Mobile App Status
    */
    'UpdateStatus'?: UpdateMobileAppsSubmissionStatus.UpdateStatusEnum;
    /**
    * Mobile LastUpdateStatusTime
    */
    'LastUpdateStatusTime'?: Date;
    /**
    * Mobile Notes
    */
    'Notes'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "MobileAppsSubmissionStatusId",
            "baseName": "MobileAppsSubmissionStatusId",
            "type": "number"
        },
        {
            "name": "Type",
            "baseName": "Type",
            "type": "UpdateMobileAppsSubmissionStatus.TypeEnum"
        },
        {
            "name": "AppStatus",
            "baseName": "AppStatus",
            "type": "UpdateMobileAppsSubmissionStatus.AppStatusEnum"
        },
        {
            "name": "UpdateStatus",
            "baseName": "UpdateStatus",
            "type": "UpdateMobileAppsSubmissionStatus.UpdateStatusEnum"
        },
        {
            "name": "LastUpdateStatusTime",
            "baseName": "LastUpdateStatusTime",
            "type": "Date"
        },
        {
            "name": "Notes",
            "baseName": "Notes",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateMobileAppsSubmissionStatus.attributeTypeMap;
    }
}

export namespace UpdateMobileAppsSubmissionStatus {
    export enum TypeEnum {
        None = <any> 'None',
        Android = <any> 'Android',
        IOS = <any> 'IOS'
    }
    export enum AppStatusEnum {
        None = <any> 'None',
        Published = <any> 'Published',
        Unpublished = <any> 'Unpublished'
    }
    export enum UpdateStatusEnum {
        None = <any> 'None',
        Submitted = <any> 'Submitted',
        InReview = <any> 'InReview',
        Rejected = <any> 'Rejected',
        Approved = <any> 'Approved',
        Published = <any> 'Published'
    }
}
export class UpdatePayGreenConfigurationRequest {
    'Name'?: string;
    'AssignedStores'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "AssignedStores",
            "baseName": "AssignedStores",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return UpdatePayGreenConfigurationRequest.attributeTypeMap;
    }
}

/**
* Update Product
*/
export class UpdateProduct {
    /**
    * Stock Keeping Unit (SKU)
    */
    'Sku'?: string;
    /**
    * Product name
    */
    'Name'?: string;
    /**
    * Product description
    */
    'Description'?: string;
    /**
    * Product price
    */
    'Price'?: number;
    /**
    * Image File Name
    */
    'ImageFileName'?: string;
    /**
    * Product contains alcohol
    */
    'Alcohol'?: boolean;
    /**
    * Collection of groups associated with this item
    */
    'Groups'?: Array<UpdateGroupReference>;
    /**
    * Collection of metafields
    */
    'Metafields'?: Array<Metafield>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Sku",
            "baseName": "Sku",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Price",
            "baseName": "Price",
            "type": "number"
        },
        {
            "name": "ImageFileName",
            "baseName": "ImageFileName",
            "type": "string"
        },
        {
            "name": "Alcohol",
            "baseName": "Alcohol",
            "type": "boolean"
        },
        {
            "name": "Groups",
            "baseName": "Groups",
            "type": "Array<UpdateGroupReference>"
        },
        {
            "name": "Metafields",
            "baseName": "Metafields",
            "type": "Array<Metafield>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateProduct.attributeTypeMap;
    }
}

/**
* Data to update a {Flipdish.Menus.PublicModels.V1.Catalog.Groups.UpdateProductReference}
*/
export class UpdateProductReference {
    /**
    * Identifier of the CatalogItemId to use as SubProduct
    */
    'CatalogItemId': string;
    /**
    * Type of the SupProduct
    */
    'ProductType': UpdateProductReference.ProductTypeEnum;
    /**
    * Quantity of the modifier that will be set when the parent product is placed in the basket
    */
    'PreselectedQuantity'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CatalogItemId",
            "baseName": "CatalogItemId",
            "type": "string"
        },
        {
            "name": "ProductType",
            "baseName": "ProductType",
            "type": "UpdateProductReference.ProductTypeEnum"
        },
        {
            "name": "PreselectedQuantity",
            "baseName": "PreselectedQuantity",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return UpdateProductReference.attributeTypeMap;
    }
}

export namespace UpdateProductReference {
    export enum ProductTypeEnum {
        Product = <any> 'Product',
        Modifier = <any> 'Modifier'
    }
}
export class UpdateStorePayGreenConfigurationRequest {
    'Active'?: boolean;
    'PayGreenConfigurationId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Active",
            "baseName": "Active",
            "type": "boolean"
        },
        {
            "name": "PayGreenConfigurationId",
            "baseName": "PayGreenConfigurationId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return UpdateStorePayGreenConfigurationRequest.attributeTypeMap;
    }
}

/**
* Describes the configuration of tipping
*/
export class UpdateTipConfiguration {
    /**
    * Are tips enabled?
    */
    'IsEnabled'?: boolean;
    /**
    * Are custom tips allowed?
    */
    'AllowCustomTips'?: boolean;
    /**
    * Is round up allowed?
    */
    'AllowRoundUp'?: boolean;
    /**
    * Are emojis allowed?
    */
    'AllowEmojis'?: boolean;
    /**
    * Ordered list of tip breakpoints (smallest -&gt; largest)
    */
    'Percentages'?: Array<number>;
    /**
    * Defines a default percentage, it must be in the list of Percentages
    */
    'DefaultPercentage'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "AllowCustomTips",
            "baseName": "AllowCustomTips",
            "type": "boolean"
        },
        {
            "name": "AllowRoundUp",
            "baseName": "AllowRoundUp",
            "type": "boolean"
        },
        {
            "name": "AllowEmojis",
            "baseName": "AllowEmojis",
            "type": "boolean"
        },
        {
            "name": "Percentages",
            "baseName": "Percentages",
            "type": "Array<number>"
        },
        {
            "name": "DefaultPercentage",
            "baseName": "DefaultPercentage",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return UpdateTipConfiguration.attributeTypeMap;
    }
}

/**
* Update Voucher
*/
export class UpdateVoucher {
    /**
    * Promotion ID to update
    */
    'PromotionId'?: number;
    /**
    * The updated name of the promotion
    */
    'PromotionName'?: string;
    /**
    * The updated menu items that the promotion awards
    */
    'PromotionAwardMenuItemPublicIds'?: Array<string>;
    /**
    * Voucher Code
    */
    'Code'?: string;
    /**
    * Voucher Description (Visible on printout)
    */
    'Description'?: string;
    /**
    * Stores that this voucher applies to
    */
    'Stores'?: Array<number>;
    /**
    * Valid on orders on or above
    */
    'ValidOnOrdersOver'?: number;
    /**
    * Takes priority
    */
    'TakesPriority'?: boolean;
    /**
    * Is voucher enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Is voucher automatically applied
    */
    'IsAutomaticallyApplied'?: boolean;
    /**
    * Include delivery fees
    */
    'IncludeDeliveryFee'?: boolean;
    /**
    * Valid for delivery orders
    */
    'IsValidForDeliveryOrders'?: boolean;
    /**
    * Valid for pickup orders
    */
    'IsValidForPickupOrders'?: boolean;
    /**
    * Valid for orders payed online
    */
    'IsValidForOrdersPayedOnline'?: boolean;
    /**
    * Valid for orders payed in cash
    */
    'IsValidForOrdersPayedByCash'?: boolean;
    /**
    * Valid only on the first order by the customer
    */
    'IsValidForFirstOrderOnly'?: boolean;
    /**
    * Valid once per customer
    */
    'IsValidOncePerCustomer'?: boolean;
    /**
    * Valid only once, by any customer (once used cannot be used again by any other customer)
    */
    'IsValidOnlyOnce'?: boolean;
    /**
    * Voucher Starts On (Time in UTC)
    */
    'StartDate'?: Date;
    /**
    * Voucher Expires On (Time in UTC)
    */
    'ExpiryDate'?: Date;
    /**
    * Limit the channels this voucher can be used on
    */
    'ChannelRestrictions'?: Array<UpdateVoucher.ChannelRestrictionsEnum>;
    /**
    * Periods in which the voucher is valid.  An empty list means the voucher is valid at all times.  When updating the voucher, if this is set to null, the validity periods won't be updated.
    */
    'ValidityPeriods'?: Array<ValidityPeriod>;
    /**
    * Voucher Subtype
    */
    'VoucherSubType'?: UpdateVoucher.VoucherSubTypeEnum;
    /**
    * Customer UserID
    */
    'CustomerId'?: number;
    /**
    * Maximum number of times the voucher can be redeemed (used)
    */
    'MaxRedemptions'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PromotionId",
            "baseName": "PromotionId",
            "type": "number"
        },
        {
            "name": "PromotionName",
            "baseName": "PromotionName",
            "type": "string"
        },
        {
            "name": "PromotionAwardMenuItemPublicIds",
            "baseName": "PromotionAwardMenuItemPublicIds",
            "type": "Array<string>"
        },
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Stores",
            "baseName": "Stores",
            "type": "Array<number>"
        },
        {
            "name": "ValidOnOrdersOver",
            "baseName": "ValidOnOrdersOver",
            "type": "number"
        },
        {
            "name": "TakesPriority",
            "baseName": "TakesPriority",
            "type": "boolean"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "IsAutomaticallyApplied",
            "baseName": "IsAutomaticallyApplied",
            "type": "boolean"
        },
        {
            "name": "IncludeDeliveryFee",
            "baseName": "IncludeDeliveryFee",
            "type": "boolean"
        },
        {
            "name": "IsValidForDeliveryOrders",
            "baseName": "IsValidForDeliveryOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForPickupOrders",
            "baseName": "IsValidForPickupOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedOnline",
            "baseName": "IsValidForOrdersPayedOnline",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedByCash",
            "baseName": "IsValidForOrdersPayedByCash",
            "type": "boolean"
        },
        {
            "name": "IsValidForFirstOrderOnly",
            "baseName": "IsValidForFirstOrderOnly",
            "type": "boolean"
        },
        {
            "name": "IsValidOncePerCustomer",
            "baseName": "IsValidOncePerCustomer",
            "type": "boolean"
        },
        {
            "name": "IsValidOnlyOnce",
            "baseName": "IsValidOnlyOnce",
            "type": "boolean"
        },
        {
            "name": "StartDate",
            "baseName": "StartDate",
            "type": "Date"
        },
        {
            "name": "ExpiryDate",
            "baseName": "ExpiryDate",
            "type": "Date"
        },
        {
            "name": "ChannelRestrictions",
            "baseName": "ChannelRestrictions",
            "type": "Array<UpdateVoucher.ChannelRestrictionsEnum>"
        },
        {
            "name": "ValidityPeriods",
            "baseName": "ValidityPeriods",
            "type": "Array<ValidityPeriod>"
        },
        {
            "name": "VoucherSubType",
            "baseName": "VoucherSubType",
            "type": "UpdateVoucher.VoucherSubTypeEnum"
        },
        {
            "name": "CustomerId",
            "baseName": "CustomerId",
            "type": "number"
        },
        {
            "name": "MaxRedemptions",
            "baseName": "MaxRedemptions",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return UpdateVoucher.attributeTypeMap;
    }
}

export namespace UpdateVoucher {
    export enum ChannelRestrictionsEnum {
        Ios = <any> 'Ios',
        Android = <any> 'Android',
        Web = <any> 'Web',
        Kiosk = <any> 'Kiosk',
        Pos = <any> 'Pos',
        Google = <any> 'Google'
    }
    export enum VoucherSubTypeEnum {
        None = <any> 'None',
        SignUp = <any> 'SignUp',
        Loyalty = <any> 'Loyalty',
        Loyalty25 = <any> 'Loyalty25',
        Retention = <any> 'Retention',
        SecondaryRetention = <any> 'SecondaryRetention',
        Custom = <any> 'Custom'
    }
}
/**
* Update Voucher Usage
*/
export class UpdateVoucherUsage {
    /**
    * Flag indicating whether the voucher is used
    */
    'IsUsed'?: boolean;
    /**
    * Indicates Customer that used the voucher.
    */
    'UsedByCustomerId'?: number;
    /**
    * An opaque string, to ensure idempotency. This allows for safely retrying requests without accidentally performing the same stamp operation twice.   This will typically contain the the ID of the sale order.
    */
    'TransactionKey'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IsUsed",
            "baseName": "IsUsed",
            "type": "boolean"
        },
        {
            "name": "UsedByCustomerId",
            "baseName": "UsedByCustomerId",
            "type": "number"
        },
        {
            "name": "TransactionKey",
            "baseName": "TransactionKey",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateVoucherUsage.attributeTypeMap;
    }
}

/**
* User answered signup questions event
*/
export class UserAnsweredSignupQuestionsEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The user
    */
    'User'?: UserEventInfo;
    /**
    * The users answers
    */
    'SignupAnswers'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "SignupAnswers",
            "baseName": "SignupAnswers",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserAnsweredSignupQuestionsEvent.attributeTypeMap;
    }
}

/**
* User created event
*/
export class UserCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The user
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserCreatedEvent.attributeTypeMap;
    }
}

/**
* User deleted event
*/
export class UserDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The user
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserDeletedEvent.attributeTypeMap;
    }
}

/**
* User Event Info
*/
export class UserEventInfo {
    /**
    * User Id
    */
    'UserId'?: number;
    /**
    * User Name
    */
    'UserName'?: string;
    /**
    * User Phone Number
    */
    'UserPhoneNumber'?: string;
    /**
    * User Email
    */
    'UserEmail'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "UserId",
            "baseName": "UserId",
            "type": "number"
        },
        {
            "name": "UserName",
            "baseName": "UserName",
            "type": "string"
        },
        {
            "name": "UserPhoneNumber",
            "baseName": "UserPhoneNumber",
            "type": "string"
        },
        {
            "name": "UserEmail",
            "baseName": "UserEmail",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserEventInfo.attributeTypeMap;
    }
}

/**
* User login event
*/
export class UserLoginEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The user
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserLoginEvent.attributeTypeMap;
    }
}

/**
* User created password event
*/
export class UserPasswordCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The user
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserPasswordCreatedEvent.attributeTypeMap;
    }
}

/**
* User updated event
*/
export class UserUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * The user
    */
    'User'?: UserEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserUpdatedEvent.attributeTypeMap;
    }
}

export class ValidValue {
    'Code': string;
    'Name': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ValidValue.attributeTypeMap;
    }
}

/**
* Validation error result
*/
export class ValidationErrorResult {
    /**
    * Field name
    */
    'FieldName'?: string;
    /**
    * List of errors relates to field
    */
    'Errors'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "FieldName",
            "baseName": "FieldName",
            "type": "string"
        },
        {
            "name": "Errors",
            "baseName": "Errors",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return ValidationErrorResult.attributeTypeMap;
    }
}

export class ValidityPeriod {
    'DayOfWeek'?: ValidityPeriod.DayOfWeekEnum;
    'StartTime'?: string;
    'EndTime'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "DayOfWeek",
            "baseName": "DayOfWeek",
            "type": "ValidityPeriod.DayOfWeekEnum"
        },
        {
            "name": "StartTime",
            "baseName": "StartTime",
            "type": "string"
        },
        {
            "name": "EndTime",
            "baseName": "EndTime",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ValidityPeriod.attributeTypeMap;
    }
}

export namespace ValidityPeriod {
    export enum DayOfWeekEnum {
        Sunday = <any> 'Sunday',
        Monday = <any> 'Monday',
        Tuesday = <any> 'Tuesday',
        Wednesday = <any> 'Wednesday',
        Thursday = <any> 'Thursday',
        Friday = <any> 'Friday',
        Saturday = <any> 'Saturday'
    }
}
/**
* Voucher
*/
export class Voucher {
    /**
    * Voucher Id
    */
    'VoucherId'?: number;
    /**
    * Voucher Status
    */
    'Status'?: Voucher.StatusEnum;
    /**
    * Voucher Type
    */
    'VoucherType'?: Voucher.VoucherTypeEnum;
    /**
    * Currency of the voucher
    */
    'Currency'?: Voucher.CurrencyEnum;
    /**
    * Stores that this voucher applies to
    */
    'StoreNames'?: Array<string>;
    /**
    * Promotion details
    */
    'PromotionDetails'?: PromotionDetails;
    /**
    * Credit note details
    */
    'CreditNoteDetails'?: CreditNoteDetails;
    /**
    * Lump discount details
    */
    'LumpDiscountDetails'?: LumpDiscountDetails;
    /**
    * Percent discount details
    */
    'PercentDiscountDetails'?: PercentDiscountDetails;
    /**
    * Voucher Code
    */
    'Code'?: string;
    /**
    * Voucher Description (Visible on printout)
    */
    'Description'?: string;
    /**
    * Stores that this voucher applies to
    */
    'Stores'?: Array<number>;
    /**
    * Valid on orders on or above
    */
    'ValidOnOrdersOver'?: number;
    /**
    * Takes priority
    */
    'TakesPriority'?: boolean;
    /**
    * Is voucher enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Is voucher automatically applied
    */
    'IsAutomaticallyApplied'?: boolean;
    /**
    * Include delivery fees
    */
    'IncludeDeliveryFee'?: boolean;
    /**
    * Valid for delivery orders
    */
    'IsValidForDeliveryOrders'?: boolean;
    /**
    * Valid for pickup orders
    */
    'IsValidForPickupOrders'?: boolean;
    /**
    * Valid for orders payed online
    */
    'IsValidForOrdersPayedOnline'?: boolean;
    /**
    * Valid for orders payed in cash
    */
    'IsValidForOrdersPayedByCash'?: boolean;
    /**
    * Valid only on the first order by the customer
    */
    'IsValidForFirstOrderOnly'?: boolean;
    /**
    * Valid once per customer
    */
    'IsValidOncePerCustomer'?: boolean;
    /**
    * Valid only once, by any customer (once used cannot be used again by any other customer)
    */
    'IsValidOnlyOnce'?: boolean;
    /**
    * Voucher Starts On (Time in UTC)
    */
    'StartDate'?: Date;
    /**
    * Voucher Expires On (Time in UTC)
    */
    'ExpiryDate'?: Date;
    /**
    * Limit the channels this voucher can be used on
    */
    'ChannelRestrictions'?: Array<Voucher.ChannelRestrictionsEnum>;
    /**
    * Periods in which the voucher is valid.  An empty list means the voucher is valid at all times.  When updating the voucher, if this is set to null, the validity periods won't be updated.
    */
    'ValidityPeriods'?: Array<ValidityPeriod>;
    /**
    * Voucher Subtype
    */
    'VoucherSubType'?: Voucher.VoucherSubTypeEnum;
    /**
    * Customer UserID
    */
    'CustomerId'?: number;
    /**
    * Maximum number of times the voucher can be redeemed (used)
    */
    'MaxRedemptions'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "VoucherId",
            "baseName": "VoucherId",
            "type": "number"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "Voucher.StatusEnum"
        },
        {
            "name": "VoucherType",
            "baseName": "VoucherType",
            "type": "Voucher.VoucherTypeEnum"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "Voucher.CurrencyEnum"
        },
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<string>"
        },
        {
            "name": "PromotionDetails",
            "baseName": "PromotionDetails",
            "type": "PromotionDetails"
        },
        {
            "name": "CreditNoteDetails",
            "baseName": "CreditNoteDetails",
            "type": "CreditNoteDetails"
        },
        {
            "name": "LumpDiscountDetails",
            "baseName": "LumpDiscountDetails",
            "type": "LumpDiscountDetails"
        },
        {
            "name": "PercentDiscountDetails",
            "baseName": "PercentDiscountDetails",
            "type": "PercentDiscountDetails"
        },
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Stores",
            "baseName": "Stores",
            "type": "Array<number>"
        },
        {
            "name": "ValidOnOrdersOver",
            "baseName": "ValidOnOrdersOver",
            "type": "number"
        },
        {
            "name": "TakesPriority",
            "baseName": "TakesPriority",
            "type": "boolean"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "IsAutomaticallyApplied",
            "baseName": "IsAutomaticallyApplied",
            "type": "boolean"
        },
        {
            "name": "IncludeDeliveryFee",
            "baseName": "IncludeDeliveryFee",
            "type": "boolean"
        },
        {
            "name": "IsValidForDeliveryOrders",
            "baseName": "IsValidForDeliveryOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForPickupOrders",
            "baseName": "IsValidForPickupOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedOnline",
            "baseName": "IsValidForOrdersPayedOnline",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedByCash",
            "baseName": "IsValidForOrdersPayedByCash",
            "type": "boolean"
        },
        {
            "name": "IsValidForFirstOrderOnly",
            "baseName": "IsValidForFirstOrderOnly",
            "type": "boolean"
        },
        {
            "name": "IsValidOncePerCustomer",
            "baseName": "IsValidOncePerCustomer",
            "type": "boolean"
        },
        {
            "name": "IsValidOnlyOnce",
            "baseName": "IsValidOnlyOnce",
            "type": "boolean"
        },
        {
            "name": "StartDate",
            "baseName": "StartDate",
            "type": "Date"
        },
        {
            "name": "ExpiryDate",
            "baseName": "ExpiryDate",
            "type": "Date"
        },
        {
            "name": "ChannelRestrictions",
            "baseName": "ChannelRestrictions",
            "type": "Array<Voucher.ChannelRestrictionsEnum>"
        },
        {
            "name": "ValidityPeriods",
            "baseName": "ValidityPeriods",
            "type": "Array<ValidityPeriod>"
        },
        {
            "name": "VoucherSubType",
            "baseName": "VoucherSubType",
            "type": "Voucher.VoucherSubTypeEnum"
        },
        {
            "name": "CustomerId",
            "baseName": "CustomerId",
            "type": "number"
        },
        {
            "name": "MaxRedemptions",
            "baseName": "MaxRedemptions",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Voucher.attributeTypeMap;
    }
}

export namespace Voucher {
    export enum StatusEnum {
        Valid = <any> 'Valid',
        NotYetValid = <any> 'NotYetValid',
        Expired = <any> 'Expired',
        Used = <any> 'Used',
        Disabled = <any> 'Disabled'
    }
    export enum VoucherTypeEnum {
        PercentageDiscount = <any> 'PercentageDiscount',
        LumpDiscount = <any> 'LumpDiscount',
        AddItem = <any> 'AddItem',
        CreditNote = <any> 'CreditNote',
        FreeDelivery = <any> 'FreeDelivery'
    }
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
    export enum ChannelRestrictionsEnum {
        Ios = <any> 'Ios',
        Android = <any> 'Android',
        Web = <any> 'Web',
        Kiosk = <any> 'Kiosk',
        Pos = <any> 'Pos',
        Google = <any> 'Google'
    }
    export enum VoucherSubTypeEnum {
        None = <any> 'None',
        SignUp = <any> 'SignUp',
        Loyalty = <any> 'Loyalty',
        Loyalty25 = <any> 'Loyalty25',
        Retention = <any> 'Retention',
        SecondaryRetention = <any> 'SecondaryRetention',
        Custom = <any> 'Custom'
    }
}
/**
* Voucher Created Event
*/
export class VoucherCreatedEvent {
    /**
    * Voucher Id
    */
    'VoucherId'?: number;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * User which created this voucher
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Created voucher
    */
    'Voucher'?: Voucher;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "VoucherId",
            "baseName": "VoucherId",
            "type": "number"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Voucher",
            "baseName": "Voucher",
            "type": "Voucher"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return VoucherCreatedEvent.attributeTypeMap;
    }
}

/**
* A single data point in timeline graphs related to Vouchers
*/
export class VoucherDataPoint {
    /**
    * Date from which the data point starts
    */
    'PeriodStart'?: Date;
    /**
    * The length in days that this data point covers
    */
    'PeriodLengthInDays'?: number;
    /**
    * The value of this data point
    */
    'Value'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PeriodStart",
            "baseName": "PeriodStart",
            "type": "Date"
        },
        {
            "name": "PeriodLengthInDays",
            "baseName": "PeriodLengthInDays",
            "type": "number"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return VoucherDataPoint.attributeTypeMap;
    }
}

/**
* Voucher Deleted Event
*/
export class VoucherDeletedEvent {
    /**
    * Voucher Id
    */
    'VoucherId'?: number;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * User which deleted this voucher
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Deleted voucher
    */
    'Voucher'?: Voucher;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "VoucherId",
            "baseName": "VoucherId",
            "type": "number"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Voucher",
            "baseName": "Voucher",
            "type": "Voucher"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return VoucherDeletedEvent.attributeTypeMap;
    }
}

/**
* Voucher Summary
*/
export class VoucherSummary {
    /**
    * Voucher Id
    */
    'VoucherId'?: number;
    /**
    * Voucher Code
    */
    'Code'?: string;
    /**
    * Voucher Status
    */
    'Status'?: VoucherSummary.StatusEnum;
    /**
    * Voucher Type
    */
    'VoucherType'?: VoucherSummary.VoucherTypeEnum;
    /**
    * Voucher Sub Type
    */
    'VoucherSubType'?: VoucherSummary.VoucherSubTypeEnum;
    /**
    * Voucher Description (Visible on printout)
    */
    'Description'?: string;
    /**
    * Is voucher enabled
    */
    'IsEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "VoucherId",
            "baseName": "VoucherId",
            "type": "number"
        },
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "VoucherSummary.StatusEnum"
        },
        {
            "name": "VoucherType",
            "baseName": "VoucherType",
            "type": "VoucherSummary.VoucherTypeEnum"
        },
        {
            "name": "VoucherSubType",
            "baseName": "VoucherSubType",
            "type": "VoucherSummary.VoucherSubTypeEnum"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return VoucherSummary.attributeTypeMap;
    }
}

export namespace VoucherSummary {
    export enum StatusEnum {
        Valid = <any> 'Valid',
        NotYetValid = <any> 'NotYetValid',
        Expired = <any> 'Expired',
        Used = <any> 'Used',
        Disabled = <any> 'Disabled'
    }
    export enum VoucherTypeEnum {
        PercentageDiscount = <any> 'PercentageDiscount',
        LumpDiscount = <any> 'LumpDiscount',
        AddItem = <any> 'AddItem',
        CreditNote = <any> 'CreditNote',
        FreeDelivery = <any> 'FreeDelivery'
    }
    export enum VoucherSubTypeEnum {
        None = <any> 'None',
        SignUp = <any> 'SignUp',
        Loyalty = <any> 'Loyalty',
        Loyalty25 = <any> 'Loyalty25',
        Retention = <any> 'Retention',
        SecondaryRetention = <any> 'SecondaryRetention',
        Custom = <any> 'Custom'
    }
}
/**
* Voucher Updated Event
*/
export class VoucherUpdatedEvent {
    /**
    * Voucher Id
    */
    'VoucherId'?: number;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * User which updated this voucher
    */
    'User'?: UserEventInfo;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * Updated voucher
    */
    'Voucher'?: Voucher;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "VoucherId",
            "baseName": "VoucherId",
            "type": "number"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Voucher",
            "baseName": "Voucher",
            "type": "Voucher"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return VoucherUpdatedEvent.attributeTypeMap;
    }
}

/**
* Voucher With Statistics
*/
export class VoucherWithStats {
    /**
    * Total times the voucher was used
    */
    'TotalUsed'?: number;
    /**
    * Total amount of customers who used this voucher
    */
    'TotalCustomers'?: number;
    /**
    * Total amount of money from orders
    */
    'TotalAmountFromOrders'?: number;
    /**
    * Total amount of money given away
    */
    'TotalDiscounted'?: number;
    /**
    * Average Order Size
    */
    'AverageOrderSize'?: number;
    /**
    * Voucher Id
    */
    'VoucherId'?: number;
    /**
    * Voucher Status
    */
    'Status'?: VoucherWithStats.StatusEnum;
    /**
    * Voucher Type
    */
    'VoucherType'?: VoucherWithStats.VoucherTypeEnum;
    /**
    * Currency of the voucher
    */
    'Currency'?: VoucherWithStats.CurrencyEnum;
    /**
    * Stores that this voucher applies to
    */
    'StoreNames'?: Array<string>;
    /**
    * Promotion details
    */
    'PromotionDetails'?: PromotionDetails;
    /**
    * Credit note details
    */
    'CreditNoteDetails'?: CreditNoteDetails;
    /**
    * Lump discount details
    */
    'LumpDiscountDetails'?: LumpDiscountDetails;
    /**
    * Percent discount details
    */
    'PercentDiscountDetails'?: PercentDiscountDetails;
    /**
    * Voucher Code
    */
    'Code'?: string;
    /**
    * Voucher Description (Visible on printout)
    */
    'Description'?: string;
    /**
    * Stores that this voucher applies to
    */
    'Stores'?: Array<number>;
    /**
    * Valid on orders on or above
    */
    'ValidOnOrdersOver'?: number;
    /**
    * Takes priority
    */
    'TakesPriority'?: boolean;
    /**
    * Is voucher enabled
    */
    'IsEnabled'?: boolean;
    /**
    * Is voucher automatically applied
    */
    'IsAutomaticallyApplied'?: boolean;
    /**
    * Include delivery fees
    */
    'IncludeDeliveryFee'?: boolean;
    /**
    * Valid for delivery orders
    */
    'IsValidForDeliveryOrders'?: boolean;
    /**
    * Valid for pickup orders
    */
    'IsValidForPickupOrders'?: boolean;
    /**
    * Valid for orders payed online
    */
    'IsValidForOrdersPayedOnline'?: boolean;
    /**
    * Valid for orders payed in cash
    */
    'IsValidForOrdersPayedByCash'?: boolean;
    /**
    * Valid only on the first order by the customer
    */
    'IsValidForFirstOrderOnly'?: boolean;
    /**
    * Valid once per customer
    */
    'IsValidOncePerCustomer'?: boolean;
    /**
    * Valid only once, by any customer (once used cannot be used again by any other customer)
    */
    'IsValidOnlyOnce'?: boolean;
    /**
    * Voucher Starts On (Time in UTC)
    */
    'StartDate'?: Date;
    /**
    * Voucher Expires On (Time in UTC)
    */
    'ExpiryDate'?: Date;
    /**
    * Limit the channels this voucher can be used on
    */
    'ChannelRestrictions'?: Array<VoucherWithStats.ChannelRestrictionsEnum>;
    /**
    * Periods in which the voucher is valid.  An empty list means the voucher is valid at all times.  When updating the voucher, if this is set to null, the validity periods won't be updated.
    */
    'ValidityPeriods'?: Array<ValidityPeriod>;
    /**
    * Voucher Subtype
    */
    'VoucherSubType'?: VoucherWithStats.VoucherSubTypeEnum;
    /**
    * Customer UserID
    */
    'CustomerId'?: number;
    /**
    * Maximum number of times the voucher can be redeemed (used)
    */
    'MaxRedemptions'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TotalUsed",
            "baseName": "TotalUsed",
            "type": "number"
        },
        {
            "name": "TotalCustomers",
            "baseName": "TotalCustomers",
            "type": "number"
        },
        {
            "name": "TotalAmountFromOrders",
            "baseName": "TotalAmountFromOrders",
            "type": "number"
        },
        {
            "name": "TotalDiscounted",
            "baseName": "TotalDiscounted",
            "type": "number"
        },
        {
            "name": "AverageOrderSize",
            "baseName": "AverageOrderSize",
            "type": "number"
        },
        {
            "name": "VoucherId",
            "baseName": "VoucherId",
            "type": "number"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "VoucherWithStats.StatusEnum"
        },
        {
            "name": "VoucherType",
            "baseName": "VoucherType",
            "type": "VoucherWithStats.VoucherTypeEnum"
        },
        {
            "name": "Currency",
            "baseName": "Currency",
            "type": "VoucherWithStats.CurrencyEnum"
        },
        {
            "name": "StoreNames",
            "baseName": "StoreNames",
            "type": "Array<string>"
        },
        {
            "name": "PromotionDetails",
            "baseName": "PromotionDetails",
            "type": "PromotionDetails"
        },
        {
            "name": "CreditNoteDetails",
            "baseName": "CreditNoteDetails",
            "type": "CreditNoteDetails"
        },
        {
            "name": "LumpDiscountDetails",
            "baseName": "LumpDiscountDetails",
            "type": "LumpDiscountDetails"
        },
        {
            "name": "PercentDiscountDetails",
            "baseName": "PercentDiscountDetails",
            "type": "PercentDiscountDetails"
        },
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Stores",
            "baseName": "Stores",
            "type": "Array<number>"
        },
        {
            "name": "ValidOnOrdersOver",
            "baseName": "ValidOnOrdersOver",
            "type": "number"
        },
        {
            "name": "TakesPriority",
            "baseName": "TakesPriority",
            "type": "boolean"
        },
        {
            "name": "IsEnabled",
            "baseName": "IsEnabled",
            "type": "boolean"
        },
        {
            "name": "IsAutomaticallyApplied",
            "baseName": "IsAutomaticallyApplied",
            "type": "boolean"
        },
        {
            "name": "IncludeDeliveryFee",
            "baseName": "IncludeDeliveryFee",
            "type": "boolean"
        },
        {
            "name": "IsValidForDeliveryOrders",
            "baseName": "IsValidForDeliveryOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForPickupOrders",
            "baseName": "IsValidForPickupOrders",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedOnline",
            "baseName": "IsValidForOrdersPayedOnline",
            "type": "boolean"
        },
        {
            "name": "IsValidForOrdersPayedByCash",
            "baseName": "IsValidForOrdersPayedByCash",
            "type": "boolean"
        },
        {
            "name": "IsValidForFirstOrderOnly",
            "baseName": "IsValidForFirstOrderOnly",
            "type": "boolean"
        },
        {
            "name": "IsValidOncePerCustomer",
            "baseName": "IsValidOncePerCustomer",
            "type": "boolean"
        },
        {
            "name": "IsValidOnlyOnce",
            "baseName": "IsValidOnlyOnce",
            "type": "boolean"
        },
        {
            "name": "StartDate",
            "baseName": "StartDate",
            "type": "Date"
        },
        {
            "name": "ExpiryDate",
            "baseName": "ExpiryDate",
            "type": "Date"
        },
        {
            "name": "ChannelRestrictions",
            "baseName": "ChannelRestrictions",
            "type": "Array<VoucherWithStats.ChannelRestrictionsEnum>"
        },
        {
            "name": "ValidityPeriods",
            "baseName": "ValidityPeriods",
            "type": "Array<ValidityPeriod>"
        },
        {
            "name": "VoucherSubType",
            "baseName": "VoucherSubType",
            "type": "VoucherWithStats.VoucherSubTypeEnum"
        },
        {
            "name": "CustomerId",
            "baseName": "CustomerId",
            "type": "number"
        },
        {
            "name": "MaxRedemptions",
            "baseName": "MaxRedemptions",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return VoucherWithStats.attributeTypeMap;
    }
}

export namespace VoucherWithStats {
    export enum StatusEnum {
        Valid = <any> 'Valid',
        NotYetValid = <any> 'NotYetValid',
        Expired = <any> 'Expired',
        Used = <any> 'Used',
        Disabled = <any> 'Disabled'
    }
    export enum VoucherTypeEnum {
        PercentageDiscount = <any> 'PercentageDiscount',
        LumpDiscount = <any> 'LumpDiscount',
        AddItem = <any> 'AddItem',
        CreditNote = <any> 'CreditNote',
        FreeDelivery = <any> 'FreeDelivery'
    }
    export enum CurrencyEnum {
        EUR = <any> 'EUR',
        USD = <any> 'USD',
        GBP = <any> 'GBP',
        CAD = <any> 'CAD',
        AUD = <any> 'AUD',
        DJF = <any> 'DJF',
        ZAR = <any> 'ZAR',
        ETB = <any> 'ETB',
        AED = <any> 'AED',
        BHD = <any> 'BHD',
        DZD = <any> 'DZD',
        EGP = <any> 'EGP',
        IQD = <any> 'IQD',
        JOD = <any> 'JOD',
        KWD = <any> 'KWD',
        LBP = <any> 'LBP',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        OMR = <any> 'OMR',
        QAR = <any> 'QAR',
        SAR = <any> 'SAR',
        SYP = <any> 'SYP',
        TND = <any> 'TND',
        YER = <any> 'YER',
        CLP = <any> 'CLP',
        INR = <any> 'INR',
        AZN = <any> 'AZN',
        RUB = <any> 'RUB',
        BYN = <any> 'BYN',
        BGN = <any> 'BGN',
        NGN = <any> 'NGN',
        BDT = <any> 'BDT',
        CNY = <any> 'CNY',
        BAM = <any> 'BAM',
        CZK = <any> 'CZK',
        DKK = <any> 'DKK',
        CHF = <any> 'CHF',
        MVR = <any> 'MVR',
        BTN = <any> 'BTN',
        XCD = <any> 'XCD',
        BZD = <any> 'BZD',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        JMD = <any> 'JMD',
        MYR = <any> 'MYR',
        NZD = <any> 'NZD',
        PHP = <any> 'PHP',
        SGD = <any> 'SGD',
        TTD = <any> 'TTD',
        XDR = <any> 'XDR',
        ARS = <any> 'ARS',
        BOB = <any> 'BOB',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        DOP = <any> 'DOP',
        GTQ = <any> 'GTQ',
        HNL = <any> 'HNL',
        MXN = <any> 'MXN',
        NIO = <any> 'NIO',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PYG = <any> 'PYG',
        UYU = <any> 'UYU',
        VEF = <any> 'VEF',
        IRR = <any> 'IRR',
        XOF = <any> 'XOF',
        CDF = <any> 'CDF',
        XAF = <any> 'XAF',
        HTG = <any> 'HTG',
        ILS = <any> 'ILS',
        HRK = <any> 'HRK',
        HUF = <any> 'HUF',
        AMD = <any> 'AMD',
        ISK = <any> 'ISK',
        JPY = <any> 'JPY',
        GEL = <any> 'GEL',
        KZT = <any> 'KZT',
        KHR = <any> 'KHR',
        KRW = <any> 'KRW',
        KGS = <any> 'KGS',
        LAK = <any> 'LAK',
        MKD = <any> 'MKD',
        MNT = <any> 'MNT',
        BND = <any> 'BND',
        MMK = <any> 'MMK',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        AFN = <any> 'AFN',
        BRL = <any> 'BRL',
        MDL = <any> 'MDL',
        RON = <any> 'RON',
        RWF = <any> 'RWF',
        SEK = <any> 'SEK',
        LKR = <any> 'LKR',
        SOS = <any> 'SOS',
        ALL = <any> 'ALL',
        RSD = <any> 'RSD',
        KES = <any> 'KES',
        TJS = <any> 'TJS',
        THB = <any> 'THB',
        ERN = <any> 'ERN',
        TMT = <any> 'TMT',
        BWP = <any> 'BWP',
        TRY = <any> 'TRY',
        UAH = <any> 'UAH',
        UZS = <any> 'UZS',
        VND = <any> 'VND',
        MOP = <any> 'MOP',
        TWD = <any> 'TWD',
        BMD = <any> 'BMD'
    }
    export enum ChannelRestrictionsEnum {
        Ios = <any> 'Ios',
        Android = <any> 'Android',
        Web = <any> 'Web',
        Kiosk = <any> 'Kiosk',
        Pos = <any> 'Pos',
        Google = <any> 'Google'
    }
    export enum VoucherSubTypeEnum {
        None = <any> 'None',
        SignUp = <any> 'SignUp',
        Loyalty = <any> 'Loyalty',
        Loyalty25 = <any> 'Loyalty25',
        Retention = <any> 'Retention',
        SecondaryRetention = <any> 'SecondaryRetention',
        Custom = <any> 'Custom'
    }
}
export class WaitHandle {
    'Handle'?: any;
    'SafeWaitHandle'?: SafeWaitHandle;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Handle",
            "baseName": "Handle",
            "type": "any"
        },
        {
            "name": "SafeWaitHandle",
            "baseName": "SafeWaitHandle",
            "type": "SafeWaitHandle"
        }    ];

    static getAttributeTypeMap() {
        return WaitHandle.attributeTypeMap;
    }
}

/**
* Sample payload of a webhook event
*/
export class WebhookEventSample {
    /**
    * Event name
    */
    'Type'?: string;
    /**
    * Sample event creation date and time
    */
    'CreateTime'?: Date;
    /**
    * Sample event body
    */
    'Body'?: FlipdishEventBase;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Type",
            "baseName": "Type",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Body",
            "baseName": "Body",
            "type": "FlipdishEventBase"
        }    ];

    static getAttributeTypeMap() {
        return WebhookEventSample.attributeTypeMap;
    }
}

/**
* Webhook log
*/
export class WebhookLog {
    /**
    * Webhook subscription owner user identifier
    */
    'WebhookSubscriptionOwnerUserId'?: number;
    /**
    * Event created
    */
    'EventCreated'?: string;
    /**
    * Webhook triggered
    */
    'WebhookTriggered'?: string;
    /**
    * Webhook event name
    */
    'WebhookEventName'?: string;
    /**
    * Webhook subscription callback url
    */
    'WebhookSubscriptionCallbackUrl'?: string;
    /**
    * Received HTTP repsonse status HTTP code
    */
    'HttpResponseStatusCode'?: string;
    /**
    * Received HTTP repsonse status
    */
    'HttpResponseStatus'?: string;
    /**
    * Request headers
    */
    'RequestHeaders'?: string;
    /**
    * Request body
    */
    'RequestBody'?: string;
    /**
    * Received response headers
    */
    'ResponseHeaders'?: string;
    /**
    * Received response body
    */
    'ResponseBody'?: string;
    /**
    * Duration of HTTP request
    */
    'Duration'?: string;
    /**
    * Retry count
    */
    'RetryCount'?: number;
    /**
    * Flipdish webhook identifier
    */
    'FlipdishWebhookId'?: string;
    /**
    * Flipdish webhook version
    */
    'Version'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "WebhookSubscriptionOwnerUserId",
            "baseName": "WebhookSubscriptionOwnerUserId",
            "type": "number"
        },
        {
            "name": "EventCreated",
            "baseName": "EventCreated",
            "type": "string"
        },
        {
            "name": "WebhookTriggered",
            "baseName": "WebhookTriggered",
            "type": "string"
        },
        {
            "name": "WebhookEventName",
            "baseName": "WebhookEventName",
            "type": "string"
        },
        {
            "name": "WebhookSubscriptionCallbackUrl",
            "baseName": "WebhookSubscriptionCallbackUrl",
            "type": "string"
        },
        {
            "name": "HttpResponseStatusCode",
            "baseName": "HttpResponseStatusCode",
            "type": "string"
        },
        {
            "name": "HttpResponseStatus",
            "baseName": "HttpResponseStatus",
            "type": "string"
        },
        {
            "name": "RequestHeaders",
            "baseName": "RequestHeaders",
            "type": "string"
        },
        {
            "name": "RequestBody",
            "baseName": "RequestBody",
            "type": "string"
        },
        {
            "name": "ResponseHeaders",
            "baseName": "ResponseHeaders",
            "type": "string"
        },
        {
            "name": "ResponseBody",
            "baseName": "ResponseBody",
            "type": "string"
        },
        {
            "name": "Duration",
            "baseName": "Duration",
            "type": "string"
        },
        {
            "name": "RetryCount",
            "baseName": "RetryCount",
            "type": "number"
        },
        {
            "name": "FlipdishWebhookId",
            "baseName": "FlipdishWebhookId",
            "type": "string"
        },
        {
            "name": "Version",
            "baseName": "Version",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebhookLog.attributeTypeMap;
    }
}

/**
* Webhook subscription
*/
export class WebhookSubscription {
    /**
    * Webhook subscription identifier
    */
    'Id'?: number;
    /**
    * Webhook subscription owner user identifier
    */
    'OwnerUserId'?: number;
    /**
    * Webhook subscription owner user identifier
    */
    'Version'?: string;
    /**
    * Webhook subscription event names
    */
    'EventNames'?: Array<string>;
    /**
    * Callback url. Flipdish system POST messages to this url.
    */
    'CallbackUrl'?: string;
    /**
    * Is webhook subscription enabled.
    */
    'Enabled'?: boolean;
    /**
    * This is your token which will be in the Header of each POST request from Flipdish with name: X-Verify-Token.
    */
    'VerifyToken'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "OwnerUserId",
            "baseName": "OwnerUserId",
            "type": "number"
        },
        {
            "name": "Version",
            "baseName": "Version",
            "type": "string"
        },
        {
            "name": "EventNames",
            "baseName": "EventNames",
            "type": "Array<string>"
        },
        {
            "name": "CallbackUrl",
            "baseName": "CallbackUrl",
            "type": "string"
        },
        {
            "name": "Enabled",
            "baseName": "Enabled",
            "type": "boolean"
        },
        {
            "name": "VerifyToken",
            "baseName": "VerifyToken",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebhookSubscription.attributeTypeMap;
    }
}

/**
* 
*/
export class WebhookSubscriptionCreatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Webhook subscription details
    */
    'WebhookSubscriptionEventInfo'?: WebhookSubscriptionEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "WebhookSubscriptionEventInfo",
            "baseName": "WebhookSubscriptionEventInfo",
            "type": "WebhookSubscriptionEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebhookSubscriptionCreatedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class WebhookSubscriptionDeletedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Webhook subscription details
    */
    'WebhookSubscriptionEventInfo'?: WebhookSubscriptionEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "WebhookSubscriptionEventInfo",
            "baseName": "WebhookSubscriptionEventInfo",
            "type": "WebhookSubscriptionEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebhookSubscriptionDeletedEvent.attributeTypeMap;
    }
}

/**
* 
*/
export class WebhookSubscriptionEventInfo {
    /**
    * Webhook subscription owner user identifier
    */
    'OwnerUserId'?: number;
    /**
    * Webhook subscription identifier
    */
    'WebhookSubscriptionId'?: number;
    /**
    * Oauth client identifier
    */
    'ClientId'?: string;
    /**
    * Webhook callback url
    */
    'CallbackUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "OwnerUserId",
            "baseName": "OwnerUserId",
            "type": "number"
        },
        {
            "name": "WebhookSubscriptionId",
            "baseName": "WebhookSubscriptionId",
            "type": "number"
        },
        {
            "name": "ClientId",
            "baseName": "ClientId",
            "type": "string"
        },
        {
            "name": "CallbackUrl",
            "baseName": "CallbackUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebhookSubscriptionEventInfo.attributeTypeMap;
    }
}

/**
* 
*/
export class WebhookSubscriptionUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Webhook subscription details
    */
    'WebhookSubscriptionEventInfo'?: WebhookSubscriptionEventInfo;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "WebhookSubscriptionEventInfo",
            "baseName": "WebhookSubscriptionEventInfo",
            "type": "WebhookSubscriptionEventInfo"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebhookSubscriptionUpdatedEvent.attributeTypeMap;
    }
}

/**
* Represents a website image
*/
export class WebsiteImage {
    /**
    * Represents the id of the image
    */
    'ImageId'?: number;
    /**
    * Represents the location of the image
    */
    'ImageLocation'?: WebsiteImage.ImageLocationEnum;
    /**
    * Represents the image url
    */
    'ImageUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ImageId",
            "baseName": "ImageId",
            "type": "number"
        },
        {
            "name": "ImageLocation",
            "baseName": "ImageLocation",
            "type": "WebsiteImage.ImageLocationEnum"
        },
        {
            "name": "ImageUrl",
            "baseName": "ImageUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebsiteImage.attributeTypeMap;
    }
}

export namespace WebsiteImage {
    export enum ImageLocationEnum {
        IndexHeader = <any> 'IndexHeader',
        IndexAboutSectionLeft = <any> 'IndexAboutSectionLeft',
        IndexAboutSectionRight = <any> 'IndexAboutSectionRight',
        IndexGallery = <any> 'IndexGallery',
        IndexOpeningHoursHeader = <any> 'IndexOpeningHoursHeader',
        IndexTestimonialsHeader = <any> 'IndexTestimonialsHeader'
    }
}
/**
* Represents a testimonial
*/
export class WebsiteTestimonial {
    /**
    * Id of the testimonial
    */
    'TestimonialId'?: number;
    /**
    * Author of the testimonial
    */
    'Author'?: string;
    /**
    * Message of the testimonial
    */
    'Message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TestimonialId",
            "baseName": "TestimonialId",
            "type": "number"
        },
        {
            "name": "Author",
            "baseName": "Author",
            "type": "string"
        },
        {
            "name": "Message",
            "baseName": "Message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebsiteTestimonial.attributeTypeMap;
    }
}

/**
* Represents a testimonial base
*/
export class WebsiteTestimonialBase {
    /**
    * Author of the testimonial
    */
    'Author'?: string;
    /**
    * Message of the testimonial
    */
    'Message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Author",
            "baseName": "Author",
            "type": "string"
        },
        {
            "name": "Message",
            "baseName": "Message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebsiteTestimonialBase.attributeTypeMap;
    }
}

/**
* WebsiteUpdatedEvent
*/
export class WebsiteUpdatedEvent {
    /**
    * App Name id of the whitelabel of the website
    */
    'AppNameId'?: string;
    /**
    * User updating the website
    */
    'User'?: UserEventInfo;
    /**
    * Description of event
    */
    'Description'?: string;
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "AppNameId",
            "baseName": "AppNameId",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebsiteUpdatedEvent.attributeTypeMap;
    }
}

/**
* Website vanity url
*/
export class WebsiteVanityUrlUpdatedEvent {
    /**
    * The event name
    */
    'EventName'?: string;
    /**
    * Description
    */
    'Description'?: string;
    /**
    * User who has updated the url
    */
    'User'?: UserEventInfo;
    /**
    * New vanity url
    */
    'VanityUrl'?: string;
    /**
    * The identitfier of the event
    */
    'FlipdishEventId'?: string;
    /**
    * The time of creation of the event
    */
    'CreateTime'?: Date;
    /**
    * Position
    */
    'Position'?: number;
    /**
    * App id
    */
    'AppId'?: string;
    /**
    * Ip Address
    */
    'IpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "EventName",
            "baseName": "EventName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "User",
            "baseName": "User",
            "type": "UserEventInfo"
        },
        {
            "name": "VanityUrl",
            "baseName": "VanityUrl",
            "type": "string"
        },
        {
            "name": "FlipdishEventId",
            "baseName": "FlipdishEventId",
            "type": "string"
        },
        {
            "name": "CreateTime",
            "baseName": "CreateTime",
            "type": "Date"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "number"
        },
        {
            "name": "AppId",
            "baseName": "AppId",
            "type": "string"
        },
        {
            "name": "IpAddress",
            "baseName": "IpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebsiteVanityUrlUpdatedEvent.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
        "AccountFieldDefinition.KeyEnum": AccountFieldDefinition.KeyEnum,
        "AccountFieldDefinition.TypeEnum": AccountFieldDefinition.TypeEnum,
        "AccountFieldKeyValuePair.KeyEnum": AccountFieldKeyValuePair.KeyEnum,
        "ApmHourlyDataPoint.DayEnum": ApmHourlyDataPoint.DayEnum,
        "App.AppAccessLevelEnum": App.AppAccessLevelEnum,
        "App.AppResourceSetEnum": App.AppResourceSetEnum,
        "App.ApplicationCategoryEnum": App.ApplicationCategoryEnum,
        "AppCompliance.ComplianceTypeEnum": AppCompliance.ComplianceTypeEnum,
        "AppConfigSalesChannel.EmailRequestModeEnum": AppConfigSalesChannel.EmailRequestModeEnum,
        "AppConfigSalesChannel.WebToAppRedirectEnum": AppConfigSalesChannel.WebToAppRedirectEnum,
        "AppConfigSalesChannel.AddressEntryTypeEnum": AppConfigSalesChannel.AddressEntryTypeEnum,
        "AppConfigUpdateModel.ApplicationCategoryEnum": AppConfigUpdateModel.ApplicationCategoryEnum,
        "AppStoreApp.VerificationStatusEnum": AppStoreApp.VerificationStatusEnum,
        "AppStoreApp.ConfigurationTypeEnum": AppStoreApp.ConfigurationTypeEnum,
        "AppStoreApp.StoreSelectorTypeEnum": AppStoreApp.StoreSelectorTypeEnum,
        "AppStoreApp.TeammateAppAccessLevelEnum": AppStoreApp.TeammateAppAccessLevelEnum,
        "AppStoreApp.PermissionsTypeEnum": AppStoreApp.PermissionsTypeEnum,
        "AppStoreApp.CategoriesEnum": AppStoreApp.CategoriesEnum,
        "AppStoreApp.CountriesEnum": AppStoreApp.CountriesEnum,
        "AppStoreAppConfiguration.VerificationStatusEnum": AppStoreAppConfiguration.VerificationStatusEnum,
        "AppStoreAppConfiguration.ConfigurationTypeEnum": AppStoreAppConfiguration.ConfigurationTypeEnum,
        "AppStoreAppConfiguration.StoreSelectorTypeEnum": AppStoreAppConfiguration.StoreSelectorTypeEnum,
        "AppStoreAppConfiguration.TeammateAppAccessLevelEnum": AppStoreAppConfiguration.TeammateAppAccessLevelEnum,
        "AppStoreAppConfiguration.PermissionsTypeEnum": AppStoreAppConfiguration.PermissionsTypeEnum,
        "AppStoreAppConfiguration.CategoriesEnum": AppStoreAppConfiguration.CategoriesEnum,
        "AppStoreAppConfiguration.CountriesEnum": AppStoreAppConfiguration.CountriesEnum,
        "AppStoreAppConfigurationSummary.ConfigurationTypeEnum": AppStoreAppConfigurationSummary.ConfigurationTypeEnum,
        "AppStoreAppConfigurationSummary.StoreSelectorTypeEnum": AppStoreAppConfigurationSummary.StoreSelectorTypeEnum,
        "AppStoreAppSummary.VerificationStatusEnum": AppStoreAppSummary.VerificationStatusEnum,
        "AppStoreAppSummary.CategoriesEnum": AppStoreAppSummary.CategoriesEnum,
        "AppStoreAppSummary.CountriesEnum": AppStoreAppSummary.CountriesEnum,
        "BankAccount.AccountStateEnum": BankAccount.AccountStateEnum,
        "BankAccountCreate.CurrencyCodeEnum": BankAccountCreate.CurrencyCodeEnum,
        "BankAccountCreate.BusinessTypeEnum": BankAccountCreate.BusinessTypeEnum,
        "BankAccountDetail.AccountStateEnum": BankAccountDetail.AccountStateEnum,
        "BankAccountDetail.CurrencyCodeEnum": BankAccountDetail.CurrencyCodeEnum,
        "BankAccountDetail.BusinessTypeEnum": BankAccountDetail.BusinessTypeEnum,
        "BankAccountDetailsUpdateRequest.BusinessTypeEnum": BankAccountDetailsUpdateRequest.BusinessTypeEnum,
        "BankAccountSummary.AccountStateEnum": BankAccountSummary.AccountStateEnum,
        "BankAccountSummary.BusinessTypeEnum": BankAccountSummary.BusinessTypeEnum,
        "BluetoothTerminalStatus.DeviceTypeEnum": BluetoothTerminalStatus.DeviceTypeEnum,
        "BluetoothTerminalStatus.StatusEnum": BluetoothTerminalStatus.StatusEnum,
        "BusinessHoursOverride.DeliveryTypeEnum": BusinessHoursOverride.DeliveryTypeEnum,
        "BusinessHoursOverride.TypeEnum": BusinessHoursOverride.TypeEnum,
        "BusinessHoursOverrideBase.DeliveryTypeEnum": BusinessHoursOverrideBase.DeliveryTypeEnum,
        "BusinessHoursOverrideBase.TypeEnum": BusinessHoursOverrideBase.TypeEnum,
        "BusinessHoursPeriod.DayOfWeekEnum": BusinessHoursPeriod.DayOfWeekEnum,
        "BusinessHoursPeriodBase.DayOfWeekEnum": BusinessHoursPeriodBase.DayOfWeekEnum,
        "CatalogGroupReference.GroupTypeEnum": CatalogGroupReference.GroupTypeEnum,
        "CatalogItem.ItemTypeEnum": CatalogItem.ItemTypeEnum,
        "Channel.SourceEnum": Channel.SourceEnum,
        "CreateAppStoreApp.ConfigurationTypeEnum": CreateAppStoreApp.ConfigurationTypeEnum,
        "CreateAppStoreApp.StoreSelectorTypeEnum": CreateAppStoreApp.StoreSelectorTypeEnum,
        "CreateAppStoreApp.TeammateAppAccessLevelEnum": CreateAppStoreApp.TeammateAppAccessLevelEnum,
        "CreateAppStoreApp.PermissionsTypeEnum": CreateAppStoreApp.PermissionsTypeEnum,
        "CreateAppStoreApp.CategoriesEnum": CreateAppStoreApp.CategoriesEnum,
        "CreateAppStoreApp.CountriesEnum": CreateAppStoreApp.CountriesEnum,
        "CreateCatalogGroupReference.GroupTypeEnum": CreateCatalogGroupReference.GroupTypeEnum,
        "CreateCatalogItem.ItemTypeEnum": CreateCatalogItem.ItemTypeEnum,
        "CreateFulfillmentStatesConfiguration.StoreSelectorTypeEnum": CreateFulfillmentStatesConfiguration.StoreSelectorTypeEnum,
        "CreateFullMenu.MenuSectionBehaviourEnum": CreateFullMenu.MenuSectionBehaviourEnum,
        "CreateFullMenu.TaxTypeEnum": CreateFullMenu.TaxTypeEnum,
        "CreateFullMenuItemOptionSet.CellLayoutTypeEnum": CreateFullMenuItemOptionSet.CellLayoutTypeEnum,
        "CreateFullMenuItemOptionSetItem.CellLayoutTypeEnum": CreateFullMenuItemOptionSetItem.CellLayoutTypeEnum,
        "CreateFullMenuSectionItem.SpicinessRatingEnum": CreateFullMenuSectionItem.SpicinessRatingEnum,
        "CreateFullMenuSectionItem.CellLayoutTypeEnum": CreateFullMenuSectionItem.CellLayoutTypeEnum,
        "CreateGroup.GroupTypeEnum": CreateGroup.GroupTypeEnum,
        "CreateGroupReference.GroupTypeEnum": CreateGroupReference.GroupTypeEnum,
        "CreateMetafieldDefinition.OwnerEntityEnum": CreateMetafieldDefinition.OwnerEntityEnum,
        "CreateMetafieldDefinition.ValueTypeEnum": CreateMetafieldDefinition.ValueTypeEnum,
        "CreateMetafieldDefinition.BehaviorsEnum": CreateMetafieldDefinition.BehaviorsEnum,
        "CreateProduct.ProductTypeEnum": CreateProduct.ProductTypeEnum,
        "CreateProductReference.ProductTypeEnum": CreateProductReference.ProductTypeEnum,
        "CreateTeammate.AppAccessLevelEnum": CreateTeammate.AppAccessLevelEnum,
        "CreateVoucher.VoucherTypeEnum": CreateVoucher.VoucherTypeEnum,
        "CreateVoucher.ChannelRestrictionsEnum": CreateVoucher.ChannelRestrictionsEnum,
        "CreateVoucher.VoucherSubTypeEnum": CreateVoucher.VoucherSubTypeEnum,
        "CurrencyData.CurrencyEnum": CurrencyData.CurrencyEnum,
        "CustomerCreateModel.AppTypeEnum": CustomerCreateModel.AppTypeEnum,
        "CustomerDeliveryTrackingOrder.CurrencyEnum": CustomerDeliveryTrackingOrder.CurrencyEnum,
        "DuringOrderPromotionOptionsDm.DuringOrderPromotionTypeEnum": DuringOrderPromotionOptionsDm.DuringOrderPromotionTypeEnum,
        "ExecuteConfigurationActionResult.RedirectTargetEnum": ExecuteConfigurationActionResult.RedirectTargetEnum,
        "Field.FieldTypeEnum": Field.FieldTypeEnum,
        "FulfillmentInfo.DispatchTypeEnum": FulfillmentInfo.DispatchTypeEnum,
        "FulfillmentStatesConfiguration.StoreSelectorTypeEnum": FulfillmentStatesConfiguration.StoreSelectorTypeEnum,
        "FulfillmentStatesConfigurationSummary.StoreSelectorTypeEnum": FulfillmentStatesConfigurationSummary.StoreSelectorTypeEnum,
        "FulfillmentStatusConfigurationItem.ChangeTypeEnum": FulfillmentStatusConfigurationItem.ChangeTypeEnum,
        "FulfillmentStatusConfigurationItem.OrderTypesEnum": FulfillmentStatusConfigurationItem.OrderTypesEnum,
        "Group.GroupTypeEnum": Group.GroupTypeEnum,
        "GroupReference.GroupTypeEnum": GroupReference.GroupTypeEnum,
        "HomeAction.HomeActionTypeEnum": HomeAction.HomeActionTypeEnum,
        "HydraConfig.PaymentOptionsEnum": HydraConfig.PaymentOptionsEnum,
        "HydraConnectionStatusChangedEvent.HydraDeviceStatusEnum": HydraConnectionStatusChangedEvent.HydraDeviceStatusEnum,
        "HydraDeviceDetails.DeviceTypeEnum": HydraDeviceDetails.DeviceTypeEnum,
        "HydraDeviceDetails.StatusEnum": HydraDeviceDetails.StatusEnum,
        "HydraStatus.UserTypeEnum": HydraStatus.UserTypeEnum,
        "Invoice.CurrencyEnum": Invoice.CurrencyEnum,
        "Invoice.StatusEnum": Invoice.StatusEnum,
        "KioskBluetoothInstallUpdateInitiateEvent.BluetoothTerminalTypeEnum": KioskBluetoothInstallUpdateInitiateEvent.BluetoothTerminalTypeEnum,
        "KioskBluetoothPairingModeEvent.BluetoothTerminalTypeEnum": KioskBluetoothPairingModeEvent.BluetoothTerminalTypeEnum,
        "KioskBluetoothTerminalCancelUpdateEvent.BluetoothTerminalTypeEnum": KioskBluetoothTerminalCancelUpdateEvent.BluetoothTerminalTypeEnum,
        "KioskBluetoothTerminalFirmwareVersionStatusEvent.UpdateTimeEstimateEnum": KioskBluetoothTerminalFirmwareVersionStatusEvent.UpdateTimeEstimateEnum,
        "KioskBluetoothTerminalInstallationStatusEvent.BluetoothTerminalTypeEnum": KioskBluetoothTerminalInstallationStatusEvent.BluetoothTerminalTypeEnum,
        "KioskBluetoothTerminalUnpairedEvent.BluetoothTerminalTypeEnum": KioskBluetoothTerminalUnpairedEvent.BluetoothTerminalTypeEnum,
        "KioskBluetoothTerminalUpdatedEvent.BluetoothTerminalTypeEnum": KioskBluetoothTerminalUpdatedEvent.BluetoothTerminalTypeEnum,
        "KioskBluetoothUnpairingModeEvent.BluetoothTerminalTypeEnum": KioskBluetoothUnpairingModeEvent.BluetoothTerminalTypeEnum,
        "KioskTerminalActionStateChangedEvent.BluetoothTerminalTypeEnum": KioskTerminalActionStateChangedEvent.BluetoothTerminalTypeEnum,
        "LightspeedSettings.PriceTypeEnum": LightspeedSettings.PriceTypeEnum,
        "Menu.MenuSectionBehaviourEnum": Menu.MenuSectionBehaviourEnum,
        "Menu.TaxTypeEnum": Menu.TaxTypeEnum,
        "MenuBase.MenuSectionBehaviourEnum": MenuBase.MenuSectionBehaviourEnum,
        "MenuBase.TaxTypeEnum": MenuBase.TaxTypeEnum,
        "MenuCatalogItem.CellLayoutTypeEnum": MenuCatalogItem.CellLayoutTypeEnum,
        "MenuElementEditResponse.MenuElementTypeEnum": MenuElementEditResponse.MenuElementTypeEnum,
        "MenuElementEditResponse.ValidationCodeEnum": MenuElementEditResponse.ValidationCodeEnum,
        "MenuElementHide.MenuElementTypeEnum": MenuElementHide.MenuElementTypeEnum,
        "MenuElementListItemResponse.MenuElementTypeEnum": MenuElementListItemResponse.MenuElementTypeEnum,
        "MenuItemOptionSet.CellLayoutTypeEnum": MenuItemOptionSet.CellLayoutTypeEnum,
        "MenuItemOptionSetBase.CellLayoutTypeEnum": MenuItemOptionSetBase.CellLayoutTypeEnum,
        "MenuItemOptionSetItem.CellLayoutTypeEnum": MenuItemOptionSetItem.CellLayoutTypeEnum,
        "MenuItemOptionSetItemBase.CellLayoutTypeEnum": MenuItemOptionSetItemBase.CellLayoutTypeEnum,
        "MenuSectionAvailability.AvailabilityModeEnum": MenuSectionAvailability.AvailabilityModeEnum,
        "MenuSectionAvailabilityBase.AvailabilityModeEnum": MenuSectionAvailabilityBase.AvailabilityModeEnum,
        "MenuSectionItem.SpicinessRatingEnum": MenuSectionItem.SpicinessRatingEnum,
        "MenuSectionItem.CellLayoutTypeEnum": MenuSectionItem.CellLayoutTypeEnum,
        "MenuSectionItemBase.SpicinessRatingEnum": MenuSectionItemBase.SpicinessRatingEnum,
        "MenuSectionItemBase.CellLayoutTypeEnum": MenuSectionItemBase.CellLayoutTypeEnum,
        "MenuTaxDetails.TaxTypeEnum": MenuTaxDetails.TaxTypeEnum,
        "MetafieldDefinition.OwnerEntityEnum": MetafieldDefinition.OwnerEntityEnum,
        "MetafieldDefinition.ValueTypeEnum": MetafieldDefinition.ValueTypeEnum,
        "MetafieldDefinition.BehaviorsEnum": MetafieldDefinition.BehaviorsEnum,
        "MetafieldDefinitionRecommendation.OwnerEntityEnum": MetafieldDefinitionRecommendation.OwnerEntityEnum,
        "MetafieldDefinitionRecommendation.ValueTypeEnum": MetafieldDefinitionRecommendation.ValueTypeEnum,
        "MetafieldDefinitionRecommendation.BehaviorsEnum": MetafieldDefinitionRecommendation.BehaviorsEnum,
        "MobileAppsStatistics.PlatformTypeEnum": MobileAppsStatistics.PlatformTypeEnum,
        "MobileAppsSubmissionStatus.TypeEnum": MobileAppsSubmissionStatus.TypeEnum,
        "MobileAppsSubmissionStatus.AppStatusEnum": MobileAppsSubmissionStatus.AppStatusEnum,
        "MobileAppsSubmissionStatus.UpdateStatusEnum": MobileAppsSubmissionStatus.UpdateStatusEnum,
        "NextStatusWithOrderType.OrderTypeEnum": NextStatusWithOrderType.OrderTypeEnum,
        "OAuthApp.FlowEnum": OAuthApp.FlowEnum,
        "OAuthApp.RefreshTokenUsageEnum": OAuthApp.RefreshTokenUsageEnum,
        "OnboardingConfigUpdate.ConfigTypeEnum": OnboardingConfigUpdate.ConfigTypeEnum,
        "OnboardingItemUpdate.StatusEnum": OnboardingItemUpdate.StatusEnum,
        "Order.DeliveryTypeEnum": Order.DeliveryTypeEnum,
        "Order.PickupLocationTypeEnum": Order.PickupLocationTypeEnum,
        "Order.TableServiceCatagoryEnum": Order.TableServiceCatagoryEnum,
        "Order.PaymentAccountTypeEnum": Order.PaymentAccountTypeEnum,
        "Order.OrderStateEnum": Order.OrderStateEnum,
        "Order.AppTypeEnum": Order.AppTypeEnum,
        "Order.PaymentStatusEnum": Order.PaymentStatusEnum,
        "Order.RejectionReasonEnum": Order.RejectionReasonEnum,
        "Order.DeliveryTrackingStatusEnum": Order.DeliveryTrackingStatusEnum,
        "OrderDeliveryInformation.StatusEnum": OrderDeliveryInformation.StatusEnum,
        "OrderDeliveryInformationBase.StatusEnum": OrderDeliveryInformationBase.StatusEnum,
        "OrderDm.DeliveryTypeEnum": OrderDm.DeliveryTypeEnum,
        "OrderDm.PickupLocationTypeEnum": OrderDm.PickupLocationTypeEnum,
        "OrderDm.TableServiceCatagoryEnum": OrderDm.TableServiceCatagoryEnum,
        "OrderIngestSubmitOrderRequest.AppTypeEnum": OrderIngestSubmitOrderRequest.AppTypeEnum,
        "OrderIngestSubmitOrderRequest.CurrencyCodeEnum": OrderIngestSubmitOrderRequest.CurrencyCodeEnum,
        "OrderIngestSubmitOrderResponse.CurrencyCodeEnum": OrderIngestSubmitOrderResponse.CurrencyCodeEnum,
        "OrderSummary.DeliveryTypeEnum": OrderSummary.DeliveryTypeEnum,
        "OrderSummary.PickupLocationTypeEnum": OrderSummary.PickupLocationTypeEnum,
        "OrderSummary.TableServiceCatagoryEnum": OrderSummary.TableServiceCatagoryEnum,
        "OrderSummary.OrderStateEnum": OrderSummary.OrderStateEnum,
        "OrderSummary.PaymentAccountTypeEnum": OrderSummary.PaymentAccountTypeEnum,
        "OrderSummary.PaymentStatusEnum": OrderSummary.PaymentStatusEnum,
        "OrderSummary.CurrencyEnum": OrderSummary.CurrencyEnum,
        "OrderSummary.AppTypeEnum": OrderSummary.AppTypeEnum,
        "OrderVoucherSummary.TypeEnum": OrderVoucherSummary.TypeEnum,
        "OrderVoucherSummary.SubTypeEnum": OrderVoucherSummary.SubTypeEnum,
        "OwnerEntityConfiguration.OwnerEntityEnum": OwnerEntityConfiguration.OwnerEntityEnum,
        "OwnerEntityConfiguration.AllowedBehaviorsEnum": OwnerEntityConfiguration.AllowedBehaviorsEnum,
        "Payout.PayoutStatusEnum": Payout.PayoutStatusEnum,
        "Payout.PayoutTypeEnum": Payout.PayoutTypeEnum,
        "Payout.CurrencyEnum": Payout.CurrencyEnum,
        "PayoutChargeback.OrderCurrencyEnum": PayoutChargeback.OrderCurrencyEnum,
        "PayoutChargeback.OrderTypeEnum": PayoutChargeback.OrderTypeEnum,
        "PayoutDetail.PayoutStatusEnum": PayoutDetail.PayoutStatusEnum,
        "PayoutDetail.PayoutTypeEnum": PayoutDetail.PayoutTypeEnum,
        "PayoutDetail.CurrencyEnum": PayoutDetail.CurrencyEnum,
        "PayoutOrder.OrderTypeEnum": PayoutOrder.OrderTypeEnum,
        "PayoutOrder.OrderCurrencyEnum": PayoutOrder.OrderCurrencyEnum,
        "PayoutOtherCharge.CurrencyEnum": PayoutOtherCharge.CurrencyEnum,
        "PayoutOtherCharge.ChargeTypeEnum": PayoutOtherCharge.ChargeTypeEnum,
        "PayoutRefund.OrderCurrencyEnum": PayoutRefund.OrderCurrencyEnum,
        "PayoutRefund.OrderTypeEnum": PayoutRefund.OrderTypeEnum,
        "PayoutReport3PayoutOrder.OrderTypeEnum": PayoutReport3PayoutOrder.OrderTypeEnum,
        "PayoutReport3PayoutOrder.OrderCurrencyEnum": PayoutReport3PayoutOrder.OrderCurrencyEnum,
        "PayoutReport3PayoutOrder.RefundChargebackTypeEnum": PayoutReport3PayoutOrder.RefundChargebackTypeEnum,
        "PayoutRequestIds.StatesEnum": PayoutRequestIds.StatesEnum,
        "PayoutSummary.PayoutStatusEnum": PayoutSummary.PayoutStatusEnum,
        "PayoutSummary.CurrencyEnum": PayoutSummary.CurrencyEnum,
        "PhoneCall.CallStatusEnum": PhoneCall.CallStatusEnum,
        "PreOrderConfig.PreOrderTimeDisplayTypeEnum": PreOrderConfig.PreOrderTimeDisplayTypeEnum,
        "PreviousOrder.CurrencyEnum": PreviousOrder.CurrencyEnum,
        "ProcessingFeeConfig.PaymentAccountTypeEnum": ProcessingFeeConfig.PaymentAccountTypeEnum,
        "Product.ProductTypeEnum": Product.ProductTypeEnum,
        "ProductReference.ProductTypeEnum": ProductReference.ProductTypeEnum,
        "Range.DayOfWeekEnum": Range.DayOfWeekEnum,
        "RedeemInvitationResult.InvitationStatusEnum": RedeemInvitationResult.InvitationStatusEnum,
        "Reject.RejectReasonEnum": Reject.RejectReasonEnum,
        "SetVoucherValidityPeriodsSimplifiedRequest.DaysOfWeekEnum": SetVoucherValidityPeriodsSimplifiedRequest.DaysOfWeekEnum,
        "SignupStep.ActionEnum": SignupStep.ActionEnum,
        "StatisticsCurrencyDataPoint.CurrencyEnum": StatisticsCurrencyDataPoint.CurrencyEnum,
        "Store.PrintoutLayoutTypeEnum": Store.PrintoutLayoutTypeEnum,
        "Store.CurrencyEnum": Store.CurrencyEnum,
        "StoreEndOfDayReport.CurrencyEnum": StoreEndOfDayReport.CurrencyEnum,
        "StoreGroup.CurrencyEnum": StoreGroup.CurrencyEnum,
        "StoreGroupBase.CurrencyEnum": StoreGroupBase.CurrencyEnum,
        "StoreGroupExtended.CurrencyEnum": StoreGroupExtended.CurrencyEnum,
        "StoreOpeningHoursUpdatedEvent.DeliveryTypeEnum": StoreOpeningHoursUpdatedEvent.DeliveryTypeEnum,
        "StoreOrderCapacityConfig.DeliveryTypeEnum": StoreOrderCapacityConfig.DeliveryTypeEnum,
        "StoreOrderCapacityPeriod.DayOfTheWeekEnum": StoreOrderCapacityPeriod.DayOfTheWeekEnum,
        "StoreSummary.CurrencyEnum": StoreSummary.CurrencyEnum,
        "StripeAccountLinkRequest.CollectEnum": StripeAccountLinkRequest.CollectEnum,
        "StripeAccountLinkRequest.TypeEnum": StripeAccountLinkRequest.TypeEnum,
        "StripeConnectedAccount.CardPaymentsStatusEnum": StripeConnectedAccount.CardPaymentsStatusEnum,
        "StripeConnectedAccount.TransfersStatusEnum": StripeConnectedAccount.TransfersStatusEnum,
        "StripeConnectedAccount.AccountStatusEnum": StripeConnectedAccount.AccountStatusEnum,
        "StripeConnectedAccountInfo.AccountStatusEnum": StripeConnectedAccountInfo.AccountStatusEnum,
        "StripeConnectedAccountInfo.CardPaymentStatusEnum": StripeConnectedAccountInfo.CardPaymentStatusEnum,
        "StripeConnectedAccountInfo.PayoutScheduleIntervalEnum": StripeConnectedAccountInfo.PayoutScheduleIntervalEnum,
        "StripeCustomConnectedAccount.CardPaymentsStatusEnum": StripeCustomConnectedAccount.CardPaymentsStatusEnum,
        "StripeCustomConnectedAccount.TransfersStatusEnum": StripeCustomConnectedAccount.TransfersStatusEnum,
        "StripeCustomConnectedAccount.AccountStatusEnum": StripeCustomConnectedAccount.AccountStatusEnum,
        "StuartSettings.PackageTypeEnum": StuartSettings.PackageTypeEnum,
        "StuartSettings.TransportTypeEnum": StuartSettings.TransportTypeEnum,
        "SubmitOrderResponseDm.DeliveryTypeEnum": SubmitOrderResponseDm.DeliveryTypeEnum,
        "Subscription.StatusEnum": Subscription.StatusEnum,
        "Subscription.CurrencyEnum": Subscription.CurrencyEnum,
        "SubscriptionProduct.PaymentFrequencyEnum": SubscriptionProduct.PaymentFrequencyEnum,
        "SubscriptionProductPriceInfo.ScopeEnum": SubscriptionProductPriceInfo.ScopeEnum,
        "SubscriptionSummary.StatusEnum": SubscriptionSummary.StatusEnum,
        "SubscriptionSummary.CurrencyEnum": SubscriptionSummary.CurrencyEnum,
        "SupportedCountry.AddressLayoutEnum": SupportedCountry.AddressLayoutEnum,
        "SupportedCountry.PostCodeTypeEnum": SupportedCountry.PostCodeTypeEnum,
        "SupportedCountry.SupportRegionEnum": SupportedCountry.SupportRegionEnum,
        "Teammate.InvitationStatusEnum": Teammate.InvitationStatusEnum,
        "Teammate.AppAccessLevelEnum": Teammate.AppAccessLevelEnum,
        "TeammateBase.AppAccessLevelEnum": TeammateBase.AppAccessLevelEnum,
        "UpdateAppStoreApp.ConfigurationTypeEnum": UpdateAppStoreApp.ConfigurationTypeEnum,
        "UpdateAppStoreApp.StoreSelectorTypeEnum": UpdateAppStoreApp.StoreSelectorTypeEnum,
        "UpdateAppStoreApp.TeammateAppAccessLevelEnum": UpdateAppStoreApp.TeammateAppAccessLevelEnum,
        "UpdateAppStoreApp.PermissionsTypeEnum": UpdateAppStoreApp.PermissionsTypeEnum,
        "UpdateAppStoreApp.CategoriesEnum": UpdateAppStoreApp.CategoriesEnum,
        "UpdateAppStoreApp.CountriesEnum": UpdateAppStoreApp.CountriesEnum,
        "UpdateCatalogGroupReference.GroupTypeEnum": UpdateCatalogGroupReference.GroupTypeEnum,
        "UpdateFulfillmentStatesConfiguration.StoreSelectorTypeEnum": UpdateFulfillmentStatesConfiguration.StoreSelectorTypeEnum,
        "UpdateGroupReference.GroupTypeEnum": UpdateGroupReference.GroupTypeEnum,
        "UpdateMetafieldDefinition.BehaviorsEnum": UpdateMetafieldDefinition.BehaviorsEnum,
        "UpdateMobileAppsSubmissionStatus.TypeEnum": UpdateMobileAppsSubmissionStatus.TypeEnum,
        "UpdateMobileAppsSubmissionStatus.AppStatusEnum": UpdateMobileAppsSubmissionStatus.AppStatusEnum,
        "UpdateMobileAppsSubmissionStatus.UpdateStatusEnum": UpdateMobileAppsSubmissionStatus.UpdateStatusEnum,
        "UpdateProductReference.ProductTypeEnum": UpdateProductReference.ProductTypeEnum,
        "UpdateVoucher.ChannelRestrictionsEnum": UpdateVoucher.ChannelRestrictionsEnum,
        "UpdateVoucher.VoucherSubTypeEnum": UpdateVoucher.VoucherSubTypeEnum,
        "ValidityPeriod.DayOfWeekEnum": ValidityPeriod.DayOfWeekEnum,
        "Voucher.StatusEnum": Voucher.StatusEnum,
        "Voucher.VoucherTypeEnum": Voucher.VoucherTypeEnum,
        "Voucher.CurrencyEnum": Voucher.CurrencyEnum,
        "Voucher.ChannelRestrictionsEnum": Voucher.ChannelRestrictionsEnum,
        "Voucher.VoucherSubTypeEnum": Voucher.VoucherSubTypeEnum,
        "VoucherSummary.StatusEnum": VoucherSummary.StatusEnum,
        "VoucherSummary.VoucherTypeEnum": VoucherSummary.VoucherTypeEnum,
        "VoucherSummary.VoucherSubTypeEnum": VoucherSummary.VoucherSubTypeEnum,
        "VoucherWithStats.StatusEnum": VoucherWithStats.StatusEnum,
        "VoucherWithStats.VoucherTypeEnum": VoucherWithStats.VoucherTypeEnum,
        "VoucherWithStats.CurrencyEnum": VoucherWithStats.CurrencyEnum,
        "VoucherWithStats.ChannelRestrictionsEnum": VoucherWithStats.ChannelRestrictionsEnum,
        "VoucherWithStats.VoucherSubTypeEnum": VoucherWithStats.VoucherSubTypeEnum,
        "WebsiteImage.ImageLocationEnum": WebsiteImage.ImageLocationEnum,
}

let typeMap: {[index: string]: any} = {
    "Accept": Accept,
    "AccountDetail": AccountDetail,
    "AccountDetailBase": AccountDetailBase,
    "AccountFieldDefinition": AccountFieldDefinition,
    "AccountFieldKeyValuePair": AccountFieldKeyValuePair,
    "AccountFieldsDefinitions": AccountFieldsDefinitions,
    "AddressFormDisplayFormat": AddressFormDisplayFormat,
    "AddressFormResponse": AddressFormResponse,
    "AllMetadataResult": AllMetadataResult,
    "Allergen": Allergen,
    "AnalyticsClientEvent": AnalyticsClientEvent,
    "ApmCurrencyDataPoint": ApmCurrencyDataPoint,
    "ApmDataPoint": ApmDataPoint,
    "ApmHourlyDataPoint": ApmHourlyDataPoint,
    "ApmStatistics": ApmStatistics,
    "ApmStatus": ApmStatus,
    "App": App,
    "AppChannelAssignment": AppChannelAssignment,
    "AppCompliance": AppCompliance,
    "AppConfigSalesChannel": AppConfigSalesChannel,
    "AppConfigUpdateModel": AppConfigUpdateModel,
    "AppCreatedEvent": AppCreatedEvent,
    "AppLookup": AppLookup,
    "AppStoreApp": AppStoreApp,
    "AppStoreAppConfiguration": AppStoreAppConfiguration,
    "AppStoreAppConfigurationSummary": AppStoreAppConfigurationSummary,
    "AppStoreAppConfigurationsWithSubscriptions": AppStoreAppConfigurationsWithSubscriptions,
    "AppStoreAppEntitlements": AppStoreAppEntitlements,
    "AppStoreAppSubscriptionAccount": AppStoreAppSubscriptionAccount,
    "AppStoreAppSubscriptionSummary": AppStoreAppSubscriptionSummary,
    "AppStoreAppSummary": AppStoreAppSummary,
    "AppStoreAppSupportInfo": AppStoreAppSupportInfo,
    "AppStoreConfigCreatedEvent": AppStoreConfigCreatedEvent,
    "AppStoreConfigDeletedEvent": AppStoreConfigDeletedEvent,
    "AppStoreConfigUpdatedEvent": AppStoreConfigUpdatedEvent,
    "AppStoreSubscriptionChangeJobUpdatedEvent": AppStoreSubscriptionChangeJobUpdatedEvent,
    "AppUpdatedEvent": AppUpdatedEvent,
    "AssignedBankAccount": AssignedBankAccount,
    "AuditLogFieldChangeInformation": AuditLogFieldChangeInformation,
    "BalanceDetails": BalanceDetails,
    "BankAccount": BankAccount,
    "BankAccountAssignedEvent": BankAccountAssignedEvent,
    "BankAccountCreate": BankAccountCreate,
    "BankAccountCreatedEvent": BankAccountCreatedEvent,
    "BankAccountDeletedEvent": BankAccountDeletedEvent,
    "BankAccountDetail": BankAccountDetail,
    "BankAccountDetailsUpdateRequest": BankAccountDetailsUpdateRequest,
    "BankAccountSummary": BankAccountSummary,
    "BankAccountUpdatedEvent": BankAccountUpdatedEvent,
    "BluetoothTerminalStatus": BluetoothTerminalStatus,
    "BusinessHoursOverride": BusinessHoursOverride,
    "BusinessHoursOverrideBase": BusinessHoursOverrideBase,
    "BusinessHoursPeriod": BusinessHoursPeriod,
    "BusinessHoursPeriodBase": BusinessHoursPeriodBase,
    "CampaignStatistics": CampaignStatistics,
    "CancellationToken": CancellationToken,
    "CardReader": CardReader,
    "CardReaderRegistrationRequest": CardReaderRegistrationRequest,
    "Cart": Cart,
    "CatalogGroupArchivedEvent": CatalogGroupArchivedEvent,
    "CatalogGroupCreatedEvent": CatalogGroupCreatedEvent,
    "CatalogGroupReference": CatalogGroupReference,
    "CatalogGroupUpdatedEvent": CatalogGroupUpdatedEvent,
    "CatalogImage": CatalogImage,
    "CatalogItem": CatalogItem,
    "CatalogItemArchivedEvent": CatalogItemArchivedEvent,
    "CatalogItemCreatedEvent": CatalogItemCreatedEvent,
    "CatalogItemUpdatedEvent": CatalogItemUpdatedEvent,
    "CertificateCreatedEvent": CertificateCreatedEvent,
    "CertificateRenewedEvent": CertificateRenewedEvent,
    "ChangePasswordModel": ChangePasswordModel,
    "Channel": Channel,
    "ChannelStoreMapping": ChannelStoreMapping,
    "ChannelStoresUpdatedEvent": ChannelStoresUpdatedEvent,
    "ChargebackDetails": ChargebackDetails,
    "ClientDevice": ClientDevice,
    "ClientDeviceAssignEnrolledDevice": ClientDeviceAssignEnrolledDevice,
    "ClientDeviceEnroll": ClientDeviceEnroll,
    "ClientDeviceEnrollmentResult": ClientDeviceEnrollmentResult,
    "ClientDeviceSummary": ClientDeviceSummary,
    "ConfiguredStore": ConfiguredStore,
    "Contact": Contact,
    "Coordinates": Coordinates,
    "CoordinatesDm": CoordinatesDm,
    "CountryFormResponse": CountryFormResponse,
    "CountryWithAccountFieldsDefinitions": CountryWithAccountFieldsDefinitions,
    "CreateAccountModel": CreateAccountModel,
    "CreateAppInOrg": CreateAppInOrg,
    "CreateAppParameters": CreateAppParameters,
    "CreateAppStoreApp": CreateAppStoreApp,
    "CreateBasicAccountModel": CreateBasicAccountModel,
    "CreateCatalogGroupReference": CreateCatalogGroupReference,
    "CreateCatalogItem": CreateCatalogItem,
    "CreateFulfillmentStatesConfiguration": CreateFulfillmentStatesConfiguration,
    "CreateFullMenu": CreateFullMenu,
    "CreateFullMenuItemOptionSet": CreateFullMenuItemOptionSet,
    "CreateFullMenuItemOptionSetItem": CreateFullMenuItemOptionSetItem,
    "CreateFullMenuSection": CreateFullMenuSection,
    "CreateFullMenuSectionItem": CreateFullMenuSectionItem,
    "CreateGroup": CreateGroup,
    "CreateGroupReference": CreateGroupReference,
    "CreateLocation": CreateLocation,
    "CreateLocationArea": CreateLocationArea,
    "CreateMenuSectionItemFromCatalogItems": CreateMenuSectionItemFromCatalogItems,
    "CreateMenuTaxRate": CreateMenuTaxRate,
    "CreateMetadata": CreateMetadata,
    "CreateMetafieldDefinition": CreateMetafieldDefinition,
    "CreateOrderRequest": CreateOrderRequest,
    "CreatePayGreenConfigurationRequest": CreatePayGreenConfigurationRequest,
    "CreateProduct": CreateProduct,
    "CreateProductReference": CreateProductReference,
    "CreatePromotion": CreatePromotion,
    "CreateTeammate": CreateTeammate,
    "CreateVoucher": CreateVoucher,
    "CreatedMenuSectionItems": CreatedMenuSectionItems,
    "CreditNoteDetails": CreditNoteDetails,
    "CrossSellMenuItems": CrossSellMenuItems,
    "CspReport": CspReport,
    "CspReportRequest": CspReportRequest,
    "CurrencyData": CurrencyData,
    "Customer": Customer,
    "CustomerConsentUpdatedEvent": CustomerConsentUpdatedEvent,
    "CustomerCreateModel": CustomerCreateModel,
    "CustomerCreatedEvent": CustomerCreatedEvent,
    "CustomerDeliveryTrackingOrder": CustomerDeliveryTrackingOrder,
    "CustomerDeliveryTrackingOrderLine": CustomerDeliveryTrackingOrderLine,
    "CustomerSummary": CustomerSummary,
    "CustomerUpdateModel": CustomerUpdateModel,
    "CustomerUpdatedEvent": CustomerUpdatedEvent,
    "DashboardEmbed": DashboardEmbed,
    "DeliveryLocation": DeliveryLocation,
    "DeliveryZone": DeliveryZone,
    "DeliveryZoneBase": DeliveryZoneBase,
    "DeliveryZoneCreatedEvent": DeliveryZoneCreatedEvent,
    "DeliveryZoneDeletedEvent": DeliveryZoneDeletedEvent,
    "DeliveryZoneUpdatedEvent": DeliveryZoneUpdatedEvent,
    "DepositReturnFeesSummary": DepositReturnFeesSummary,
    "DeviceSettings": DeviceSettings,
    "DnsRecordInformation": DnsRecordInformation,
    "DnsVerifiedEvent": DnsVerifiedEvent,
    "DriverLoginModel": DriverLoginModel,
    "DriverRequestLoginPinModel": DriverRequestLoginPinModel,
    "DuringOrderPromotionOptionsDm": DuringOrderPromotionOptionsDm,
    "DynamicFormField": DynamicFormField,
    "DynamicFormFieldOption": DynamicFormFieldOption,
    "DynamicFormRule": DynamicFormRule,
    "DynamicFormRules": DynamicFormRules,
    "EmvNotificationEvent": EmvNotificationEvent,
    "EmvTerminal": EmvTerminal,
    "EmvTerminalWithAssignments": EmvTerminalWithAssignments,
    "EventSearchResult": EventSearchResult,
    "ExecuteConfigurationActionRequest": ExecuteConfigurationActionRequest,
    "ExecuteConfigurationActionResult": ExecuteConfigurationActionResult,
    "ExternalStoreAuditLog": ExternalStoreAuditLog,
    "ExternalStoreEvent": ExternalStoreEvent,
    "FeeSummary": FeeSummary,
    "Field": Field,
    "FieldChangeInformation": FieldChangeInformation,
    "FieldGroup": FieldGroup,
    "FileCreationResult": FileCreationResult,
    "FileDownloadResult": FileDownloadResult,
    "FirebaseApp": FirebaseApp,
    "FlipdishEventBase": FlipdishEventBase,
    "FlipdishFeesDetails": FlipdishFeesDetails,
    "FulfillentStatusActionItem": FulfillentStatusActionItem,
    "FulfillmentInfo": FulfillmentInfo,
    "FulfillmentStatesConfiguration": FulfillmentStatesConfiguration,
    "FulfillmentStatesConfigurationSummary": FulfillmentStatesConfigurationSummary,
    "FulfillmentStatesConfiguredStore": FulfillmentStatesConfiguredStore,
    "FulfillmentStatusConfigurationItem": FulfillmentStatusConfigurationItem,
    "GeoPointRequest": GeoPointRequest,
    "GetReceiptByOrderIdQueryResponse": GetReceiptByOrderIdQueryResponse,
    "GoogleAddress": GoogleAddress,
    "GoogleAddressComponent": GoogleAddressComponent,
    "GoogleAddressResult": GoogleAddressResult,
    "GoogleCoordinates": GoogleCoordinates,
    "GoogleGeometry": GoogleGeometry,
    "GoogleLocation": GoogleLocation,
    "GoogleViewport": GoogleViewport,
    "Group": Group,
    "GroupReference": GroupReference,
    "GroupedCoordinates": GroupedCoordinates,
    "HasPaymentMethodResponse": HasPaymentMethodResponse,
    "HomeAction": HomeAction,
    "HomeStatistics": HomeStatistics,
    "HttpPostedFileBase": HttpPostedFileBase,
    "HttpRequestAndResponseLog": HttpRequestAndResponseLog,
    "HydraAssignedEvent": HydraAssignedEvent,
    "HydraConfig": HydraConfig,
    "HydraConnectionStatusChangedEvent": HydraConnectionStatusChangedEvent,
    "HydraDeviceDetails": HydraDeviceDetails,
    "HydraRegistrationRequest": HydraRegistrationRequest,
    "HydraRequestResetEvent": HydraRequestResetEvent,
    "HydraSettingChangedEvent": HydraSettingChangedEvent,
    "HydraStatus": HydraStatus,
    "HydraStoreAssignedEvent": HydraStoreAssignedEvent,
    "HydraStoreData": HydraStoreData,
    "HydraStoreUnassignedEvent": HydraStoreUnassignedEvent,
    "HydraUnAssignedEvent": HydraUnAssignedEvent,
    "IndexPage": IndexPage,
    "IndexPageBase": IndexPageBase,
    "IntercomUserHash": IntercomUserHash,
    "Invoice": Invoice,
    "InvoiceDiscount": InvoiceDiscount,
    "InvoiceItem": InvoiceItem,
    "InvoicePeriod": InvoicePeriod,
    "ItemNutritionInfoAddUpdateModel": ItemNutritionInfoAddUpdateModel,
    "ItemNutritionInfoV2AddUpdateModel": ItemNutritionInfoV2AddUpdateModel,
    "JobAddress": JobAddress,
    "JobCancellation": JobCancellation,
    "JobContact": JobContact,
    "JobDelivery": JobDelivery,
    "JobDeliveryDetail": JobDeliveryDetail,
    "JobDriver": JobDriver,
    "JobEta": JobEta,
    "JobPricing": JobPricing,
    "JobProof": JobProof,
    "JobResponse": JobResponse,
    "KioskBluetoothInstallUpdateInitiateEvent": KioskBluetoothInstallUpdateInitiateEvent,
    "KioskBluetoothPairingModeEvent": KioskBluetoothPairingModeEvent,
    "KioskBluetoothTerminalCancelUpdateEvent": KioskBluetoothTerminalCancelUpdateEvent,
    "KioskBluetoothTerminalFirmwareVersionStatusEvent": KioskBluetoothTerminalFirmwareVersionStatusEvent,
    "KioskBluetoothTerminalInitiateUpdateCheckEvent": KioskBluetoothTerminalInitiateUpdateCheckEvent,
    "KioskBluetoothTerminalInstallationStatusEvent": KioskBluetoothTerminalInstallationStatusEvent,
    "KioskBluetoothTerminalUnpairedEvent": KioskBluetoothTerminalUnpairedEvent,
    "KioskBluetoothTerminalUpdatedEvent": KioskBluetoothTerminalUpdatedEvent,
    "KioskBluetoothUnpairingModeEvent": KioskBluetoothUnpairingModeEvent,
    "KioskCashPaymentSettings": KioskCashPaymentSettings,
    "KioskEntitlementsResult": KioskEntitlementsResult,
    "KioskIotConnectionParameters": KioskIotConnectionParameters,
    "KioskSettings": KioskSettings,
    "KioskTerminalActionStateChangedEvent": KioskTerminalActionStateChangedEvent,
    "Language": Language,
    "LastPaymentError": LastPaymentError,
    "LeadTime": LeadTime,
    "LightspeedSettings": LightspeedSettings,
    "LineItem": LineItem,
    "LineItemOption": LineItemOption,
    "LocalisedTimeZone": LocalisedTimeZone,
    "Location": Location,
    "LocationArea": LocationArea,
    "LocationAreaCreatedEvent": LocationAreaCreatedEvent,
    "LocationAreaLocation": LocationAreaLocation,
    "LocationAreaUpdatedEvent": LocationAreaUpdatedEvent,
    "LocationAreaWithLocations": LocationAreaWithLocations,
    "LocationCreatedEvent": LocationCreatedEvent,
    "LocationDeletedEvent": LocationDeletedEvent,
    "LoginModel": LoginModel,
    "LoginWithPinModel": LoginWithPinModel,
    "LoyaltyCampaign": LoyaltyCampaign,
    "LoyaltyCampaignBase": LoyaltyCampaignBase,
    "LoyaltyCampaignCreatedEvent": LoyaltyCampaignCreatedEvent,
    "LoyaltyCampaignDeletedEvent": LoyaltyCampaignDeletedEvent,
    "LoyaltyCampaignUpdatedEvent": LoyaltyCampaignUpdatedEvent,
    "LumpDiscountDetails": LumpDiscountDetails,
    "MappedLocation": MappedLocation,
    "MaskedPhoneNumber": MaskedPhoneNumber,
    "Menu": Menu,
    "MenuAsyncCreationCompletedEvent": MenuAsyncCreationCompletedEvent,
    "MenuBase": MenuBase,
    "MenuBulkEditEvent": MenuBulkEditEvent,
    "MenuCatalogItem": MenuCatalogItem,
    "MenuCheckpoint": MenuCheckpoint,
    "MenuCheckpointCreatedEvent": MenuCheckpointCreatedEvent,
    "MenuCreatedEvent": MenuCreatedEvent,
    "MenuElementEditResponse": MenuElementEditResponse,
    "MenuElementHide": MenuElementHide,
    "MenuElementListItemResponse": MenuElementListItemResponse,
    "MenuElementListResponse": MenuElementListResponse,
    "MenuItemOptionSet": MenuItemOptionSet,
    "MenuItemOptionSetBase": MenuItemOptionSetBase,
    "MenuItemOptionSetCreatedEvent": MenuItemOptionSetCreatedEvent,
    "MenuItemOptionSetDeletedEvent": MenuItemOptionSetDeletedEvent,
    "MenuItemOptionSetItem": MenuItemOptionSetItem,
    "MenuItemOptionSetItemBase": MenuItemOptionSetItemBase,
    "MenuItemOptionSetItemCreatedEvent": MenuItemOptionSetItemCreatedEvent,
    "MenuItemOptionSetItemDeletedEvent": MenuItemOptionSetItemDeletedEvent,
    "MenuItemOptionSetItemUpdatedEvent": MenuItemOptionSetItemUpdatedEvent,
    "MenuItemOptionSetUpdatedEvent": MenuItemOptionSetUpdatedEvent,
    "MenuNutritionInfoHeader": MenuNutritionInfoHeader,
    "MenuObjectDisplayOrders": MenuObjectDisplayOrders,
    "MenuSection": MenuSection,
    "MenuSectionAvailability": MenuSectionAvailability,
    "MenuSectionAvailabilityBase": MenuSectionAvailabilityBase,
    "MenuSectionBase": MenuSectionBase,
    "MenuSectionCreatedEvent": MenuSectionCreatedEvent,
    "MenuSectionDeletedEvent": MenuSectionDeletedEvent,
    "MenuSectionItem": MenuSectionItem,
    "MenuSectionItemBase": MenuSectionItemBase,
    "MenuSectionItemCreatedEvent": MenuSectionItemCreatedEvent,
    "MenuSectionItemDeletedEvent": MenuSectionItemDeletedEvent,
    "MenuSectionItemUpdatedEvent": MenuSectionItemUpdatedEvent,
    "MenuSectionUpdatedEvent": MenuSectionUpdatedEvent,
    "MenuStoreNames": MenuStoreNames,
    "MenuSummary": MenuSummary,
    "MenuTaxDetails": MenuTaxDetails,
    "MenuTaxRate": MenuTaxRate,
    "MenuUpdatedEvent": MenuUpdatedEvent,
    "MenuUploadedEvent": MenuUploadedEvent,
    "MenuZone": MenuZone,
    "Metadata": Metadata,
    "Metafield": Metafield,
    "MetafieldDefinition": MetafieldDefinition,
    "MetafieldDefinitionRecommendation": MetafieldDefinitionRecommendation,
    "MobileAppsImage": MobileAppsImage,
    "MobileAppsStatistics": MobileAppsStatistics,
    "MobileAppsSubmission": MobileAppsSubmission,
    "MobileAppsSubmissionDetails": MobileAppsSubmissionDetails,
    "MobileAppsSubmissionStatus": MobileAppsSubmissionStatus,
    "MobileAppsSubmissionStatusUpdatedEvent": MobileAppsSubmissionStatusUpdatedEvent,
    "MobileAppsSubmissionUpdatedEvent": MobileAppsSubmissionUpdatedEvent,
    "ModelBase": ModelBase,
    "NextStatusWithOrderType": NextStatusWithOrderType,
    "NutritionInfo": NutritionInfo,
    "NutritionInfoItemAddUpdateLabelModel": NutritionInfoItemAddUpdateLabelModel,
    "NutritionInfoLabel": NutritionInfoLabel,
    "NutritionInfoMenuItem": NutritionInfoMenuItem,
    "NutritionInfoMenuOptionSetItem": NutritionInfoMenuOptionSetItem,
    "NutritionInfoV2": NutritionInfoV2,
    "NutritionInfoV2Allergen": NutritionInfoV2Allergen,
    "NutritionInfoV2Item": NutritionInfoV2Item,
    "OAuthApp": OAuthApp,
    "OAuthTokenModel": OAuthTokenModel,
    "OauthClientRedirectUri": OauthClientRedirectUri,
    "ObjectDisplayOrder": ObjectDisplayOrder,
    "OktaPortalFeatureFlag": OktaPortalFeatureFlag,
    "OnboardingConfigUpdate": OnboardingConfigUpdate,
    "OnboardingItemUpdate": OnboardingItemUpdate,
    "Order": Order,
    "OrderAcceptedEvent": OrderAcceptedEvent,
    "OrderBatch": OrderBatch,
    "OrderBatchPublishedEvent": OrderBatchPublishedEvent,
    "OrderBatchSummary": OrderBatchSummary,
    "OrderBatchingConfiguration": OrderBatchingConfiguration,
    "OrderCapacityConfigUpdatedEvent": OrderCapacityConfigUpdatedEvent,
    "OrderCreatedEvent": OrderCreatedEvent,
    "OrderCustomerTrackingCreatedEvent": OrderCustomerTrackingCreatedEvent,
    "OrderDeliveryInformation": OrderDeliveryInformation,
    "OrderDeliveryInformationBase": OrderDeliveryInformationBase,
    "OrderDeliveryTrackingStatusUpdatedEvent": OrderDeliveryTrackingStatusUpdatedEvent,
    "OrderDispatchedEvent": OrderDispatchedEvent,
    "OrderDm": OrderDm,
    "OrderDropOffLocation": OrderDropOffLocation,
    "OrderFulfillmentStatus": OrderFulfillmentStatus,
    "OrderFulfillmentStatusBase": OrderFulfillmentStatusBase,
    "OrderFulfillmentStatusUpdate": OrderFulfillmentStatusUpdate,
    "OrderFulfillmentStatusUpdatedEvent": OrderFulfillmentStatusUpdatedEvent,
    "OrderFulfillmentStatusWithConfigurationActions": OrderFulfillmentStatusWithConfigurationActions,
    "OrderIngestSubmitOrderRequest": OrderIngestSubmitOrderRequest,
    "OrderIngestSubmitOrderResponse": OrderIngestSubmitOrderResponse,
    "OrderItem": OrderItem,
    "OrderItemDm": OrderItemDm,
    "OrderItemOption": OrderItemOption,
    "OrderLeadTimes": OrderLeadTimes,
    "OrderList": OrderList,
    "OrderPaymentInformation": OrderPaymentInformation,
    "OrderRatingUpdatedEvent": OrderRatingUpdatedEvent,
    "OrderReference": OrderReference,
    "OrderRefundedEvent": OrderRefundedEvent,
    "OrderRejectedEvent": OrderRejectedEvent,
    "OrderSummary": OrderSummary,
    "OrderTipUpdatedEvent": OrderTipUpdatedEvent,
    "OrderVoucherSummary": OrderVoucherSummary,
    "OtherChargesDetails": OtherChargesDetails,
    "OwnerEntityConfiguration": OwnerEntityConfiguration,
    "OwnerEntityConfigurations": OwnerEntityConfigurations,
    "PasswordResetModel": PasswordResetModel,
    "PaymentInfo": PaymentInfo,
    "PaymentIntent": PaymentIntent,
    "PaymentTerminalDetails": PaymentTerminalDetails,
    "PaymentTerminalTransactionDetails": PaymentTerminalTransactionDetails,
    "Payout": Payout,
    "PayoutChargeback": PayoutChargeback,
    "PayoutDetail": PayoutDetail,
    "PayoutOrder": PayoutOrder,
    "PayoutOtherCharge": PayoutOtherCharge,
    "PayoutRefund": PayoutRefund,
    "PayoutReport3Details": PayoutReport3Details,
    "PayoutReport3DetailsAdjustments": PayoutReport3DetailsAdjustments,
    "PayoutReport3DetailsFlipdishFees": PayoutReport3DetailsFlipdishFees,
    "PayoutReport3DetailsRevenue": PayoutReport3DetailsRevenue,
    "PayoutReport3DetailsSalesLine": PayoutReport3DetailsSalesLine,
    "PayoutReport3DetailsSummary": PayoutReport3DetailsSummary,
    "PayoutReport3Overview": PayoutReport3Overview,
    "PayoutReport3OverviewHeader": PayoutReport3OverviewHeader,
    "PayoutReport3PayoutOrder": PayoutReport3PayoutOrder,
    "PayoutReport3Store": PayoutReport3Store,
    "PayoutRequestIds": PayoutRequestIds,
    "PayoutStore": PayoutStore,
    "PayoutSummary": PayoutSummary,
    "PendingMenuChanges": PendingMenuChanges,
    "PendingMenuChangesSummaries": PendingMenuChangesSummaries,
    "PercentDiscountDetails": PercentDiscountDetails,
    "PhoneCall": PhoneCall,
    "PhoneCallEndedEvent": PhoneCallEndedEvent,
    "PhoneCallStartedEvent": PhoneCallStartedEvent,
    "PosRevenueDetails": PosRevenueDetails,
    "PreOrderConfig": PreOrderConfig,
    "PreOrderTime": PreOrderTime,
    "PredefinedAnswer": PredefinedAnswer,
    "PreviousOrder": PreviousOrder,
    "PreviousOrderItem": PreviousOrderItem,
    "PreviousOrderItemOption": PreviousOrderItemOption,
    "Price": Price,
    "Printer": Printer,
    "PrinterAssignedToStoreEvent": PrinterAssignedToStoreEvent,
    "PrinterTurnedOffEvent": PrinterTurnedOffEvent,
    "PrinterTurnedOnEvent": PrinterTurnedOnEvent,
    "PrinterUnassignedFromStoreEvent": PrinterUnassignedFromStoreEvent,
    "ProcessPaymentIntentRequest": ProcessPaymentIntentRequest,
    "ProcessingFeeConfig": ProcessingFeeConfig,
    "Product": Product,
    "ProductReference": ProductReference,
    "PromotionAward": PromotionAward,
    "PromotionDetails": PromotionDetails,
    "PublishMenuChanges": PublishMenuChanges,
    "PushNotificationDeletedEvent": PushNotificationDeletedEvent,
    "PushNotificationRequest": PushNotificationRequest,
    "PushNotificationResponse": PushNotificationResponse,
    "PushNotificationScheduledEvent": PushNotificationScheduledEvent,
    "PushNotificationSentEvent": PushNotificationSentEvent,
    "Range": Range,
    "ReaderActionStateInfo": ReaderActionStateInfo,
    "RedeemInvitationResult": RedeemInvitationResult,
    "Refund": Refund,
    "Reject": Reject,
    "RequestLoginPinModel": RequestLoginPinModel,
    "RequestLoginPinResponse": RequestLoginPinResponse,
    "RequestPasswordResetModel": RequestPasswordResetModel,
    "RequestPasswordResetPinResponse": RequestPasswordResetPinResponse,
    "Response": Response,
    "RestApiArrayResultAllMetadataResult": RestApiArrayResultAllMetadataResult,
    "RestApiArrayResultAllergen": RestApiArrayResultAllergen,
    "RestApiArrayResultApmCurrencyDataPoint": RestApiArrayResultApmCurrencyDataPoint,
    "RestApiArrayResultApmDataPoint": RestApiArrayResultApmDataPoint,
    "RestApiArrayResultApmHourlyDataPoint": RestApiArrayResultApmHourlyDataPoint,
    "RestApiArrayResultAppStoreAppConfigurationSummary": RestApiArrayResultAppStoreAppConfigurationSummary,
    "RestApiArrayResultAppStoreAppSummary": RestApiArrayResultAppStoreAppSummary,
    "RestApiArrayResultBankAccountSummary": RestApiArrayResultBankAccountSummary,
    "RestApiArrayResultBusinessHoursPeriod": RestApiArrayResultBusinessHoursPeriod,
    "RestApiArrayResultChannel": RestApiArrayResultChannel,
    "RestApiArrayResultClientDeviceSummary": RestApiArrayResultClientDeviceSummary,
    "RestApiArrayResultCountryWithAccountFieldsDefinitions": RestApiArrayResultCountryWithAccountFieldsDefinitions,
    "RestApiArrayResultDeliveryZone": RestApiArrayResultDeliveryZone,
    "RestApiArrayResultEmvTerminalWithAssignments": RestApiArrayResultEmvTerminalWithAssignments,
    "RestApiArrayResultFulfillmentStatesConfigurationSummary": RestApiArrayResultFulfillmentStatesConfigurationSummary,
    "RestApiArrayResultHomeAction": RestApiArrayResultHomeAction,
    "RestApiArrayResultKioskCashPaymentSettings": RestApiArrayResultKioskCashPaymentSettings,
    "RestApiArrayResultLocalisedTimeZone": RestApiArrayResultLocalisedTimeZone,
    "RestApiArrayResultLocationAreaLocation": RestApiArrayResultLocationAreaLocation,
    "RestApiArrayResultLocationAreaWithLocations": RestApiArrayResultLocationAreaWithLocations,
    "RestApiArrayResultLoyaltyCampaign": RestApiArrayResultLoyaltyCampaign,
    "RestApiArrayResultMenuCheckpoint": RestApiArrayResultMenuCheckpoint,
    "RestApiArrayResultMenuElementEditResponse": RestApiArrayResultMenuElementEditResponse,
    "RestApiArrayResultMenuElementListResponse": RestApiArrayResultMenuElementListResponse,
    "RestApiArrayResultMenuItemOptionSet": RestApiArrayResultMenuItemOptionSet,
    "RestApiArrayResultMenuItemOptionSetItem": RestApiArrayResultMenuItemOptionSetItem,
    "RestApiArrayResultMenuSection": RestApiArrayResultMenuSection,
    "RestApiArrayResultMenuSectionItem": RestApiArrayResultMenuSectionItem,
    "RestApiArrayResultMenuStoreNames": RestApiArrayResultMenuStoreNames,
    "RestApiArrayResultMenuSummary": RestApiArrayResultMenuSummary,
    "RestApiArrayResultMenuTaxDetails": RestApiArrayResultMenuTaxDetails,
    "RestApiArrayResultMenuZone": RestApiArrayResultMenuZone,
    "RestApiArrayResultMetadata": RestApiArrayResultMetadata,
    "RestApiArrayResultMobileAppsStatistics": RestApiArrayResultMobileAppsStatistics,
    "RestApiArrayResultOAuthApp": RestApiArrayResultOAuthApp,
    "RestApiArrayResultOauthClientRedirectUri": RestApiArrayResultOauthClientRedirectUri,
    "RestApiArrayResultOrderBatch": RestApiArrayResultOrderBatch,
    "RestApiArrayResultOrderFulfillmentStatus": RestApiArrayResultOrderFulfillmentStatus,
    "RestApiArrayResultPayoutSummary": RestApiArrayResultPayoutSummary,
    "RestApiArrayResultPendingMenuChangesSummaries": RestApiArrayResultPendingMenuChangesSummaries,
    "RestApiArrayResultPreOrderTime": RestApiArrayResultPreOrderTime,
    "RestApiArrayResultProcessingFeeConfig": RestApiArrayResultProcessingFeeConfig,
    "RestApiArrayResultRestApiDefaultResponse": RestApiArrayResultRestApiDefaultResponse,
    "RestApiArrayResultRestaurantVoucherEligibleStore": RestApiArrayResultRestaurantVoucherEligibleStore,
    "RestApiArrayResultRestaurantVoucherPayGreenConfiguration": RestApiArrayResultRestaurantVoucherPayGreenConfiguration,
    "RestApiArrayResultRestaurantVoucherPayGreenConfigurationSummary": RestApiArrayResultRestaurantVoucherPayGreenConfigurationSummary,
    "RestApiArrayResultRetentionCampaign": RestApiArrayResultRetentionCampaign,
    "RestApiArrayResultStoreChannelAssignment": RestApiArrayResultStoreChannelAssignment,
    "RestApiArrayResultStoreChannelStoreMapping": RestApiArrayResultStoreChannelStoreMapping,
    "RestApiArrayResultStoreDeliveryZoneFeeConfig": RestApiArrayResultStoreDeliveryZoneFeeConfig,
    "RestApiArrayResultStoreListItem": RestApiArrayResultStoreListItem,
    "RestApiArrayResultStoreStatistics": RestApiArrayResultStoreStatistics,
    "RestApiArrayResultStripeCustomConnectedAccount": RestApiArrayResultStripeCustomConnectedAccount,
    "RestApiArrayResultSubscriptionSummary": RestApiArrayResultSubscriptionSummary,
    "RestApiArrayResultSupportedCountry": RestApiArrayResultSupportedCountry,
    "RestApiArrayResultTeammate": RestApiArrayResultTeammate,
    "RestApiArrayResultVoucherDataPoint": RestApiArrayResultVoucherDataPoint,
    "RestApiDefaultResponse": RestApiDefaultResponse,
    "RestApiErrorResult": RestApiErrorResult,
    "RestApiEventSearchPaginationResult": RestApiEventSearchPaginationResult,
    "RestApiFinanceSearchPaginationResultInvoice": RestApiFinanceSearchPaginationResultInvoice,
    "RestApiForbiddenResult": RestApiForbiddenResult,
    "RestApiIntegerResult": RestApiIntegerResult,
    "RestApiPaginationResultApp": RestApiPaginationResultApp,
    "RestApiPaginationResultAppStoreAppSummary": RestApiPaginationResultAppStoreAppSummary,
    "RestApiPaginationResultBusinessHoursOverride": RestApiPaginationResultBusinessHoursOverride,
    "RestApiPaginationResultCatalogItem": RestApiPaginationResultCatalogItem,
    "RestApiPaginationResultGroup": RestApiPaginationResultGroup,
    "RestApiPaginationResultHttpRequestAndResponseLog": RestApiPaginationResultHttpRequestAndResponseLog,
    "RestApiPaginationResultHydraDeviceDetails": RestApiPaginationResultHydraDeviceDetails,
    "RestApiPaginationResultMetafieldDefinition": RestApiPaginationResultMetafieldDefinition,
    "RestApiPaginationResultMetafieldDefinitionRecommendation": RestApiPaginationResultMetafieldDefinitionRecommendation,
    "RestApiPaginationResultOAuthTokenModel": RestApiPaginationResultOAuthTokenModel,
    "RestApiPaginationResultOrder": RestApiPaginationResultOrder,
    "RestApiPaginationResultOrderSummary": RestApiPaginationResultOrderSummary,
    "RestApiPaginationResultPayout": RestApiPaginationResultPayout,
    "RestApiPaginationResultPayoutChargeback": RestApiPaginationResultPayoutChargeback,
    "RestApiPaginationResultPayoutOrder": RestApiPaginationResultPayoutOrder,
    "RestApiPaginationResultPayoutOtherCharge": RestApiPaginationResultPayoutOtherCharge,
    "RestApiPaginationResultPayoutRefund": RestApiPaginationResultPayoutRefund,
    "RestApiPaginationResultPayoutReport3PayoutOrder": RestApiPaginationResultPayoutReport3PayoutOrder,
    "RestApiPaginationResultPendingMenuChanges": RestApiPaginationResultPendingMenuChanges,
    "RestApiPaginationResultPhoneCall": RestApiPaginationResultPhoneCall,
    "RestApiPaginationResultProduct": RestApiPaginationResultProduct,
    "RestApiPaginationResultPushNotificationResponse": RestApiPaginationResultPushNotificationResponse,
    "RestApiPaginationResultStore": RestApiPaginationResultStore,
    "RestApiPaginationResultStoreGroup": RestApiPaginationResultStoreGroup,
    "RestApiPaginationResultStoreGroupExtended": RestApiPaginationResultStoreGroupExtended,
    "RestApiPaginationResultStoreHeader": RestApiPaginationResultStoreHeader,
    "RestApiPaginationResultStoreValidationConfig": RestApiPaginationResultStoreValidationConfig,
    "RestApiPaginationResultVoucherSummary": RestApiPaginationResultVoucherSummary,
    "RestApiPaginationResultWebhookLog": RestApiPaginationResultWebhookLog,
    "RestApiPaginationResultWebhookSubscription": RestApiPaginationResultWebhookSubscription,
    "RestApiResultAccountDetail": RestApiResultAccountDetail,
    "RestApiResultAccountFieldsDefinitions": RestApiResultAccountFieldsDefinitions,
    "RestApiResultAddressFormResponse": RestApiResultAddressFormResponse,
    "RestApiResultApmStatistics": RestApiResultApmStatistics,
    "RestApiResultApmStatus": RestApiResultApmStatus,
    "RestApiResultApp": RestApiResultApp,
    "RestApiResultAppChannelAssignment": RestApiResultAppChannelAssignment,
    "RestApiResultAppCompliance": RestApiResultAppCompliance,
    "RestApiResultAppConfigSalesChannel": RestApiResultAppConfigSalesChannel,
    "RestApiResultAppStoreApp": RestApiResultAppStoreApp,
    "RestApiResultAppStoreAppConfiguration": RestApiResultAppStoreAppConfiguration,
    "RestApiResultAppStoreAppConfigurationsWithSubscriptions": RestApiResultAppStoreAppConfigurationsWithSubscriptions,
    "RestApiResultAppStoreAppEntitlements": RestApiResultAppStoreAppEntitlements,
    "RestApiResultAssignedBankAccount": RestApiResultAssignedBankAccount,
    "RestApiResultBankAccountDetail": RestApiResultBankAccountDetail,
    "RestApiResultBluetoothTerminalStatus": RestApiResultBluetoothTerminalStatus,
    "RestApiResultBusinessHoursOverride": RestApiResultBusinessHoursOverride,
    "RestApiResultBusinessHoursPeriod": RestApiResultBusinessHoursPeriod,
    "RestApiResultCardReader": RestApiResultCardReader,
    "RestApiResultCatalogItem": RestApiResultCatalogItem,
    "RestApiResultChannel": RestApiResultChannel,
    "RestApiResultClientDevice": RestApiResultClientDevice,
    "RestApiResultClientDeviceEnrollmentResult": RestApiResultClientDeviceEnrollmentResult,
    "RestApiResultCoordinates": RestApiResultCoordinates,
    "RestApiResultCountryFormResponse": RestApiResultCountryFormResponse,
    "RestApiResultCreatedMenuSectionItems": RestApiResultCreatedMenuSectionItems,
    "RestApiResultCrossSellMenuItems": RestApiResultCrossSellMenuItems,
    "RestApiResultCustomer": RestApiResultCustomer,
    "RestApiResultDeliveryZone": RestApiResultDeliveryZone,
    "RestApiResultDnsRecordInformation": RestApiResultDnsRecordInformation,
    "RestApiResultExecuteConfigurationActionResult": RestApiResultExecuteConfigurationActionResult,
    "RestApiResultFileCreationResult": RestApiResultFileCreationResult,
    "RestApiResultFileDownloadResult": RestApiResultFileDownloadResult,
    "RestApiResultFulfillmentStatesConfiguration": RestApiResultFulfillmentStatesConfiguration,
    "RestApiResultGroup": RestApiResultGroup,
    "RestApiResultHasPaymentMethodResponse": RestApiResultHasPaymentMethodResponse,
    "RestApiResultHomeStatistics": RestApiResultHomeStatistics,
    "RestApiResultHydraConfig": RestApiResultHydraConfig,
    "RestApiResultHydraDeviceDetails": RestApiResultHydraDeviceDetails,
    "RestApiResultHydraStatus": RestApiResultHydraStatus,
    "RestApiResultIndexPage": RestApiResultIndexPage,
    "RestApiResultIndexPageBase": RestApiResultIndexPageBase,
    "RestApiResultIntercomUserHash": RestApiResultIntercomUserHash,
    "RestApiResultJobResponse": RestApiResultJobResponse,
    "RestApiResultKioskEntitlementsResult": RestApiResultKioskEntitlementsResult,
    "RestApiResultKioskIotConnectionParameters": RestApiResultKioskIotConnectionParameters,
    "RestApiResultKioskSettings": RestApiResultKioskSettings,
    "RestApiResultLightspeedSettings": RestApiResultLightspeedSettings,
    "RestApiResultLocationArea": RestApiResultLocationArea,
    "RestApiResultLocationAreaLocation": RestApiResultLocationAreaLocation,
    "RestApiResultLocationAreaWithLocations": RestApiResultLocationAreaWithLocations,
    "RestApiResultLoyaltyCampaign": RestApiResultLoyaltyCampaign,
    "RestApiResultMappedLocation": RestApiResultMappedLocation,
    "RestApiResultMenu": RestApiResultMenu,
    "RestApiResultMenuItemOptionSet": RestApiResultMenuItemOptionSet,
    "RestApiResultMenuItemOptionSetItem": RestApiResultMenuItemOptionSetItem,
    "RestApiResultMenuNutritionInfoHeader": RestApiResultMenuNutritionInfoHeader,
    "RestApiResultMenuSection": RestApiResultMenuSection,
    "RestApiResultMenuSectionAvailability": RestApiResultMenuSectionAvailability,
    "RestApiResultMenuSectionItem": RestApiResultMenuSectionItem,
    "RestApiResultMenuZone": RestApiResultMenuZone,
    "RestApiResultMetadata": RestApiResultMetadata,
    "RestApiResultMetafieldDefinition": RestApiResultMetafieldDefinition,
    "RestApiResultMobileAppsImage": RestApiResultMobileAppsImage,
    "RestApiResultMobileAppsSubmission": RestApiResultMobileAppsSubmission,
    "RestApiResultMobileAppsSubmissionDetails": RestApiResultMobileAppsSubmissionDetails,
    "RestApiResultMobileAppsSubmissionStatus": RestApiResultMobileAppsSubmissionStatus,
    "RestApiResultModelBase": RestApiResultModelBase,
    "RestApiResultNutritionInfo": RestApiResultNutritionInfo,
    "RestApiResultNutritionInfoV2": RestApiResultNutritionInfoV2,
    "RestApiResultOAuthApp": RestApiResultOAuthApp,
    "RestApiResultOauthClientRedirectUri": RestApiResultOauthClientRedirectUri,
    "RestApiResultOktaPortalFeatureFlag": RestApiResultOktaPortalFeatureFlag,
    "RestApiResultOrder": RestApiResultOrder,
    "RestApiResultOrderBatch": RestApiResultOrderBatch,
    "RestApiResultOrderBatchingConfiguration": RestApiResultOrderBatchingConfiguration,
    "RestApiResultOrderDeliveryInformation": RestApiResultOrderDeliveryInformation,
    "RestApiResultOrderFulfillmentStatus": RestApiResultOrderFulfillmentStatus,
    "RestApiResultOrderFulfillmentStatusWithConfigurationActions": RestApiResultOrderFulfillmentStatusWithConfigurationActions,
    "RestApiResultOrderIngestSubmitOrderResponse": RestApiResultOrderIngestSubmitOrderResponse,
    "RestApiResultOrderLeadTimes": RestApiResultOrderLeadTimes,
    "RestApiResultOrderPaymentInformation": RestApiResultOrderPaymentInformation,
    "RestApiResultPaymentIntent": RestApiResultPaymentIntent,
    "RestApiResultPaymentTerminalDetails": RestApiResultPaymentTerminalDetails,
    "RestApiResultPaymentTerminalTransactionDetails": RestApiResultPaymentTerminalTransactionDetails,
    "RestApiResultPayoutReport3Details": RestApiResultPayoutReport3Details,
    "RestApiResultPayoutReport3Overview": RestApiResultPayoutReport3Overview,
    "RestApiResultPreOrderConfig": RestApiResultPreOrderConfig,
    "RestApiResultProcessingFeeConfig": RestApiResultProcessingFeeConfig,
    "RestApiResultProduct": RestApiResultProduct,
    "RestApiResultPushNotificationResponse": RestApiResultPushNotificationResponse,
    "RestApiResultRedeemInvitationResult": RestApiResultRedeemInvitationResult,
    "RestApiResultRestApiIntegerResult": RestApiResultRestApiIntegerResult,
    "RestApiResultRestaurantVoucherPayGreenConfiguration": RestApiResultRestaurantVoucherPayGreenConfiguration,
    "RestApiResultRestaurantVoucherPayGreenStoreConfiguration": RestApiResultRestaurantVoucherPayGreenStoreConfiguration,
    "RestApiResultRetentionCampaign": RestApiResultRetentionCampaign,
    "RestApiResultServiceCharge": RestApiResultServiceCharge,
    "RestApiResultStore": RestApiResultStore,
    "RestApiResultStoreAddress": RestApiResultStoreAddress,
    "RestApiResultStoreChannelAssignment": RestApiResultStoreChannelAssignment,
    "RestApiResultStoreEndOfDayReport": RestApiResultStoreEndOfDayReport,
    "RestApiResultStoreGroup": RestApiResultStoreGroup,
    "RestApiResultStoreGroupBase": RestApiResultStoreGroupBase,
    "RestApiResultStoreOrderCapacityConfig": RestApiResultStoreOrderCapacityConfig,
    "RestApiResultStripeConnectedAccount": RestApiResultStripeConnectedAccount,
    "RestApiResultStripeTerminalConnectionToken": RestApiResultStripeTerminalConnectionToken,
    "RestApiResultStripeTerminalLocation": RestApiResultStripeTerminalLocation,
    "RestApiResultStuartSettings": RestApiResultStuartSettings,
    "RestApiResultSubmitOrderResponseDm": RestApiResultSubmitOrderResponseDm,
    "RestApiResultSubscription": RestApiResultSubscription,
    "RestApiResultTeammate": RestApiResultTeammate,
    "RestApiResultTelemetrySeriesResult": RestApiResultTelemetrySeriesResult,
    "RestApiResultTipConfiguration": RestApiResultTipConfiguration,
    "RestApiResultUpdateMobileAppsSubmissionStatus": RestApiResultUpdateMobileAppsSubmissionStatus,
    "RestApiResultVoucherWithStats": RestApiResultVoucherWithStats,
    "RestApiResultWebsiteImage": RestApiResultWebsiteImage,
    "RestApiResultWebsiteTestimonial": RestApiResultWebsiteTestimonial,
    "RestApiStringArrayResult": RestApiStringArrayResult,
    "RestApiStringResult": RestApiStringResult,
    "RestApiUnauthorizedResult": RestApiUnauthorizedResult,
    "RestaurantVoucherAssignedStore": RestaurantVoucherAssignedStore,
    "RestaurantVoucherEligibleStore": RestaurantVoucherEligibleStore,
    "RestaurantVoucherPayGreenConfiguration": RestaurantVoucherPayGreenConfiguration,
    "RestaurantVoucherPayGreenConfigurationSummary": RestaurantVoucherPayGreenConfigurationSummary,
    "RestaurantVoucherPayGreenStoreConfiguration": RestaurantVoucherPayGreenStoreConfiguration,
    "RetentionCampaign": RetentionCampaign,
    "RetentionCampaignBase": RetentionCampaignBase,
    "RetentionCampaignCreatedEvent": RetentionCampaignCreatedEvent,
    "RetentionCampaignDeletedEvent": RetentionCampaignDeletedEvent,
    "RetentionCampaignUpdatedEvent": RetentionCampaignUpdatedEvent,
    "RevenueAdjustmentsDetails": RevenueAdjustmentsDetails,
    "RevenueDetail": RevenueDetail,
    "SafeWaitHandle": SafeWaitHandle,
    "SearchCriteria": SearchCriteria,
    "ServiceCharge": ServiceCharge,
    "SetOrderBatchingConfiguration": SetOrderBatchingConfiguration,
    "SetPasswordWithPinModel": SetPasswordWithPinModel,
    "SetVoucherValidityPeriodsSimplifiedRequest": SetVoucherValidityPeriodsSimplifiedRequest,
    "Setting": Setting,
    "SignupStep": SignupStep,
    "SmsInfo": SmsInfo,
    "SmsReceivedEvent": SmsReceivedEvent,
    "StatisticsCurrencyDataPoint": StatisticsCurrencyDataPoint,
    "Store": Store,
    "StoreAddress": StoreAddress,
    "StoreAddressBase": StoreAddressBase,
    "StoreAddressForm": StoreAddressForm,
    "StoreAddressUpdatedEvent": StoreAddressUpdatedEvent,
    "StoreArchivedEvent": StoreArchivedEvent,
    "StoreBase": StoreBase,
    "StoreBusinessHoursOverrideCreatedEvent": StoreBusinessHoursOverrideCreatedEvent,
    "StoreBusinessHoursOverrideDeletedEvent": StoreBusinessHoursOverrideDeletedEvent,
    "StoreCampaignStartTime": StoreCampaignStartTime,
    "StoreChannelAssignment": StoreChannelAssignment,
    "StoreChannelStoreMapping": StoreChannelStoreMapping,
    "StoreCloneSettings": StoreCloneSettings,
    "StoreConfig": StoreConfig,
    "StoreCreateBase": StoreCreateBase,
    "StoreCreatedEvent": StoreCreatedEvent,
    "StoreDataPoint": StoreDataPoint,
    "StoreDeletedEvent": StoreDeletedEvent,
    "StoreDeliveryZoneFeeConfig": StoreDeliveryZoneFeeConfig,
    "StoreDeliveryZoneFeeConfigUpdateRequest": StoreDeliveryZoneFeeConfigUpdateRequest,
    "StoreEndOfDayReport": StoreEndOfDayReport,
    "StoreFeeConfig": StoreFeeConfig,
    "StoreFeeConfigUpdatedEvent": StoreFeeConfigUpdatedEvent,
    "StoreGroup": StoreGroup,
    "StoreGroupBase": StoreGroupBase,
    "StoreGroupCreatedEvent": StoreGroupCreatedEvent,
    "StoreGroupDeletedEvent": StoreGroupDeletedEvent,
    "StoreGroupExtended": StoreGroupExtended,
    "StoreGroupUpdatedEvent": StoreGroupUpdatedEvent,
    "StoreHeader": StoreHeader,
    "StoreItemHeader": StoreItemHeader,
    "StoreKioskSetting": StoreKioskSetting,
    "StoreKioskSettingUpdatedEvent": StoreKioskSettingUpdatedEvent,
    "StoreListItem": StoreListItem,
    "StoreLogoCreatedEvent": StoreLogoCreatedEvent,
    "StoreLogoDeletedEvent": StoreLogoDeletedEvent,
    "StoreLogoUpdatedEvent": StoreLogoUpdatedEvent,
    "StoreMenuAssignedEvent": StoreMenuAssignedEvent,
    "StoreNote": StoreNote,
    "StoreOpeningHoursUpdatedEvent": StoreOpeningHoursUpdatedEvent,
    "StoreOrderCapacityConfig": StoreOrderCapacityConfig,
    "StoreOrderCapacityConfigEditModel": StoreOrderCapacityConfigEditModel,
    "StoreOrderCapacityPeriod": StoreOrderCapacityPeriod,
    "StorePreOrderConfigUpdatedEvent": StorePreOrderConfigUpdatedEvent,
    "StorePublishedEvent": StorePublishedEvent,
    "StoreServiceChargeUpdatedEvent": StoreServiceChargeUpdatedEvent,
    "StoreStatistics": StoreStatistics,
    "StoreSummary": StoreSummary,
    "StoreTipUpdatedEvent": StoreTipUpdatedEvent,
    "StoreUnarchivedEvent": StoreUnarchivedEvent,
    "StoreUnpublishedEvent": StoreUnpublishedEvent,
    "StoreUpdatedEvent": StoreUpdatedEvent,
    "StoreValidationConfig": StoreValidationConfig,
    "Stream": Stream,
    "StripeAccountLinkRequest": StripeAccountLinkRequest,
    "StripeConnectedAccount": StripeConnectedAccount,
    "StripeConnectedAccountInfo": StripeConnectedAccountInfo,
    "StripeCustomConnectedAccount": StripeCustomConnectedAccount,
    "StripeTerminalConnectionToken": StripeTerminalConnectionToken,
    "StripeTerminalLocation": StripeTerminalLocation,
    "StuartSettings": StuartSettings,
    "StuartSettingsTransportPrices": StuartSettingsTransportPrices,
    "SubmitOrderRequest": SubmitOrderRequest,
    "SubmitOrderResponseDm": SubmitOrderResponseDm,
    "Subscription": Subscription,
    "SubscriptionProduct": SubscriptionProduct,
    "SubscriptionProductPriceInfo": SubscriptionProductPriceInfo,
    "SubscriptionStore": SubscriptionStore,
    "SubscriptionSummary": SubscriptionSummary,
    "SupportedCountry": SupportedCountry,
    "TaxRate": TaxRate,
    "Teammate": Teammate,
    "TeammateBase": TeammateBase,
    "TeammateDeletedEvent": TeammateDeletedEvent,
    "TeammateInviteAcceptedEvent": TeammateInviteAcceptedEvent,
    "TeammateInviteSentEvent": TeammateInviteSentEvent,
    "TeammateUpdatedEvent": TeammateUpdatedEvent,
    "TelemetrySeriesProperty": TelemetrySeriesProperty,
    "TelemetrySeriesQueryParameters": TelemetrySeriesQueryParameters,
    "TelemetrySeriesResult": TelemetrySeriesResult,
    "TelephonyConfig": TelephonyConfig,
    "TelephonyConfigUpdatedEvent": TelephonyConfigUpdatedEvent,
    "ThirdPartyFeesDetails": ThirdPartyFeesDetails,
    "TipConfiguration": TipConfiguration,
    "UnRegisterCardReaderRequest": UnRegisterCardReaderRequest,
    "UpcomingInvoice": UpcomingInvoice,
    "UpdateAppStoreApp": UpdateAppStoreApp,
    "UpdateAppStoreAppConfiguration": UpdateAppStoreAppConfiguration,
    "UpdateAppStoreAppConfigurationValuesBatch": UpdateAppStoreAppConfigurationValuesBatch,
    "UpdateAppStoreAppConfigurationWebhookDTO": UpdateAppStoreAppConfigurationWebhookDTO,
    "UpdateAppStoreAppExternalProduct": UpdateAppStoreAppExternalProduct,
    "UpdateCatalogGroupReference": UpdateCatalogGroupReference,
    "UpdateCatalogItem": UpdateCatalogItem,
    "UpdateDriverNotificationToken": UpdateDriverNotificationToken,
    "UpdateDriverProfileModel": UpdateDriverProfileModel,
    "UpdateFulfillmentStatesConfiguration": UpdateFulfillmentStatesConfiguration,
    "UpdateGroup": UpdateGroup,
    "UpdateGroupReference": UpdateGroupReference,
    "UpdateLocationArea": UpdateLocationArea,
    "UpdateMetafieldDefinition": UpdateMetafieldDefinition,
    "UpdateMobileAppsSubmissionStatus": UpdateMobileAppsSubmissionStatus,
    "UpdatePayGreenConfigurationRequest": UpdatePayGreenConfigurationRequest,
    "UpdateProduct": UpdateProduct,
    "UpdateProductReference": UpdateProductReference,
    "UpdateStorePayGreenConfigurationRequest": UpdateStorePayGreenConfigurationRequest,
    "UpdateTipConfiguration": UpdateTipConfiguration,
    "UpdateVoucher": UpdateVoucher,
    "UpdateVoucherUsage": UpdateVoucherUsage,
    "UserAnsweredSignupQuestionsEvent": UserAnsweredSignupQuestionsEvent,
    "UserCreatedEvent": UserCreatedEvent,
    "UserDeletedEvent": UserDeletedEvent,
    "UserEventInfo": UserEventInfo,
    "UserLoginEvent": UserLoginEvent,
    "UserPasswordCreatedEvent": UserPasswordCreatedEvent,
    "UserUpdatedEvent": UserUpdatedEvent,
    "ValidValue": ValidValue,
    "ValidationErrorResult": ValidationErrorResult,
    "ValidityPeriod": ValidityPeriod,
    "Voucher": Voucher,
    "VoucherCreatedEvent": VoucherCreatedEvent,
    "VoucherDataPoint": VoucherDataPoint,
    "VoucherDeletedEvent": VoucherDeletedEvent,
    "VoucherSummary": VoucherSummary,
    "VoucherUpdatedEvent": VoucherUpdatedEvent,
    "VoucherWithStats": VoucherWithStats,
    "WaitHandle": WaitHandle,
    "WebhookEventSample": WebhookEventSample,
    "WebhookLog": WebhookLog,
    "WebhookSubscription": WebhookSubscription,
    "WebhookSubscriptionCreatedEvent": WebhookSubscriptionCreatedEvent,
    "WebhookSubscriptionDeletedEvent": WebhookSubscriptionDeletedEvent,
    "WebhookSubscriptionEventInfo": WebhookSubscriptionEventInfo,
    "WebhookSubscriptionUpdatedEvent": WebhookSubscriptionUpdatedEvent,
    "WebsiteImage": WebsiteImage,
    "WebsiteTestimonial": WebsiteTestimonial,
    "WebsiteTestimonialBase": WebsiteTestimonialBase,
    "WebsiteUpdatedEvent": WebsiteUpdatedEvent,
    "WebsiteVanityUrlUpdatedEvent": WebsiteVanityUrlUpdatedEvent,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum AccountsApiApiKeys {
}

export class AccountsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AccountsApiApiKeys, value: string) {
        (this.authentications as any)[AccountsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param signupStepAction 
     * @param answerId 
     * @param {*} [options] Override http request options.
     */
    public answerSignUpQuestion (signupStepAction: 'Question' | 'StoreLocation' | 'PaymentSubscription' | 'StoreName', answerId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/signupstep/{signupStepAction}/answer'
            .replace('{' + 'signupStepAction' + '}', encodeURIComponent(String(signupStepAction)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'signupStepAction' is not null or undefined
        if (signupStepAction === null || signupStepAction === undefined) {
            throw new Error('Required parameter signupStepAction was null or undefined when calling answerSignUpQuestion.');
        }

        // verify required parameter 'answerId' is not null or undefined
        if (answerId === null || answerId === undefined) {
            throw new Error('Required parameter answerId was null or undefined when calling answerSignUpQuestion.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(answerId, "number")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param changePasswordModel 
     * @param {*} [options] Override http request options.
     */
    public changePassword (changePasswordModel: ChangePasswordModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/password';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'changePasswordModel' is not null or undefined
        if (changePasswordModel === null || changePasswordModel === undefined) {
            throw new Error('Required parameter changePasswordModel was null or undefined when calling changePassword.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(changePasswordModel, "ChangePasswordModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param changePasswordModel 
     * @param {*} [options] Override http request options.
     */
    public changePasswordWithPin (changePasswordModel: SetPasswordWithPinModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/password/pin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'changePasswordModel' is not null or undefined
        if (changePasswordModel === null || changePasswordModel === undefined) {
            throw new Error('Required parameter changePasswordModel was null or undefined when calling changePasswordWithPin.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(changePasswordModel, "SetPasswordWithPinModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param createAccountModel 
     * @param {*} [options] Override http request options.
     */
    public createAccount (createAccountModel: CreateAccountModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'createAccountModel' is not null or undefined
        if (createAccountModel === null || createAccountModel === undefined) {
            throw new Error('Required parameter createAccountModel was null or undefined when calling createAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createAccountModel, "CreateAccountModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param basicAccountModel 
     * @param {*} [options] Override http request options.
     */
    public createBasicAccount (basicAccountModel: CreateBasicAccountModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/basic-account';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'basicAccountModel' is not null or undefined
        if (basicAccountModel === null || basicAccountModel === undefined) {
            throw new Error('Required parameter basicAccountModel was null or undefined when calling createBasicAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(basicAccountModel, "CreateBasicAccountModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public getAccountDetails (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultAccountDetail;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultAccountDetail;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultAccountDetail");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public getLocalisedTimeZones (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultLocalisedTimeZone;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/timezones';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultLocalisedTimeZone;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultLocalisedTimeZone");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param loginModel 
     * @param {*} [options] Override http request options.
     */
    public login (loginModel: LoginModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/login';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'loginModel' is not null or undefined
        if (loginModel === null || loginModel === undefined) {
            throw new Error('Required parameter loginModel was null or undefined when calling login.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(loginModel, "LoginModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public loginSso (options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/login/sso';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param loginModel 
     * @param {*} [options] Override http request options.
     */
    public loginWithPin (loginModel: LoginWithPinModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/login/pin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'loginModel' is not null or undefined
        if (loginModel === null || loginModel === undefined) {
            throw new Error('Required parameter loginModel was null or undefined when calling loginWithPin.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(loginModel, "LoginWithPinModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public logout (options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/logout';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param passwordResetModel 
     * @param {*} [options] Override http request options.
     */
    public passwordResetWithToken (passwordResetModel: PasswordResetModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/password';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'passwordResetModel' is not null or undefined
        if (passwordResetModel === null || passwordResetModel === undefined) {
            throw new Error('Required parameter passwordResetModel was null or undefined when calling passwordResetWithToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(passwordResetModel, "PasswordResetModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param token 
     * @param {*} [options] Override http request options.
     */
    public recaptchaValidate (token: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/recaptcha';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'token' is not null or undefined
        if (token === null || token === undefined) {
            throw new Error('Required parameter token was null or undefined when calling recaptchaValidate.');
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param requestLoginPinRequest 
     * @param {*} [options] Override http request options.
     */
    public requestLoginPin (requestLoginPinRequest: RequestLoginPinModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RequestLoginPinResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/pin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'requestLoginPinRequest' is not null or undefined
        if (requestLoginPinRequest === null || requestLoginPinRequest === undefined) {
            throw new Error('Required parameter requestLoginPinRequest was null or undefined when calling requestLoginPin.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(requestLoginPinRequest, "RequestLoginPinModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RequestLoginPinResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RequestLoginPinResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param requestPasswordResetModel 
     * @param {*} [options] Override http request options.
     */
    public requestPasswordReset (requestPasswordResetModel: RequestPasswordResetModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/passwordreset';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'requestPasswordResetModel' is not null or undefined
        if (requestPasswordResetModel === null || requestPasswordResetModel === undefined) {
            throw new Error('Required parameter requestPasswordResetModel was null or undefined when calling requestPasswordReset.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(requestPasswordResetModel, "RequestPasswordResetModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param requestPasswordResetRequest 
     * @param {*} [options] Override http request options.
     */
    public sendPinForPasswordReset (requestPasswordResetRequest: RequestPasswordResetModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RequestPasswordResetPinResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/password/resetpin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'requestPasswordResetRequest' is not null or undefined
        if (requestPasswordResetRequest === null || requestPasswordResetRequest === undefined) {
            throw new Error('Required parameter requestPasswordResetRequest was null or undefined when calling sendPinForPasswordReset.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(requestPasswordResetRequest, "RequestPasswordResetModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RequestPasswordResetPinResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RequestPasswordResetPinResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param signupStepAction 
     * @param {*} [options] Override http request options.
     */
    public skipSignupStep (signupStepAction: 'Question' | 'StoreLocation' | 'PaymentSubscription' | 'StoreName', options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts/signupstep/{signupStepAction}/skip'
            .replace('{' + 'signupStepAction' + '}', encodeURIComponent(String(signupStepAction)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'signupStepAction' is not null or undefined
        if (signupStepAction === null || signupStepAction === undefined) {
            throw new Error('Required parameter signupStepAction was null or undefined when calling skipSignupStep.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param updateAccountModel 
     * @param {*} [options] Override http request options.
     */
    public updateAccount (updateAccountModel: AccountDetailBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/accounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'updateAccountModel' is not null or undefined
        if (updateAccountModel === null || updateAccountModel === undefined) {
            throw new Error('Required parameter updateAccountModel was null or undefined when calling updateAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateAccountModel, "AccountDetailBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AddressApiApiKeys {
}

export class AddressApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AddressApiApiKeys, value: string) {
        (this.authentications as any)[AddressApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param language 
     * @param {*} [options] Override http request options.
     */
    public formByApp (appId: string, language?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultAddressFormResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/app/{appId}/address/form'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling formByApp.');
        }

        if (language !== undefined) {
            localVarQueryParameters['language'] = ObjectSerializer.serialize(language, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultAddressFormResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultAddressFormResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param countryCode 
     * @param language 
     * @param {*} [options] Override http request options.
     */
    public formByCountry (countryCode: string, language?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultAddressFormResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/address/country/{countryCode}/form'
            .replace('{' + 'countryCode' + '}', encodeURIComponent(String(countryCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'countryCode' is not null or undefined
        if (countryCode === null || countryCode === undefined) {
            throw new Error('Required parameter countryCode was null or undefined when calling formByCountry.');
        }

        if (language !== undefined) {
            localVarQueryParameters['language'] = ObjectSerializer.serialize(language, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultAddressFormResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultAddressFormResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param googleAddress 
     * @param language 
     * @param {*} [options] Override http request options.
     */
    public formatGoogleAddress (googleAddress: GoogleAddress, language?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultAddressFormResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/address/google';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'googleAddress' is not null or undefined
        if (googleAddress === null || googleAddress === undefined) {
            throw new Error('Required parameter googleAddress was null or undefined when calling formatGoogleAddress.');
        }

        if (language !== undefined) {
            localVarQueryParameters['language'] = ObjectSerializer.serialize(language, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(googleAddress, "GoogleAddress")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultAddressFormResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultAddressFormResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param language 
     * @param {*} [options] Override http request options.
     */
    public getCountries (language?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultCountryFormResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/address/countries';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (language !== undefined) {
            localVarQueryParameters['language'] = ObjectSerializer.serialize(language, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultCountryFormResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultCountryFormResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ApmApiApiKeys {
}

export class ApmApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ApmApiApiKeys, value: string) {
        (this.authentications as any)[ApmApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getApmStatus (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultApmStatus;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/apm/status'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getApmStatus.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultApmStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultApmStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public getBasicStatistics (appId: string, storeId?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultApmStatistics;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/apm/statistics'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getBasicStatistics.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultApmStatistics;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultApmStatistics");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public getCalendarWeekStatistics (appId: string, storeId?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultApmHourlyDataPoint;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/apm/statistics/calendar'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getCalendarWeekStatistics.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultApmHourlyDataPoint;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultApmHourlyDataPoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param aggregateDataBy 
     * @param dataPointLimit 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public getCallsStatistics (appId: string, aggregateDataBy: 'Daily' | 'Weekly' | 'Monthly', dataPointLimit?: number, storeId?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultApmDataPoint;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/apm/statistics/calls/{aggregateDataBy}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'aggregateDataBy' + '}', encodeURIComponent(String(aggregateDataBy)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getCallsStatistics.');
        }

        // verify required parameter 'aggregateDataBy' is not null or undefined
        if (aggregateDataBy === null || aggregateDataBy === undefined) {
            throw new Error('Required parameter aggregateDataBy was null or undefined when calling getCallsStatistics.');
        }

        if (dataPointLimit !== undefined) {
            localVarQueryParameters['dataPointLimit'] = ObjectSerializer.serialize(dataPointLimit, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultApmDataPoint;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultApmDataPoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param aggregateDataBy 
     * @param dataPointLimit 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public getOrderStatistics (appId: string, aggregateDataBy: 'Daily' | 'Weekly' | 'Monthly', dataPointLimit?: number, storeId?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultApmCurrencyDataPoint;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/apm/statistics/orders/{aggregateDataBy}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'aggregateDataBy' + '}', encodeURIComponent(String(aggregateDataBy)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOrderStatistics.');
        }

        // verify required parameter 'aggregateDataBy' is not null or undefined
        if (aggregateDataBy === null || aggregateDataBy === undefined) {
            throw new Error('Required parameter aggregateDataBy was null or undefined when calling getOrderStatistics.');
        }

        if (dataPointLimit !== undefined) {
            localVarQueryParameters['dataPointLimit'] = ObjectSerializer.serialize(dataPointLimit, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultApmCurrencyDataPoint;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultApmCurrencyDataPoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param page 
     * @param limit 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public getPaginatedCallList (appId: string, page?: number, limit?: number, storeId?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPhoneCall;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/apm/calls'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPaginatedCallList.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPhoneCall;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultPhoneCall");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AppStoreApiApiKeys {
}

export class AppStoreApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AppStoreApiApiKeys, value: string) {
        (this.authentications as any)[AppStoreApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appStoreAppId 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getAppStoreApp (appStoreAppId: string, appId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultAppStoreApp;  }> {
        const localVarPath = this.basePath + '/api/v1.0/appstore/apps/{appStoreAppId}'
            .replace('{' + 'appStoreAppId' + '}', encodeURIComponent(String(appStoreAppId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appStoreAppId' is not null or undefined
        if (appStoreAppId === null || appStoreAppId === undefined) {
            throw new Error('Required parameter appStoreAppId was null or undefined when calling getAppStoreApp.');
        }

        if (appId !== undefined) {
            localVarQueryParameters['appId'] = ObjectSerializer.serialize(appId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultAppStoreApp;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultAppStoreApp");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param search 
     * @param page 
     * @param limit 
     * @param excludeNotOwned 
     * @param showOnlyVerified 
     * @param {*} [options] Override http request options.
     */
    public getAppStoreApps (search: string, page?: number, limit?: number, excludeNotOwned?: boolean, showOnlyVerified?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultAppStoreAppSummary;  }> {
        const localVarPath = this.basePath + '/api/v1.0/appstore/apps';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'search' is not null or undefined
        if (search === null || search === undefined) {
            throw new Error('Required parameter search was null or undefined when calling getAppStoreApps.');
        }

        if (search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(search, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (excludeNotOwned !== undefined) {
            localVarQueryParameters['excludeNotOwned'] = ObjectSerializer.serialize(excludeNotOwned, "boolean");
        }

        if (showOnlyVerified !== undefined) {
            localVarQueryParameters['showOnlyVerified'] = ObjectSerializer.serialize(showOnlyVerified, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultAppStoreAppSummary;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultAppStoreAppSummary");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AppStoreConfigurationsApiApiKeys {
}

export class AppStoreConfigurationsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AppStoreConfigurationsApiApiKeys, value: string) {
        (this.authentications as any)[AppStoreConfigurationsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appStoreAppId 
     * @param {*} [options] Override http request options.
     */
    public appStoreConfigurationsAppStoreHandleOauthResponseCode (appStoreAppId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/appstore/oauthresponse/{appStoreAppId}/responsecode'
            .replace('{' + 'appStoreAppId' + '}', encodeURIComponent(String(appStoreAppId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appStoreAppId' is not null or undefined
        if (appStoreAppId === null || appStoreAppId === undefined) {
            throw new Error('Required parameter appStoreAppId was null or undefined when calling appStoreConfigurationsAppStoreHandleOauthResponseCode.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param appStoreAppId 
     * @param {*} [options] Override http request options.
     */
    public createAppStoreConfig (appId: string, appStoreAppId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultAppStoreAppConfiguration;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/appstore/apps/{appStoreAppId}/config'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'appStoreAppId' + '}', encodeURIComponent(String(appStoreAppId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createAppStoreConfig.');
        }

        // verify required parameter 'appStoreAppId' is not null or undefined
        if (appStoreAppId === null || appStoreAppId === undefined) {
            throw new Error('Required parameter appStoreAppId was null or undefined when calling createAppStoreConfig.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultAppStoreAppConfiguration;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultAppStoreAppConfiguration");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param appStoreAppId 
     * @param configId 
     * @param {*} [options] Override http request options.
     */
    public deleteAppStoreConfig (appId: string, appStoreAppId: string, configId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/appstore/apps/{appStoreAppId}/config/{configId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'appStoreAppId' + '}', encodeURIComponent(String(appStoreAppId)))
            .replace('{' + 'configId' + '}', encodeURIComponent(String(configId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteAppStoreConfig.');
        }

        // verify required parameter 'appStoreAppId' is not null or undefined
        if (appStoreAppId === null || appStoreAppId === undefined) {
            throw new Error('Required parameter appStoreAppId was null or undefined when calling deleteAppStoreConfig.');
        }

        // verify required parameter 'configId' is not null or undefined
        if (configId === null || configId === undefined) {
            throw new Error('Required parameter configId was null or undefined when calling deleteAppStoreConfig.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param appStoreAppId 
     * @param configId 
     * @param executeConfigurationActionRequest 
     * @param {*} [options] Override http request options.
     */
    public executeConfigurationAction (appId: string, appStoreAppId: string, configId: string, executeConfigurationActionRequest: ExecuteConfigurationActionRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultExecuteConfigurationActionResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/appstore/apps/{appStoreAppId}/config/{configId}/action'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'appStoreAppId' + '}', encodeURIComponent(String(appStoreAppId)))
            .replace('{' + 'configId' + '}', encodeURIComponent(String(configId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling executeConfigurationAction.');
        }

        // verify required parameter 'appStoreAppId' is not null or undefined
        if (appStoreAppId === null || appStoreAppId === undefined) {
            throw new Error('Required parameter appStoreAppId was null or undefined when calling executeConfigurationAction.');
        }

        // verify required parameter 'configId' is not null or undefined
        if (configId === null || configId === undefined) {
            throw new Error('Required parameter configId was null or undefined when calling executeConfigurationAction.');
        }

        // verify required parameter 'executeConfigurationActionRequest' is not null or undefined
        if (executeConfigurationActionRequest === null || executeConfigurationActionRequest === undefined) {
            throw new Error('Required parameter executeConfigurationActionRequest was null or undefined when calling executeConfigurationAction.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(executeConfigurationActionRequest, "ExecuteConfigurationActionRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultExecuteConfigurationActionResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultExecuteConfigurationActionResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param appStoreAppId 
     * @param configId 
     * @param {*} [options] Override http request options.
     */
    public getAppStoreConfig (appId: string, appStoreAppId: string, configId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultAppStoreAppConfiguration;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/appstore/apps/{appStoreAppId}/config/{configId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'appStoreAppId' + '}', encodeURIComponent(String(appStoreAppId)))
            .replace('{' + 'configId' + '}', encodeURIComponent(String(configId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getAppStoreConfig.');
        }

        // verify required parameter 'appStoreAppId' is not null or undefined
        if (appStoreAppId === null || appStoreAppId === undefined) {
            throw new Error('Required parameter appStoreAppId was null or undefined when calling getAppStoreConfig.');
        }

        // verify required parameter 'configId' is not null or undefined
        if (configId === null || configId === undefined) {
            throw new Error('Required parameter configId was null or undefined when calling getAppStoreConfig.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultAppStoreAppConfiguration;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultAppStoreAppConfiguration");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param appStoreAppId 
     * @param {*} [options] Override http request options.
     */
    public getConfiguredAppSingleApp (appId: string, appStoreAppId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultAppStoreAppConfigurationSummary;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/appstore/apps/{appStoreAppId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'appStoreAppId' + '}', encodeURIComponent(String(appStoreAppId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getConfiguredAppSingleApp.');
        }

        // verify required parameter 'appStoreAppId' is not null or undefined
        if (appStoreAppId === null || appStoreAppId === undefined) {
            throw new Error('Required parameter appStoreAppId was null or undefined when calling getConfiguredAppSingleApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultAppStoreAppConfigurationSummary;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultAppStoreAppConfigurationSummary");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param appStoreAppId 
     * @param {*} [options] Override http request options.
     */
    public getConfiguredAppWithSubscriptionsSingleApp (appId: string, appStoreAppId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultAppStoreAppConfigurationsWithSubscriptions;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/appstore/apps_subscriptions/{appStoreAppId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'appStoreAppId' + '}', encodeURIComponent(String(appStoreAppId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getConfiguredAppWithSubscriptionsSingleApp.');
        }

        // verify required parameter 'appStoreAppId' is not null or undefined
        if (appStoreAppId === null || appStoreAppId === undefined) {
            throw new Error('Required parameter appStoreAppId was null or undefined when calling getConfiguredAppWithSubscriptionsSingleApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultAppStoreAppConfigurationsWithSubscriptions;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultAppStoreAppConfigurationsWithSubscriptions");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getConfiguredApps (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultAppStoreAppSummary;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/appstore/apps'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getConfiguredApps.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultAppStoreAppSummary;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultAppStoreAppSummary");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param appStoreAppId 
     * @param configId 
     * @param updateAppStoreAppConfiguration 
     * @param {*} [options] Override http request options.
     */
    public updateAppStoreConfig (appId: string, appStoreAppId: string, configId: string, updateAppStoreAppConfiguration: UpdateAppStoreAppConfiguration, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/appstore/apps/{appStoreAppId}/config/{configId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'appStoreAppId' + '}', encodeURIComponent(String(appStoreAppId)))
            .replace('{' + 'configId' + '}', encodeURIComponent(String(configId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateAppStoreConfig.');
        }

        // verify required parameter 'appStoreAppId' is not null or undefined
        if (appStoreAppId === null || appStoreAppId === undefined) {
            throw new Error('Required parameter appStoreAppId was null or undefined when calling updateAppStoreConfig.');
        }

        // verify required parameter 'configId' is not null or undefined
        if (configId === null || configId === undefined) {
            throw new Error('Required parameter configId was null or undefined when calling updateAppStoreConfig.');
        }

        // verify required parameter 'updateAppStoreAppConfiguration' is not null or undefined
        if (updateAppStoreAppConfiguration === null || updateAppStoreAppConfiguration === undefined) {
            throw new Error('Required parameter updateAppStoreAppConfiguration was null or undefined when calling updateAppStoreConfig.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateAppStoreAppConfiguration, "UpdateAppStoreAppConfiguration")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param appStoreAppId 
     * @param configId 
     * @param updateAppStoreAppConfigurationValues 
     * @param {*} [options] Override http request options.
     */
    public updateAppStoreConfigSettingValues (appId: string, appStoreAppId: string, configId: string, updateAppStoreAppConfigurationValues: UpdateAppStoreAppConfigurationValuesBatch, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/appstore/apps/{appStoreAppId}/config/{configId}/updatesettings'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'appStoreAppId' + '}', encodeURIComponent(String(appStoreAppId)))
            .replace('{' + 'configId' + '}', encodeURIComponent(String(configId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateAppStoreConfigSettingValues.');
        }

        // verify required parameter 'appStoreAppId' is not null or undefined
        if (appStoreAppId === null || appStoreAppId === undefined) {
            throw new Error('Required parameter appStoreAppId was null or undefined when calling updateAppStoreConfigSettingValues.');
        }

        // verify required parameter 'configId' is not null or undefined
        if (configId === null || configId === undefined) {
            throw new Error('Required parameter configId was null or undefined when calling updateAppStoreConfigSettingValues.');
        }

        // verify required parameter 'updateAppStoreAppConfigurationValues' is not null or undefined
        if (updateAppStoreAppConfigurationValues === null || updateAppStoreAppConfigurationValues === undefined) {
            throw new Error('Required parameter updateAppStoreAppConfigurationValues was null or undefined when calling updateAppStoreConfigSettingValues.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateAppStoreAppConfigurationValues, "UpdateAppStoreAppConfigurationValuesBatch")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AppStoreDeveloperApiApiKeys {
}

export class AppStoreDeveloperApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AppStoreDeveloperApiApiKeys, value: string) {
        (this.authentications as any)[AppStoreDeveloperApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param oauthAppId 
     * @param appStoreAppId 
     * @param verificationStatus 
     * @param {*} [options] Override http request options.
     */
    public appVerificationUpdate (oauthAppId: string, appStoreAppId: string, verificationStatus: 'Draft' | 'Submitted' | 'Verified', options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/oauthclients/{oauthAppId}/appstore/apps/{appStoreAppId}/verification'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appStoreAppId' + '}', encodeURIComponent(String(appStoreAppId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling appVerificationUpdate.');
        }

        // verify required parameter 'appStoreAppId' is not null or undefined
        if (appStoreAppId === null || appStoreAppId === undefined) {
            throw new Error('Required parameter appStoreAppId was null or undefined when calling appVerificationUpdate.');
        }

        // verify required parameter 'verificationStatus' is not null or undefined
        if (verificationStatus === null || verificationStatus === undefined) {
            throw new Error('Required parameter verificationStatus was null or undefined when calling appVerificationUpdate.');
        }

        if (verificationStatus !== undefined) {
            localVarQueryParameters['verificationStatus'] = ObjectSerializer.serialize(verificationStatus, "'Draft' | 'Submitted' | 'Verified'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param oauthAppId 
     * @param createAppStoreApp 
     * @param {*} [options] Override http request options.
     */
    public createAppStoreApp (oauthAppId: string, createAppStoreApp: CreateAppStoreApp, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultAppStoreApp;  }> {
        const localVarPath = this.basePath + '/api/v1.0/oauthclients/{oauthAppId}/appstore/apps'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling createAppStoreApp.');
        }

        // verify required parameter 'createAppStoreApp' is not null or undefined
        if (createAppStoreApp === null || createAppStoreApp === undefined) {
            throw new Error('Required parameter createAppStoreApp was null or undefined when calling createAppStoreApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createAppStoreApp, "CreateAppStoreApp")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultAppStoreApp;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultAppStoreApp");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param oauthAppId 
     * @param appStoreAppId 
     * @param {*} [options] Override http request options.
     */
    public deleteAppStoreApp (oauthAppId: string, appStoreAppId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/oauthclients/{oauthAppId}/appstore/apps/{appStoreAppId}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appStoreAppId' + '}', encodeURIComponent(String(appStoreAppId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling deleteAppStoreApp.');
        }

        // verify required parameter 'appStoreAppId' is not null or undefined
        if (appStoreAppId === null || appStoreAppId === undefined) {
            throw new Error('Required parameter appStoreAppId was null or undefined when calling deleteAppStoreApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param oauthAppId 
     * @param appStoreAppId 
     * @param {*} [options] Override http request options.
     */
    public getAppExternalProduct (oauthAppId: string, appStoreAppId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/oauthclients/{oauthAppId}/appstore/apps/{appStoreAppId}/external_product'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appStoreAppId' + '}', encodeURIComponent(String(appStoreAppId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getAppExternalProduct.');
        }

        // verify required parameter 'appStoreAppId' is not null or undefined
        if (appStoreAppId === null || appStoreAppId === undefined) {
            throw new Error('Required parameter appStoreAppId was null or undefined when calling getAppExternalProduct.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param oauthAppId 
     * @param appStoreAppId 
     * @param {*} [options] Override http request options.
     */
    public getExternalFunctionSigningKey (oauthAppId: string, appStoreAppId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/oauthclients/{oauthAppId}/appstore/apps/{appStoreAppId}/external_function_signing_key'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appStoreAppId' + '}', encodeURIComponent(String(appStoreAppId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getExternalFunctionSigningKey.');
        }

        // verify required parameter 'appStoreAppId' is not null or undefined
        if (appStoreAppId === null || appStoreAppId === undefined) {
            throw new Error('Required parameter appStoreAppId was null or undefined when calling getExternalFunctionSigningKey.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param oauthAppId 
     * @param appStoreAppId 
     * @param appStoreApp 
     * @param {*} [options] Override http request options.
     */
    public updateAppStoreApp (oauthAppId: string, appStoreAppId: string, appStoreApp: UpdateAppStoreApp, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/oauthclients/{oauthAppId}/appstore/apps/{appStoreAppId}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appStoreAppId' + '}', encodeURIComponent(String(appStoreAppId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling updateAppStoreApp.');
        }

        // verify required parameter 'appStoreAppId' is not null or undefined
        if (appStoreAppId === null || appStoreAppId === undefined) {
            throw new Error('Required parameter appStoreAppId was null or undefined when calling updateAppStoreApp.');
        }

        // verify required parameter 'appStoreApp' is not null or undefined
        if (appStoreApp === null || appStoreApp === undefined) {
            throw new Error('Required parameter appStoreApp was null or undefined when calling updateAppStoreApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(appStoreApp, "UpdateAppStoreApp")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param oauthAppId 
     * @param appStoreAppId 
     * @param appStoreAppExternalProduct 
     * @param {*} [options] Override http request options.
     */
    public updateExternalProduct (oauthAppId: string, appStoreAppId: string, appStoreAppExternalProduct: UpdateAppStoreAppExternalProduct, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/oauthclients/{oauthAppId}/appstore/apps/{appStoreAppId}/external_product'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appStoreAppId' + '}', encodeURIComponent(String(appStoreAppId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling updateExternalProduct.');
        }

        // verify required parameter 'appStoreAppId' is not null or undefined
        if (appStoreAppId === null || appStoreAppId === undefined) {
            throw new Error('Required parameter appStoreAppId was null or undefined when calling updateExternalProduct.');
        }

        // verify required parameter 'appStoreAppExternalProduct' is not null or undefined
        if (appStoreAppExternalProduct === null || appStoreAppExternalProduct === undefined) {
            throw new Error('Required parameter appStoreAppExternalProduct was null or undefined when calling updateExternalProduct.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(appStoreAppExternalProduct, "UpdateAppStoreAppExternalProduct")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param oauthAppId 
     * @param appStoreAppId 
     * @param Image App Store App Logo
     * @param {*} [options] Override http request options.
     */
    public uploadAppStoreAppLogo (oauthAppId: string, appStoreAppId: string, Image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/oauthclients/{oauthAppId}/appstore/apps/{appStoreAppId}/logo'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appStoreAppId' + '}', encodeURIComponent(String(appStoreAppId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling uploadAppStoreAppLogo.');
        }

        // verify required parameter 'appStoreAppId' is not null or undefined
        if (appStoreAppId === null || appStoreAppId === undefined) {
            throw new Error('Required parameter appStoreAppId was null or undefined when calling uploadAppStoreAppLogo.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadAppStoreAppLogo.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AppStoreEntitlementsApiApiKeys {
}

export class AppStoreEntitlementsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AppStoreEntitlementsApiApiKeys, value: string) {
        (this.authentications as any)[AppStoreEntitlementsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param appStoreAppId 
     * @param {*} [options] Override http request options.
     */
    public getAppStoreAppEntitlements (appId: string, appStoreAppId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultAppStoreAppEntitlements;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/appstore/apps/{appStoreAppId}/entitlements'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'appStoreAppId' + '}', encodeURIComponent(String(appStoreAppId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getAppStoreAppEntitlements.');
        }

        // verify required parameter 'appStoreAppId' is not null or undefined
        if (appStoreAppId === null || appStoreAppId === undefined) {
            throw new Error('Required parameter appStoreAppId was null or undefined when calling getAppStoreAppEntitlements.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultAppStoreAppEntitlements;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultAppStoreAppEntitlements");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AppsApiApiKeys {
}

export class AppsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AppsApiApiKeys, value: string) {
        (this.authentications as any)[AppsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param parameters 
     * @param {*} [options] Override http request options.
     */
    public createApp (parameters: CreateAppParameters, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'parameters' is not null or undefined
        if (parameters === null || parameters === undefined) {
            throw new Error('Required parameter parameters was null or undefined when calling createApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(parameters, "CreateAppParameters")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param orgId 
     * @param createAppInOrgRequest 
     * @param {*} [options] Override http request options.
     */
    public createAppInOrg (orgId: string, createAppInOrgRequest: CreateAppInOrg, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultApp;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orgs/{orgId}/apps'
            .replace('{' + 'orgId' + '}', encodeURIComponent(String(orgId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orgId' is not null or undefined
        if (orgId === null || orgId === undefined) {
            throw new Error('Required parameter orgId was null or undefined when calling createAppInOrg.');
        }

        // verify required parameter 'createAppInOrgRequest' is not null or undefined
        if (createAppInOrgRequest === null || createAppInOrgRequest === undefined) {
            throw new Error('Required parameter createAppInOrgRequest was null or undefined when calling createAppInOrg.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createAppInOrgRequest, "CreateAppInOrg")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultApp;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultApp");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getApp (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultApp;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultApp;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultApp");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getAppHostnameStatus (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultDnsRecordInformation;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/hostnamestatus'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getAppHostnameStatus.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultDnsRecordInformation;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultDnsRecordInformation");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param nameFilter 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getApps (nameFilter?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultApp;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (nameFilter !== undefined) {
            localVarQueryParameters['nameFilter'] = ObjectSerializer.serialize(nameFilter, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultApp;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultApp");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getCompliance (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultAppCompliance;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/compliance'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getCompliance.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultAppCompliance;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultAppCompliance");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getPanaceaVanityUrl (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/panacea/url'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPanaceaVanityUrl.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public getSupportedCountries (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultSupportedCountry;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/supportedcountries';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultSupportedCountry;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultSupportedCountry");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param vanityUrl 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public isPanaceaVanityUrlAvailable (vanityUrl: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/panacea/url/available'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'vanityUrl' is not null or undefined
        if (vanityUrl === null || vanityUrl === undefined) {
            throw new Error('Required parameter vanityUrl was null or undefined when calling isPanaceaVanityUrlAvailable.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling isPanaceaVanityUrlAvailable.');
        }

        if (vanityUrl !== undefined) {
            localVarQueryParameters['vanityUrl'] = ObjectSerializer.serialize(vanityUrl, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param whitelabelId 
     * @param {*} [options] Override http request options.
     */
    public lookupByWhitelabelId (whitelabelId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: AppLookup;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{whitelabelId}/lookup'
            .replace('{' + 'whitelabelId' + '}', encodeURIComponent(String(whitelabelId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'whitelabelId' is not null or undefined
        if (whitelabelId === null || whitelabelId === undefined) {
            throw new Error('Required parameter whitelabelId was null or undefined when calling lookupByWhitelabelId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AppLookup;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AppLookup");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param appConfigUpdate 
     * @param {*} [options] Override http request options.
     */
    public setAppConfig (appId: string, appConfigUpdate: AppConfigUpdateModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultApp;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/config'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling setAppConfig.');
        }

        // verify required parameter 'appConfigUpdate' is not null or undefined
        if (appConfigUpdate === null || appConfigUpdate === undefined) {
            throw new Error('Required parameter appConfigUpdate was null or undefined when calling setAppConfig.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(appConfigUpdate, "AppConfigUpdateModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultApp;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultApp");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param hostname 
     * @param isEmbed 
     * @param {*} [options] Override http request options.
     */
    public setAppHostname (appId: string, hostname: string, isEmbed?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/hostname'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling setAppHostname.');
        }

        // verify required parameter 'hostname' is not null or undefined
        if (hostname === null || hostname === undefined) {
            throw new Error('Required parameter hostname was null or undefined when calling setAppHostname.');
        }

        if (hostname !== undefined) {
            localVarQueryParameters['hostname'] = ObjectSerializer.serialize(hostname, "string");
        }

        if (isEmbed !== undefined) {
            localVarQueryParameters['isEmbed'] = ObjectSerializer.serialize(isEmbed, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param languages 
     * @param {*} [options] Override http request options.
     */
    public setAppLanguages (appId: string, languages: Array<Language>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultApp;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/config/languages'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling setAppLanguages.');
        }

        // verify required parameter 'languages' is not null or undefined
        if (languages === null || languages === undefined) {
            throw new Error('Required parameter languages was null or undefined when calling setAppLanguages.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(languages, "Array<Language>")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultApp;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultApp");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param appStoreName 
     * @param {*} [options] Override http request options.
     */
    public setAppStoreName (appId: string, appStoreName: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/appstorename'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling setAppStoreName.');
        }

        // verify required parameter 'appStoreName' is not null or undefined
        if (appStoreName === null || appStoreName === undefined) {
            throw new Error('Required parameter appStoreName was null or undefined when calling setAppStoreName.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(appStoreName, "string")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param complianceType 
     * @param {*} [options] Override http request options.
     */
    public setCompliance (appId: string, complianceType: 'Default' | 'GdprCompliance', options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultAppCompliance;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/compliance'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling setCompliance.');
        }

        // verify required parameter 'complianceType' is not null or undefined
        if (complianceType === null || complianceType === undefined) {
            throw new Error('Required parameter complianceType was null or undefined when calling setCompliance.');
        }

        if (complianceType !== undefined) {
            localVarQueryParameters['complianceType'] = ObjectSerializer.serialize(complianceType, "'Default' | 'GdprCompliance'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultAppCompliance;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultAppCompliance");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param vanityUrl 
     * @param {*} [options] Override http request options.
     */
    public setPanaceaVanityUrl (appId: string, vanityUrl: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/panacea/url'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling setPanaceaVanityUrl.');
        }

        // verify required parameter 'vanityUrl' is not null or undefined
        if (vanityUrl === null || vanityUrl === undefined) {
            throw new Error('Required parameter vanityUrl was null or undefined when calling setPanaceaVanityUrl.');
        }

        if (vanityUrl !== undefined) {
            localVarQueryParameters['vanityUrl'] = ObjectSerializer.serialize(vanityUrl, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param hostname 
     * @param vanityUrl 
     * @param isNextGenWeb 
     * @param {*} [options] Override http request options.
     */
    public toggleNextGenWeb (appId: string, hostname: string, vanityUrl: string, isNextGenWeb: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/nextgenweb'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling toggleNextGenWeb.');
        }

        // verify required parameter 'hostname' is not null or undefined
        if (hostname === null || hostname === undefined) {
            throw new Error('Required parameter hostname was null or undefined when calling toggleNextGenWeb.');
        }

        // verify required parameter 'vanityUrl' is not null or undefined
        if (vanityUrl === null || vanityUrl === undefined) {
            throw new Error('Required parameter vanityUrl was null or undefined when calling toggleNextGenWeb.');
        }

        // verify required parameter 'isNextGenWeb' is not null or undefined
        if (isNextGenWeb === null || isNextGenWeb === undefined) {
            throw new Error('Required parameter isNextGenWeb was null or undefined when calling toggleNextGenWeb.');
        }

        if (hostname !== undefined) {
            localVarQueryParameters['hostname'] = ObjectSerializer.serialize(hostname, "string");
        }

        if (vanityUrl !== undefined) {
            localVarQueryParameters['vanityUrl'] = ObjectSerializer.serialize(vanityUrl, "string");
        }

        if (isNextGenWeb !== undefined) {
            localVarQueryParameters['isNextGenWeb'] = ObjectSerializer.serialize(isNextGenWeb, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param Image App Logo
     * @param {*} [options] Override http request options.
     */
    public uploadAppLogo (appId: string, Image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/apps/{appId}/logo'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling uploadAppLogo.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadAppLogo.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AuditLogsApiApiKeys {
}

export class AuditLogsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AuditLogsApiApiKeys, value: string) {
        (this.authentications as any)[AuditLogsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param orderId 
     * @param externalEventCreate 
     * @param {*} [options] Override http request options.
     */
    public addOrderAuditLog (orderId: number, externalEventCreate: Array<ExternalStoreAuditLog>, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/auditlogs/orders/{orderId}'
            .replace('{' + 'orderId' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling addOrderAuditLog.');
        }

        // verify required parameter 'externalEventCreate' is not null or undefined
        if (externalEventCreate === null || externalEventCreate === undefined) {
            throw new Error('Required parameter externalEventCreate was null or undefined when calling addOrderAuditLog.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(externalEventCreate, "Array<ExternalStoreAuditLog>")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param externalEventCreate 
     * @param {*} [options] Override http request options.
     */
    public addStoreAuditLogEvent (storeId: number, externalEventCreate: Array<ExternalStoreAuditLog>, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/auditlogs/stores/{storeId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling addStoreAuditLogEvent.');
        }

        // verify required parameter 'externalEventCreate' is not null or undefined
        if (externalEventCreate === null || externalEventCreate === undefined) {
            throw new Error('Required parameter externalEventCreate was null or undefined when calling addStoreAuditLogEvent.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(externalEventCreate, "Array<ExternalStoreAuditLog>")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AuthorizationTokensApiApiKeys {
}

export class AuthorizationTokensApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AuthorizationTokensApiApiKeys, value: string) {
        (this.authentications as any)[AuthorizationTokensApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param oauthAppId 
     * @param appId 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getAuthorizationTokens (oauthAppId: string, appId: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultOAuthTokenModel;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/authorizationtokens/{oauthAppId}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getAuthorizationTokens.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getAuthorizationTokens.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultOAuthTokenModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultOAuthTokenModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param key 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public revokeToken (key: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/authorizationtokens/{key}'
            .replace('{' + 'key' + '}', encodeURIComponent(String(key)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling revokeToken.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling revokeToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BankAccountApiApiKeys {
}

export class BankAccountApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BankAccountApiApiKeys, value: string) {
        (this.authentications as any)[BankAccountApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param bankAccountId 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public attachBankAccountToStore (appId: string, bankAccountId: number, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/store/{storeId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling attachBankAccountToStore.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling attachBankAccountToStore.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling attachBankAccountToStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param account 
     * @param {*} [options] Override http request options.
     */
    public createBankAccount (appId: string, account: BankAccountCreate, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createBankAccount.');
        }

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling createBankAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(account, "BankAccountCreate")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultBankAccountDetail");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param bankAccountId 
     * @param {*} [options] Override http request options.
     */
    public deleteBankAccount (appId: string, bankAccountId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteBankAccount.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling deleteBankAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param bankAccountId 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getBankAccountById (bankAccountId: number, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}'
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling getBankAccountById.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getBankAccountById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultBankAccountDetail");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getBankAccounts (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultBankAccountSummary;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getBankAccounts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultBankAccountSummary;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultBankAccountSummary");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getCountriesWithFieldDefinitions (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultCountryWithAccountFieldsDefinitions;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/countries-field-definitions'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getCountriesWithFieldDefinitions.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultCountryWithAccountFieldsDefinitions;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultCountryWithAccountFieldsDefinitions");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getFieldDefinitions (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultAccountFieldsDefinitions;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/field-definitions'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getFieldDefinitions.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultAccountFieldsDefinitions;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultAccountFieldsDefinitions");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param bankAccountId 
     * @param account 
     * @param {*} [options] Override http request options.
     */
    public updateBankAccount (appId: string, bankAccountId: number, account: BankAccountCreate, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateBankAccount.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling updateBankAccount.');
        }

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling updateBankAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(account, "BankAccountCreate")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param bankAccountId 
     * @param state 
     * @param reason 
     * @param {*} [options] Override http request options.
     */
    public updateBankAccountState (appId: string, bankAccountId: number, state: string, reason: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/state/{state}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'state' + '}', encodeURIComponent(String(state)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateBankAccountState.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling updateBankAccountState.');
        }

        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling updateBankAccountState.');
        }

        // verify required parameter 'reason' is not null or undefined
        if (reason === null || reason === undefined) {
            throw new Error('Required parameter reason was null or undefined when calling updateBankAccountState.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(reason, "string")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CampaignsApiApiKeys {
}

export class CampaignsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CampaignsApiApiKeys, value: string) {
        (this.authentications as any)[CampaignsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param campaign 
     * @param {*} [options] Override http request options.
     */
    public createLoyaltyCampaign (appId: string, campaign: LoyaltyCampaignBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultLoyaltyCampaign;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/loyalty'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createLoyaltyCampaign.');
        }

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling createLoyaltyCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(campaign, "LoyaltyCampaignBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultLoyaltyCampaign;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultLoyaltyCampaign");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param campaign 
     * @param {*} [options] Override http request options.
     */
    public createRetentionCampaign (appId: string, campaign: RetentionCampaignBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultRetentionCampaign;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/retention'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createRetentionCampaign.');
        }

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling createRetentionCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(campaign, "RetentionCampaignBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultRetentionCampaign;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultRetentionCampaign");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getLoyaltyCampaignsForApp (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultLoyaltyCampaign;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/loyalty'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getLoyaltyCampaignsForApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultLoyaltyCampaign;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultLoyaltyCampaign");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public getLoyaltyCampaignsForStore (appId: string, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultLoyaltyCampaign;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/loyalty/{storeId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getLoyaltyCampaignsForStore.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getLoyaltyCampaignsForStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultLoyaltyCampaign;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultLoyaltyCampaign");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getRetentionCampaignsForApp (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRetentionCampaign;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/retention'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getRetentionCampaignsForApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRetentionCampaign;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultRetentionCampaign");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public getRetentionCampaignsForStore (appId: string, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRetentionCampaign;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/retention/{storeId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getRetentionCampaignsForStore.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getRetentionCampaignsForStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRetentionCampaign;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultRetentionCampaign");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param onlyPublished 
     * @param {*} [options] Override http request options.
     */
    public getStoreList (appId: string, onlyPublished?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultStoreListItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/stores'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getStoreList.');
        }

        if (onlyPublished !== undefined) {
            localVarQueryParameters['onlyPublished'] = ObjectSerializer.serialize(onlyPublished, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultStoreListItem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultStoreListItem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param campaignId 
     * @param {*} [options] Override http request options.
     */
    public removeCampaign (appId: string, campaignId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/{campaignId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling removeCampaign.');
        }

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling removeCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param campaignId 
     * @param campaign 
     * @param {*} [options] Override http request options.
     */
    public updateLoyaltyCampaign (appId: string, campaignId: number, campaign: LoyaltyCampaignBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultLoyaltyCampaign;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/loyalty/{campaignId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateLoyaltyCampaign.');
        }

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling updateLoyaltyCampaign.');
        }

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling updateLoyaltyCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(campaign, "LoyaltyCampaignBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultLoyaltyCampaign;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultLoyaltyCampaign");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param campaignId 
     * @param campaign 
     * @param {*} [options] Override http request options.
     */
    public updateRetentionCampaign (appId: string, campaignId: number, campaign: RetentionCampaignBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultRetentionCampaign;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/campaigns/retention/{campaignId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateRetentionCampaign.');
        }

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling updateRetentionCampaign.');
        }

        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling updateRetentionCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(campaign, "RetentionCampaignBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultRetentionCampaign;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultRetentionCampaign");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CardReadersApiApiKeys {
}

export class CardReadersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CardReadersApiApiKeys, value: string) {
        (this.authentications as any)[CardReadersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param deviceId 
     * @param terminalType 
     * @param {*} [options] Override http request options.
     */
    public cancelCurrentlyInitiatedBluetoothDeviceUpdate (appId: string, deviceId: string, terminalType: 'CHIPPER_2X' | 'COTS_DEVICE' | 'VERIFONE_P400' | 'WISEPAD_3' | 'WISEPOS_E', options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/cardreaders/kiosk/{deviceId}/bluetooth/{terminalType}/cancelUpdate'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)))
            .replace('{' + 'terminalType' + '}', encodeURIComponent(String(terminalType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling cancelCurrentlyInitiatedBluetoothDeviceUpdate.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling cancelCurrentlyInitiatedBluetoothDeviceUpdate.');
        }

        // verify required parameter 'terminalType' is not null or undefined
        if (terminalType === null || terminalType === undefined) {
            throw new Error('Required parameter terminalType was null or undefined when calling cancelCurrentlyInitiatedBluetoothDeviceUpdate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param readerId 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public cancelReaderAction (readerId: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultCardReader;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/payments/terminals/stripe/{readerId}/cancel_action'
            .replace('{' + 'readerId' + '}', encodeURIComponent(String(readerId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'readerId' is not null or undefined
        if (readerId === null || readerId === undefined) {
            throw new Error('Required parameter readerId was null or undefined when calling cancelReaderAction.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling cancelReaderAction.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultCardReader;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultCardReader");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param readerId 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public cardReadersGetReader (readerId: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultCardReader;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/payments/terminals/stripe/{readerId}'
            .replace('{' + 'readerId' + '}', encodeURIComponent(String(readerId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'readerId' is not null or undefined
        if (readerId === null || readerId === undefined) {
            throw new Error('Required parameter readerId was null or undefined when calling cardReadersGetReader.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling cardReadersGetReader.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultCardReader;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultCardReader");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param geoPointRequest 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public generateStripeTerminalLocation (geoPointRequest: GeoPointRequest, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStripeTerminalLocation;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stripeterminal/location'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'geoPointRequest' is not null or undefined
        if (geoPointRequest === null || geoPointRequest === undefined) {
            throw new Error('Required parameter geoPointRequest was null or undefined when calling generateStripeTerminalLocation.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling generateStripeTerminalLocation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(geoPointRequest, "GeoPointRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStripeTerminalLocation;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStripeTerminalLocation");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param deviceId 
     * @param {*} [options] Override http request options.
     */
    public getBluetoothTerminalStatus (appId: string, deviceId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultBluetoothTerminalStatus;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/cardreaders/kiosk/{deviceId}/bluetooth/status'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getBluetoothTerminalStatus.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling getBluetoothTerminalStatus.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultBluetoothTerminalStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultBluetoothTerminalStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getStripeConnectionToken (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStripeTerminalConnectionToken;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stripeterminal/connectiontoken'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getStripeConnectionToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStripeTerminalConnectionToken;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStripeTerminalConnectionToken");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param deviceId 
     * @param terminalType 
     * @param {*} [options] Override http request options.
     */
    public initiateBluetoothTerminalDeviceUpdateCheck (appId: string, deviceId: string, terminalType: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/cardreaders/kiosk/{deviceId}/bluetooth/{terminalType}/checkForUpdate'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)))
            .replace('{' + 'terminalType' + '}', encodeURIComponent(String(terminalType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling initiateBluetoothTerminalDeviceUpdateCheck.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling initiateBluetoothTerminalDeviceUpdateCheck.');
        }

        // verify required parameter 'terminalType' is not null or undefined
        if (terminalType === null || terminalType === undefined) {
            throw new Error('Required parameter terminalType was null or undefined when calling initiateBluetoothTerminalDeviceUpdateCheck.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param deviceId 
     * @param terminalType 
     * @param {*} [options] Override http request options.
     */
    public initiateKioskBluetoothPairingMode (appId: string, deviceId: string, terminalType: 'CHIPPER_2X' | 'COTS_DEVICE' | 'VERIFONE_P400' | 'WISEPAD_3' | 'WISEPOS_E', options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/cardreaders/kiosk/{deviceId}/bluetooth/{terminalType}/pair'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)))
            .replace('{' + 'terminalType' + '}', encodeURIComponent(String(terminalType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling initiateKioskBluetoothPairingMode.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling initiateKioskBluetoothPairingMode.');
        }

        // verify required parameter 'terminalType' is not null or undefined
        if (terminalType === null || terminalType === undefined) {
            throw new Error('Required parameter terminalType was null or undefined when calling initiateKioskBluetoothPairingMode.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param deviceId 
     * @param terminalType 
     * @param {*} [options] Override http request options.
     */
    public initiateKioskBluetoothUpdateInstall (appId: string, deviceId: string, terminalType: 'CHIPPER_2X' | 'COTS_DEVICE' | 'VERIFONE_P400' | 'WISEPAD_3' | 'WISEPOS_E', options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/cardreaders/kiosk/{deviceId}/bluetooth/{terminalType}/installUpdate'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)))
            .replace('{' + 'terminalType' + '}', encodeURIComponent(String(terminalType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling initiateKioskBluetoothUpdateInstall.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling initiateKioskBluetoothUpdateInstall.');
        }

        // verify required parameter 'terminalType' is not null or undefined
        if (terminalType === null || terminalType === undefined) {
            throw new Error('Required parameter terminalType was null or undefined when calling initiateKioskBluetoothUpdateInstall.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param request 
     * @param readerId 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public initiateReaderProcessPaymentIntent (request: ProcessPaymentIntentRequest, readerId: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultCardReader;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/payments/terminals/stripe/{readerId}/processPaymentIntent'
            .replace('{' + 'readerId' + '}', encodeURIComponent(String(readerId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling initiateReaderProcessPaymentIntent.');
        }

        // verify required parameter 'readerId' is not null or undefined
        if (readerId === null || readerId === undefined) {
            throw new Error('Required parameter readerId was null or undefined when calling initiateReaderProcessPaymentIntent.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling initiateReaderProcessPaymentIntent.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "ProcessPaymentIntentRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultCardReader;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultCardReader");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param request 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public registerStripeTerminal (request: CardReaderRegistrationRequest, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultCardReader;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/payments/terminals/stripe/register'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling registerStripeTerminal.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling registerStripeTerminal.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "CardReaderRegistrationRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultCardReader;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultCardReader");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param request 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public unRegisterTerminal (request: UnRegisterCardReaderRequest, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultCardReader;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/payments/terminals/stripe/unregister'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling unRegisterTerminal.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling unRegisterTerminal.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "UnRegisterCardReaderRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultCardReader;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultCardReader");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param deviceId 
     * @param {*} [options] Override http request options.
     */
    public unpairCurrentlyPairedBluetoothDevice (appId: string, deviceId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/cardreaders/kiosk/{deviceId}/bluetooth/unpair'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling unpairCurrentlyPairedBluetoothDevice.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling unpairCurrentlyPairedBluetoothDevice.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CatalogChangesApiApiKeys {
}

export class CatalogChangesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CatalogChangesApiApiKeys, value: string) {
        (this.authentications as any)[CatalogChangesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Get menu pending changes from Catalog groups and items
     * @param appId 
     * @param menuId 
     * @param catalogItemId 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getPendingMenuChanges (appId: string, menuId?: number, catalogItemId?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPendingMenuChanges;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/menus/catalog-changes'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPendingMenuChanges.');
        }

        if (menuId !== undefined) {
            localVarQueryParameters['menuId'] = ObjectSerializer.serialize(menuId, "number");
        }

        if (catalogItemId !== undefined) {
            localVarQueryParameters['catalogItemId'] = ObjectSerializer.serialize(catalogItemId, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPendingMenuChanges;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultPendingMenuChanges");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu pending changes summaries by appId
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getPendingMenuChangesSummaries (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultPendingMenuChangesSummaries;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/menus/catalog-changes/summaries'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPendingMenuChangesSummaries.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultPendingMenuChangesSummaries;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultPendingMenuChangesSummaries");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Update menus with the pending changes from Catalog groups and items
     * @param appId 
     * @param publishMenuChanges 
     * @param {*} [options] Override http request options.
     */
    public publishPendingMenuChanges (appId: string, publishMenuChanges: PublishMenuChanges, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/menus/catalog-changes/publish'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling publishPendingMenuChanges.');
        }

        // verify required parameter 'publishMenuChanges' is not null or undefined
        if (publishMenuChanges === null || publishMenuChanges === undefined) {
            throw new Error('Required parameter publishMenuChanges was null or undefined when calling publishPendingMenuChanges.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(publishMenuChanges, "PublishMenuChanges")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CatalogGroupsApiApiKeys {
}

export class CatalogGroupsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CatalogGroupsApiApiKeys, value: string) {
        (this.authentications as any)[CatalogGroupsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Archive Catalog Group
     * @param appId 
     * @param catalogItemId 
     * @param {*} [options] Override http request options.
     */
    public archiveGroup (appId: string, catalogItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/catalog/groups/{catalogItemId}/archive'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'catalogItemId' + '}', encodeURIComponent(String(catalogItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling archiveGroup.');
        }

        // verify required parameter 'catalogItemId' is not null or undefined
        if (catalogItemId === null || catalogItemId === undefined) {
            throw new Error('Required parameter catalogItemId was null or undefined when calling archiveGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Create a Catalog Group
     * @param appId 
     * @param createGroup 
     * @param {*} [options] Override http request options.
     */
    public createGroup (appId: string, createGroup: CreateGroup, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultGroup;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/catalog/groups'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createGroup.');
        }

        // verify required parameter 'createGroup' is not null or undefined
        if (createGroup === null || createGroup === undefined) {
            throw new Error('Required parameter createGroup was null or undefined when calling createGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createGroup, "CreateGroup")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultGroup;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultGroup");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Duplicate Catalog Group
     * @param appId 
     * @param catalogItemId 
     * @param {*} [options] Override http request options.
     */
    public duplicateGroup (appId: string, catalogItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/catalog/groups/{catalogItemId}/duplicate'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'catalogItemId' + '}', encodeURIComponent(String(catalogItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling duplicateGroup.');
        }

        // verify required parameter 'catalogItemId' is not null or undefined
        if (catalogItemId === null || catalogItemId === undefined) {
            throw new Error('Required parameter catalogItemId was null or undefined when calling duplicateGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Get group by Id
     * @param appId 
     * @param catalogItemId 
     * @param {*} [options] Override http request options.
     */
    public getGroupById (appId: string, catalogItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Group;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/catalog/groups/{catalogItemId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'catalogItemId' + '}', encodeURIComponent(String(catalogItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getGroupById.');
        }

        // verify required parameter 'catalogItemId' is not null or undefined
        if (catalogItemId === null || catalogItemId === undefined) {
            throw new Error('Required parameter catalogItemId was null or undefined when calling getGroupById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Group;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Group");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Get paginated groups by app name id filtered by types
     * @param appId 
     * @param groupTypes 
     * @param searchTerm 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getGroups (appId: string, groupTypes: Array<'ModifierGroup'>, searchTerm?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultGroup;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/catalog/groups'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getGroups.');
        }

        // verify required parameter 'groupTypes' is not null or undefined
        if (groupTypes === null || groupTypes === undefined) {
            throw new Error('Required parameter groupTypes was null or undefined when calling getGroups.');
        }

        if (groupTypes !== undefined) {
            localVarQueryParameters['groupTypes'] = ObjectSerializer.serialize(groupTypes, "Array<'ModifierGroup'>");
        }

        if (searchTerm !== undefined) {
            localVarQueryParameters['searchTerm'] = ObjectSerializer.serialize(searchTerm, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultGroup;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultGroup");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Update Catalog Group
     * @param appId 
     * @param catalogItemId 
     * @param updateGroup 
     * @param {*} [options] Override http request options.
     */
    public updateGroup (appId: string, catalogItemId: string, updateGroup: UpdateGroup, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/catalog/groups/{catalogItemId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'catalogItemId' + '}', encodeURIComponent(String(catalogItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateGroup.');
        }

        // verify required parameter 'catalogItemId' is not null or undefined
        if (catalogItemId === null || catalogItemId === undefined) {
            throw new Error('Required parameter catalogItemId was null or undefined when calling updateGroup.');
        }

        // verify required parameter 'updateGroup' is not null or undefined
        if (updateGroup === null || updateGroup === undefined) {
            throw new Error('Required parameter updateGroup was null or undefined when calling updateGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateGroup, "UpdateGroup")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CatalogImagesApiApiKeys {
}

export class CatalogImagesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CatalogImagesApiApiKeys, value: string) {
        (this.authentications as any)[CatalogImagesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Upload a Catalog Image
     * @param appId 
     * @param Image Catalog image
     * @param {*} [options] Override http request options.
     */
    public uploadCatalogImage (appId: string, Image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CatalogImage;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/catalog/images'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling uploadCatalogImage.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadCatalogImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CatalogImage;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CatalogImage");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CatalogItemsApiApiKeys {
}

export class CatalogItemsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CatalogItemsApiApiKeys, value: string) {
        (this.authentications as any)[CatalogItemsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Archive Catalog Item
     * @param appId 
     * @param catalogItemId 
     * @param {*} [options] Override http request options.
     */
    public archiveCatalogItem (appId: string, catalogItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/catalog/items/{catalogItemId}/archive'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'catalogItemId' + '}', encodeURIComponent(String(catalogItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling archiveCatalogItem.');
        }

        // verify required parameter 'catalogItemId' is not null or undefined
        if (catalogItemId === null || catalogItemId === undefined) {
            throw new Error('Required parameter catalogItemId was null or undefined when calling archiveCatalogItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Create a Catalog Item
     * @param appId 
     * @param createCatalogItem 
     * @param {*} [options] Override http request options.
     */
    public createCatalogItem (appId: string, createCatalogItem: CreateCatalogItem, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultCatalogItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/catalog/items'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createCatalogItem.');
        }

        // verify required parameter 'createCatalogItem' is not null or undefined
        if (createCatalogItem === null || createCatalogItem === undefined) {
            throw new Error('Required parameter createCatalogItem was null or undefined when calling createCatalogItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createCatalogItem, "CreateCatalogItem")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultCatalogItem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultCatalogItem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Duplicate Catalog Item
     * @param appId 
     * @param catalogItemId 
     * @param {*} [options] Override http request options.
     */
    public duplicateCatalogItem (appId: string, catalogItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/catalog/items/{catalogItemId}/duplicate'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'catalogItemId' + '}', encodeURIComponent(String(catalogItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling duplicateCatalogItem.');
        }

        // verify required parameter 'catalogItemId' is not null or undefined
        if (catalogItemId === null || catalogItemId === undefined) {
            throw new Error('Required parameter catalogItemId was null or undefined when calling duplicateCatalogItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Get item by Id
     * @param appId 
     * @param catalogItemId 
     * @param {*} [options] Override http request options.
     */
    public getCatalogItemById (appId: string, catalogItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CatalogItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/catalog/items/{catalogItemId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'catalogItemId' + '}', encodeURIComponent(String(catalogItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getCatalogItemById.');
        }

        // verify required parameter 'catalogItemId' is not null or undefined
        if (catalogItemId === null || catalogItemId === undefined) {
            throw new Error('Required parameter catalogItemId was null or undefined when calling getCatalogItemById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CatalogItem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CatalogItem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Get paginated items by app name id filtered by types
     * @param appId 
     * @param itemTypes 
     * @param searchTerm 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getItems (appId: string, itemTypes: Array<'Product' | 'Modifier'>, searchTerm?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultCatalogItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/catalog/items'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getItems.');
        }

        // verify required parameter 'itemTypes' is not null or undefined
        if (itemTypes === null || itemTypes === undefined) {
            throw new Error('Required parameter itemTypes was null or undefined when calling getItems.');
        }

        if (itemTypes !== undefined) {
            localVarQueryParameters['itemTypes'] = ObjectSerializer.serialize(itemTypes, "Array<'Product' | 'Modifier'>");
        }

        if (searchTerm !== undefined) {
            localVarQueryParameters['searchTerm'] = ObjectSerializer.serialize(searchTerm, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultCatalogItem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultCatalogItem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Update Catalog Item
     * @param appId 
     * @param catalogItemId 
     * @param updateCatalogItem 
     * @param {*} [options] Override http request options.
     */
    public updateCatalogItem (appId: string, catalogItemId: string, updateCatalogItem: UpdateCatalogItem, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/catalog/items/{catalogItemId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'catalogItemId' + '}', encodeURIComponent(String(catalogItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateCatalogItem.');
        }

        // verify required parameter 'catalogItemId' is not null or undefined
        if (catalogItemId === null || catalogItemId === undefined) {
            throw new Error('Required parameter catalogItemId was null or undefined when calling updateCatalogItem.');
        }

        // verify required parameter 'updateCatalogItem' is not null or undefined
        if (updateCatalogItem === null || updateCatalogItem === undefined) {
            throw new Error('Required parameter updateCatalogItem was null or undefined when calling updateCatalogItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateCatalogItem, "UpdateCatalogItem")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CatalogProductsApiApiKeys {
}

export class CatalogProductsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CatalogProductsApiApiKeys, value: string) {
        (this.authentications as any)[CatalogProductsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Archive Product
     * @param appId 
     * @param catalogItemId 
     * @param {*} [options] Override http request options.
     */
    public archiveProduct (appId: string, catalogItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/catalog/products/{catalogItemId}/archive'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'catalogItemId' + '}', encodeURIComponent(String(catalogItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling archiveProduct.');
        }

        // verify required parameter 'catalogItemId' is not null or undefined
        if (catalogItemId === null || catalogItemId === undefined) {
            throw new Error('Required parameter catalogItemId was null or undefined when calling archiveProduct.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Create a Product
     * @param appId 
     * @param createProduct 
     * @param {*} [options] Override http request options.
     */
    public createProduct (appId: string, createProduct: CreateProduct, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultProduct;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/catalog/products'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createProduct.');
        }

        // verify required parameter 'createProduct' is not null or undefined
        if (createProduct === null || createProduct === undefined) {
            throw new Error('Required parameter createProduct was null or undefined when calling createProduct.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createProduct, "CreateProduct")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultProduct;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultProduct");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Duplicate Product
     * @param appId 
     * @param catalogItemId 
     * @param {*} [options] Override http request options.
     */
    public duplicateProduct (appId: string, catalogItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/catalog/products/{catalogItemId}/duplicate'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'catalogItemId' + '}', encodeURIComponent(String(catalogItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling duplicateProduct.');
        }

        // verify required parameter 'catalogItemId' is not null or undefined
        if (catalogItemId === null || catalogItemId === undefined) {
            throw new Error('Required parameter catalogItemId was null or undefined when calling duplicateProduct.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Get Product by Id
     * @param appId 
     * @param catalogItemId 
     * @param {*} [options] Override http request options.
     */
    public getProductById (appId: string, catalogItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Product;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/catalog/products/{catalogItemId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'catalogItemId' + '}', encodeURIComponent(String(catalogItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getProductById.');
        }

        // verify required parameter 'catalogItemId' is not null or undefined
        if (catalogItemId === null || catalogItemId === undefined) {
            throw new Error('Required parameter catalogItemId was null or undefined when calling getProductById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Product;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Product");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Get paginated products by app name id filtered by types
     * @param appId 
     * @param productTypes 
     * @param searchTerm 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getProducts (appId: string, productTypes: Array<'Product' | 'Modifier'>, searchTerm?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultProduct;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/catalog/products'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getProducts.');
        }

        // verify required parameter 'productTypes' is not null or undefined
        if (productTypes === null || productTypes === undefined) {
            throw new Error('Required parameter productTypes was null or undefined when calling getProducts.');
        }

        if (productTypes !== undefined) {
            localVarQueryParameters['productTypes'] = ObjectSerializer.serialize(productTypes, "Array<'Product' | 'Modifier'>");
        }

        if (searchTerm !== undefined) {
            localVarQueryParameters['searchTerm'] = ObjectSerializer.serialize(searchTerm, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultProduct;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultProduct");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [BETA - this endpoint is under development, do not use it in your production system]
     * @summary Update Product
     * @param appId 
     * @param catalogItemId 
     * @param updateProduct 
     * @param {*} [options] Override http request options.
     */
    public updateProduct (appId: string, catalogItemId: string, updateProduct: UpdateProduct, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/catalog/products/{catalogItemId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'catalogItemId' + '}', encodeURIComponent(String(catalogItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateProduct.');
        }

        // verify required parameter 'catalogItemId' is not null or undefined
        if (catalogItemId === null || catalogItemId === undefined) {
            throw new Error('Required parameter catalogItemId was null or undefined when calling updateProduct.');
        }

        // verify required parameter 'updateProduct' is not null or undefined
        if (updateProduct === null || updateProduct === undefined) {
            throw new Error('Required parameter updateProduct was null or undefined when calling updateProduct.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateProduct, "UpdateProduct")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ChannelsApiApiKeys {
}

export class ChannelsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ChannelsApiApiKeys, value: string) {
        (this.authentications as any)[ChannelsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param channelId 
     * @param {*} [options] Override http request options.
     */
    public assignAppIdToSalesChannel (appId: string, channelId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/channels/{channelId}/assign-appId'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'channelId' + '}', encodeURIComponent(String(channelId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling assignAppIdToSalesChannel.');
        }

        // verify required parameter 'channelId' is not null or undefined
        if (channelId === null || channelId === undefined) {
            throw new Error('Required parameter channelId was null or undefined when calling assignAppIdToSalesChannel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param appId 
     * @param channelId 
     * @param {*} [options] Override http request options.
     */
    public assignStoreToChannel (storeId: number, appId: string, channelId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/channels/assign-store'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling assignStoreToChannel.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling assignStoreToChannel.');
        }

        // verify required parameter 'channelId' is not null or undefined
        if (channelId === null || channelId === undefined) {
            throw new Error('Required parameter channelId was null or undefined when calling assignStoreToChannel.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (channelId !== undefined) {
            localVarQueryParameters['channelId'] = ObjectSerializer.serialize(channelId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param channelId 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public attachStoreToSalesChannel (appId: string, channelId: number, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/channels/{channelId}/stores/{storeId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'channelId' + '}', encodeURIComponent(String(channelId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling attachStoreToSalesChannel.');
        }

        // verify required parameter 'channelId' is not null or undefined
        if (channelId === null || channelId === undefined) {
            throw new Error('Required parameter channelId was null or undefined when calling attachStoreToSalesChannel.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling attachStoreToSalesChannel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param channelId 
     * @param {*} [options] Override http request options.
     */
    public detachAllStoresFromSalesChannel (appId: string, channelId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/channels/{channelId}/stores'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'channelId' + '}', encodeURIComponent(String(channelId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling detachAllStoresFromSalesChannel.');
        }

        // verify required parameter 'channelId' is not null or undefined
        if (channelId === null || channelId === undefined) {
            throw new Error('Required parameter channelId was null or undefined when calling detachAllStoresFromSalesChannel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param channelId 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public detachStoreFromSalesChannel (appId: string, channelId: number, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/channels/{channelId}/stores/{storeId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'channelId' + '}', encodeURIComponent(String(channelId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling detachStoreFromSalesChannel.');
        }

        // verify required parameter 'channelId' is not null or undefined
        if (channelId === null || channelId === undefined) {
            throw new Error('Required parameter channelId was null or undefined when calling detachStoreFromSalesChannel.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling detachStoreFromSalesChannel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getAssignedChannels (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultChannel;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/channels/assigned-channels'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getAssignedChannels.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultChannel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultChannel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getAvailableChannels (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultChannel;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/channels/available-channels'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getAvailableChannels.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultChannel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultChannel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getChannel (id: number, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultChannel;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/channels/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getChannel.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getChannel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultChannel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultChannel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getChannels (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultChannel;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/channels'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getChannels.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultChannel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultChannel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param channelId 
     * @param {*} [options] Override http request options.
     */
    public getStoresAssignedToChannel (appId: string, channelId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultStoreChannelAssignment;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/channels/{channelId}/assigned-stores'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'channelId' + '}', encodeURIComponent(String(channelId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getStoresAssignedToChannel.');
        }

        // verify required parameter 'channelId' is not null or undefined
        if (channelId === null || channelId === undefined) {
            throw new Error('Required parameter channelId was null or undefined when calling getStoresAssignedToChannel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultStoreChannelAssignment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultStoreChannelAssignment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param channelId 
     * @param {*} [options] Override http request options.
     */
    public getStoresBySalesChannel (appId: string, channelId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Response;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/channels/{channelId}/stores'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'channelId' + '}', encodeURIComponent(String(channelId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getStoresBySalesChannel.');
        }

        // verify required parameter 'channelId' is not null or undefined
        if (channelId === null || channelId === undefined) {
            throw new Error('Required parameter channelId was null or undefined when calling getStoresBySalesChannel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param appId 
     * @param channelId 
     * @param {*} [options] Override http request options.
     */
    public unassignStoreFromChannel (storeId: number, appId: string, channelId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/channels/unassign-store'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling unassignStoreFromChannel.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling unassignStoreFromChannel.');
        }

        // verify required parameter 'channelId' is not null or undefined
        if (channelId === null || channelId === undefined) {
            throw new Error('Required parameter channelId was null or undefined when calling unassignStoreFromChannel.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (channelId !== undefined) {
            localVarQueryParameters['channelId'] = ObjectSerializer.serialize(channelId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ChannelsStoreMappingApiApiKeys {
}

export class ChannelsStoreMappingApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ChannelsStoreMappingApiApiKeys, value: string) {
        (this.authentications as any)[ChannelsStoreMappingApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param channelId 
     * @param {*} [options] Override http request options.
     */
    public channelsGetStoreChannelStoreMapping (appId: string, channelId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultStoreChannelStoreMapping;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/channels/storemappings'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling channelsGetStoreChannelStoreMapping.');
        }

        // verify required parameter 'channelId' is not null or undefined
        if (channelId === null || channelId === undefined) {
            throw new Error('Required parameter channelId was null or undefined when calling channelsGetStoreChannelStoreMapping.');
        }

        if (channelId !== undefined) {
            localVarQueryParameters['channelId'] = ObjectSerializer.serialize(channelId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultStoreChannelStoreMapping;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultStoreChannelStoreMapping");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param channelId 
     * @param stores 
     * @param {*} [options] Override http request options.
     */
    public channelsSetStoreChannelStoreMapping (appId: string, channelId: number, stores: Array<ChannelStoreMapping>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultStoreChannelStoreMapping;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/channels/storemappings'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling channelsSetStoreChannelStoreMapping.');
        }

        // verify required parameter 'channelId' is not null or undefined
        if (channelId === null || channelId === undefined) {
            throw new Error('Required parameter channelId was null or undefined when calling channelsSetStoreChannelStoreMapping.');
        }

        // verify required parameter 'stores' is not null or undefined
        if (stores === null || stores === undefined) {
            throw new Error('Required parameter stores was null or undefined when calling channelsSetStoreChannelStoreMapping.');
        }

        if (channelId !== undefined) {
            localVarQueryParameters['channelId'] = ObjectSerializer.serialize(channelId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(stores, "Array<ChannelStoreMapping>")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultStoreChannelStoreMapping;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultStoreChannelStoreMapping");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ClientsApiApiKeys {
}

export class ClientsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ClientsApiApiKeys, value: string) {
        (this.authentications as any)[ClientsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param clientId 
     * @param {*} [options] Override http request options.
     */
    public getClient (clientId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/clients/{clientId}'
            .replace('{' + 'clientId' + '}', encodeURIComponent(String(clientId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling getClient.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param clientId 
     * @param salesForceContactId 
     * @param {*} [options] Override http request options.
     */
    public setSalesForceContactId (clientId: number, salesForceContactId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/clients/{clientId}/salesforcecontactid'
            .replace('{' + 'clientId' + '}', encodeURIComponent(String(clientId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling setSalesForceContactId.');
        }

        // verify required parameter 'salesForceContactId' is not null or undefined
        if (salesForceContactId === null || salesForceContactId === undefined) {
            throw new Error('Required parameter salesForceContactId was null or undefined when calling setSalesForceContactId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(salesForceContactId, "string")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param clientId 
     * @param stripeCustomerId 
     * @param {*} [options] Override http request options.
     */
    public setStripeCustomerId (clientId: number, stripeCustomerId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/clients/{clientId}/stripecustomerid'
            .replace('{' + 'clientId' + '}', encodeURIComponent(String(clientId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling setStripeCustomerId.');
        }

        // verify required parameter 'stripeCustomerId' is not null or undefined
        if (stripeCustomerId === null || stripeCustomerId === undefined) {
            throw new Error('Required parameter stripeCustomerId was null or undefined when calling setStripeCustomerId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(stripeCustomerId, "string")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ContentSecurityPolicyApiApiKeys {
}

export class ContentSecurityPolicyApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ContentSecurityPolicyApiApiKeys, value: string) {
        (this.authentications as any)[ContentSecurityPolicyApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public contentSecurityPolicyReport (request: CspReportRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/csp/report';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling contentSecurityPolicyReport.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "CspReportRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CrossSellApiApiKeys {
}

export class CrossSellApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CrossSellApiApiKeys, value: string) {
        (this.authentications as any)[CrossSellApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param menuId 
     * @param menuItemId 
     * @param limit 
     * @param totalValue 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getCrossSellMenuItems (menuId: number, menuItemId: Array<number>, limit: number, totalValue: number, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultCrossSellMenuItems;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/crossSell/menuItems'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getCrossSellMenuItems.');
        }

        // verify required parameter 'menuItemId' is not null or undefined
        if (menuItemId === null || menuItemId === undefined) {
            throw new Error('Required parameter menuItemId was null or undefined when calling getCrossSellMenuItems.');
        }

        // verify required parameter 'limit' is not null or undefined
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling getCrossSellMenuItems.');
        }

        // verify required parameter 'totalValue' is not null or undefined
        if (totalValue === null || totalValue === undefined) {
            throw new Error('Required parameter totalValue was null or undefined when calling getCrossSellMenuItems.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getCrossSellMenuItems.');
        }

        if (menuId !== undefined) {
            localVarQueryParameters['menuId'] = ObjectSerializer.serialize(menuId, "number");
        }

        if (menuItemId !== undefined) {
            localVarQueryParameters['menuItemId'] = ObjectSerializer.serialize(menuItemId, "Array<number>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (totalValue !== undefined) {
            localVarQueryParameters['totalValue'] = ObjectSerializer.serialize(totalValue, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultCrossSellMenuItems;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultCrossSellMenuItems");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CustomersApiApiKeys {
}

export class CustomersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CustomersApiApiKeys, value: string) {
        (this.authentications as any)[CustomersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param customerCreateModel 
     * @param {*} [options] Override http request options.
     */
    public createCustomer (appId: string, customerCreateModel: CustomerCreateModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultCustomer;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customers'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createCustomer.');
        }

        // verify required parameter 'customerCreateModel' is not null or undefined
        if (customerCreateModel === null || customerCreateModel === undefined) {
            throw new Error('Required parameter customerCreateModel was null or undefined when calling createCustomer.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(customerCreateModel, "CustomerCreateModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultCustomer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultCustomer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param customerId 
     * @param {*} [options] Override http request options.
     */
    public getCustomerById (appId: string, customerId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultCustomer;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customers/{customerId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'customerId' + '}', encodeURIComponent(String(customerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getCustomerById.');
        }

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling getCustomerById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultCustomer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultCustomer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param customerId 
     * @param updateCustomer 
     * @param {*} [options] Override http request options.
     */
    public updateCustomerById (appId: string, customerId: number, updateCustomer: CustomerUpdateModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultCustomer;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customers/{customerId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'customerId' + '}', encodeURIComponent(String(customerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateCustomerById.');
        }

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling updateCustomerById.');
        }

        // verify required parameter 'updateCustomer' is not null or undefined
        if (updateCustomer === null || updateCustomer === undefined) {
            throw new Error('Required parameter updateCustomer was null or undefined when calling updateCustomerById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateCustomer, "CustomerUpdateModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultCustomer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultCustomer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DeliveryZoneApiApiKeys {
}

export class DeliveryZoneApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DeliveryZoneApiApiKeys, value: string) {
        (this.authentications as any)[DeliveryZoneApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param storeId 
     * @param deliveryZoneBase 
     * @param {*} [options] Override http request options.
     */
    public addDeliveryZone (storeId: number, deliveryZoneBase: DeliveryZoneBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultDeliveryZone;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/deliveryzones'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling addDeliveryZone.');
        }

        // verify required parameter 'deliveryZoneBase' is not null or undefined
        if (deliveryZoneBase === null || deliveryZoneBase === undefined) {
            throw new Error('Required parameter deliveryZoneBase was null or undefined when calling addDeliveryZone.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(deliveryZoneBase, "DeliveryZoneBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultDeliveryZone;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultDeliveryZone");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public getDeliveryZones (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultDeliveryZone;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/deliveryzones'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getDeliveryZones.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultDeliveryZone;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultDeliveryZone");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param deliveryZoneId 
     * @param {*} [options] Override http request options.
     */
    public removeDeliveryZone (storeId: number, deliveryZoneId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/deliveryzones/{deliveryZoneId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryZoneId' + '}', encodeURIComponent(String(deliveryZoneId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling removeDeliveryZone.');
        }

        // verify required parameter 'deliveryZoneId' is not null or undefined
        if (deliveryZoneId === null || deliveryZoneId === undefined) {
            throw new Error('Required parameter deliveryZoneId was null or undefined when calling removeDeliveryZone.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param deliveryZoneId 
     * @param deliveryZone 
     * @param {*} [options] Override http request options.
     */
    public updateDeliveryZone (storeId: number, deliveryZoneId: number, deliveryZone: DeliveryZoneBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultDeliveryZone;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/deliveryzones/{deliveryZoneId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryZoneId' + '}', encodeURIComponent(String(deliveryZoneId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updateDeliveryZone.');
        }

        // verify required parameter 'deliveryZoneId' is not null or undefined
        if (deliveryZoneId === null || deliveryZoneId === undefined) {
            throw new Error('Required parameter deliveryZoneId was null or undefined when calling updateDeliveryZone.');
        }

        // verify required parameter 'deliveryZone' is not null or undefined
        if (deliveryZone === null || deliveryZone === undefined) {
            throw new Error('Required parameter deliveryZone was null or undefined when calling updateDeliveryZone.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(deliveryZone, "DeliveryZoneBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultDeliveryZone;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultDeliveryZone");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DeviceApiApiKeys {
}

export class DeviceApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DeviceApiApiKeys, value: string) {
        (this.authentications as any)[DeviceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param assignDeviceRequest 
     * @param {*} [options] Override http request options.
     */
    public assignDevice (appId: string, assignDeviceRequest: ClientDeviceAssignEnrolledDevice, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultClientDeviceEnrollmentResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/devices/assign'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling assignDevice.');
        }

        // verify required parameter 'assignDeviceRequest' is not null or undefined
        if (assignDeviceRequest === null || assignDeviceRequest === undefined) {
            throw new Error('Required parameter assignDeviceRequest was null or undefined when calling assignDevice.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(assignDeviceRequest, "ClientDeviceAssignEnrolledDevice")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultClientDeviceEnrollmentResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultClientDeviceEnrollmentResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param deviceEnrollmentRequest 
     * @param {*} [options] Override http request options.
     */
    public enrollDevice (appId: string, deviceEnrollmentRequest: ClientDeviceEnroll, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultClientDeviceEnrollmentResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/devices/enroll'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling enrollDevice.');
        }

        // verify required parameter 'deviceEnrollmentRequest' is not null or undefined
        if (deviceEnrollmentRequest === null || deviceEnrollmentRequest === undefined) {
            throw new Error('Required parameter deviceEnrollmentRequest was null or undefined when calling enrollDevice.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(deviceEnrollmentRequest, "ClientDeviceEnroll")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultClientDeviceEnrollmentResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultClientDeviceEnrollmentResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param deviceModel 
     * @param deviceId 
     * @param {*} [options] Override http request options.
     */
    public getDeviceDetails (appId: string, deviceModel: string, deviceId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultClientDevice;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/devices/device/{deviceModel}/{deviceId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceModel' + '}', encodeURIComponent(String(deviceModel)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getDeviceDetails.');
        }

        // verify required parameter 'deviceModel' is not null or undefined
        if (deviceModel === null || deviceModel === undefined) {
            throw new Error('Required parameter deviceModel was null or undefined when calling getDeviceDetails.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling getDeviceDetails.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultClientDevice;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultClientDevice");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param storeId 
     * @param deviceModel 
     * @param {*} [options] Override http request options.
     */
    public searchDevices (appId: string, storeId?: number, deviceModel?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultClientDeviceSummary;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/devices/search'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling searchDevices.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (deviceModel !== undefined) {
            localVarQueryParameters['deviceModel'] = ObjectSerializer.serialize(deviceModel, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultClientDeviceSummary;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultClientDeviceSummary");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DriversApiApiKeys {
}

export class DriversApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DriversApiApiKeys, value: string) {
        (this.authentications as any)[DriversApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param updateDriverToken 
     * @param {*} [options] Override http request options.
     */
    public driversAddDriverNotificationToken (updateDriverToken: UpdateDriverNotificationToken, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/token';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'updateDriverToken' is not null or undefined
        if (updateDriverToken === null || updateDriverToken === undefined) {
            throw new Error('Required parameter updateDriverToken was null or undefined when calling driversAddDriverNotificationToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateDriverToken, "UpdateDriverNotificationToken")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public driversDeleteDriverProfileImage (options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/profile/image';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param driverLoginModel 
     * @param {*} [options] Override http request options.
     */
    public driversDriverLogin (driverLoginModel: DriverLoginModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/login';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'driverLoginModel' is not null or undefined
        if (driverLoginModel === null || driverLoginModel === undefined) {
            throw new Error('Required parameter driverLoginModel was null or undefined when calling driversDriverLogin.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(driverLoginModel, "DriverLoginModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param driverRequestLoginPinModel 
     * @param {*} [options] Override http request options.
     */
    public driversDriverRequestLoginCodeSms (driverRequestLoginPinModel: DriverRequestLoginPinModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/pin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'driverRequestLoginPinModel' is not null or undefined
        if (driverRequestLoginPinModel === null || driverRequestLoginPinModel === undefined) {
            throw new Error('Required parameter driverRequestLoginPinModel was null or undefined when calling driversDriverRequestLoginCodeSms.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(driverRequestLoginPinModel, "DriverRequestLoginPinModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public driversGetDriverProfile (options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/profile';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public driversGetStoresForDriver (options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/assignedstores';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param removeDriverToken 
     * @param {*} [options] Override http request options.
     */
    public driversRemoveDriverNotificationToken (removeDriverToken: UpdateDriverNotificationToken, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/token';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'removeDriverToken' is not null or undefined
        if (removeDriverToken === null || removeDriverToken === undefined) {
            throw new Error('Required parameter removeDriverToken was null or undefined when calling driversRemoveDriverNotificationToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(removeDriverToken, "UpdateDriverNotificationToken")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param presence 
     * @param {*} [options] Override http request options.
     */
    public driversSetDriverPresenceForStore (storeId: number, presence: 'Offline' | 'Online', options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/stores/{storeId}/presence/{presence}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'presence' + '}', encodeURIComponent(String(presence)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling driversSetDriverPresenceForStore.');
        }

        // verify required parameter 'presence' is not null or undefined
        if (presence === null || presence === undefined) {
            throw new Error('Required parameter presence was null or undefined when calling driversSetDriverPresenceForStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public driversSetDriverProfileImage (options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/profile/image';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param orderId 
     * @param deliveryTrackingStatus 
     * @param {*} [options] Override http request options.
     */
    public driversUpdateDeliveryTrackingStatus (orderId: number, deliveryTrackingStatus: 'Unassigned' | 'Unaccepted' | 'Accepted' | 'Carrying' | 'OnTheWay' | 'ArrivedAtLocation' | 'Delivered' | 'CannotDeliver', options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{orderId}/tracking/{deliveryTrackingStatus}'
            .replace('{' + 'orderId' + '}', encodeURIComponent(String(orderId)))
            .replace('{' + 'deliveryTrackingStatus' + '}', encodeURIComponent(String(deliveryTrackingStatus)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling driversUpdateDeliveryTrackingStatus.');
        }

        // verify required parameter 'deliveryTrackingStatus' is not null or undefined
        if (deliveryTrackingStatus === null || deliveryTrackingStatus === undefined) {
            throw new Error('Required parameter deliveryTrackingStatus was null or undefined when calling driversUpdateDeliveryTrackingStatus.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param updateDriverProfile 
     * @param {*} [options] Override http request options.
     */
    public driversUpdateDriverProfile (updateDriverProfile: UpdateDriverProfileModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/drivers/profile';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'updateDriverProfile' is not null or undefined
        if (updateDriverProfile === null || updateDriverProfile === undefined) {
            throw new Error('Required parameter updateDriverProfile was null or undefined when calling driversUpdateDriverProfile.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateDriverProfile, "UpdateDriverProfileModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EventsApiApiKeys {
}

export class EventsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EventsApiApiKeys, value: string) {
        (this.authentications as any)[EventsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param customerId 
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeIdList Events that have Store Id List
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param menuId Events that have Menu Id
     * @param campaignId Events that have Campaign Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getCustomerEvents (appId: string, customerId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId?: number, storeIdList?: Array<number>, storeGroupId?: number, userId?: number, menuId?: number, campaignId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/events/customer/{customerId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'customerId' + '}', encodeURIComponent(String(customerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getCustomerEvents.');
        }

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling getCustomerEvents.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (storeIdList !== undefined) {
            localVarQueryParameters['storeIdList'] = ObjectSerializer.serialize(storeIdList, "Array<number>");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }

        if (menuId !== undefined) {
            localVarQueryParameters['menuId'] = ObjectSerializer.serialize(menuId, "number");
        }

        if (campaignId !== undefined) {
            localVarQueryParameters['campaignId'] = ObjectSerializer.serialize(campaignId, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param whiteLabelId 
     * @param customerId 
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeIdList Events that have Store Id List
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param menuId Events that have Menu Id
     * @param campaignId Events that have Campaign Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getEvents (appId: string, whiteLabelId?: number, customerId?: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId?: number, storeIdList?: Array<number>, storeGroupId?: number, userId?: number, menuId?: number, campaignId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/events'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getEvents.');
        }

        if (whiteLabelId !== undefined) {
            localVarQueryParameters['whiteLabelId'] = ObjectSerializer.serialize(whiteLabelId, "number");
        }

        if (customerId !== undefined) {
            localVarQueryParameters['customerId'] = ObjectSerializer.serialize(customerId, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (storeIdList !== undefined) {
            localVarQueryParameters['storeIdList'] = ObjectSerializer.serialize(storeIdList, "Array<number>");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }

        if (menuId !== undefined) {
            localVarQueryParameters['menuId'] = ObjectSerializer.serialize(menuId, "number");
        }

        if (campaignId !== undefined) {
            localVarQueryParameters['campaignId'] = ObjectSerializer.serialize(campaignId, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param eventId 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getEventsById (eventId: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: EventSearchResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/events/{eventId}'
            .replace('{' + 'eventId' + '}', encodeURIComponent(String(eventId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'eventId' is not null or undefined
        if (eventId === null || eventId === undefined) {
            throw new Error('Required parameter eventId was null or undefined when calling getEventsById.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getEventsById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: EventSearchResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EventSearchResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param menuId 
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeIdList Events that have Store Id List
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param menuId2 Events that have Menu Id
     * @param campaignId Events that have Campaign Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getMenuEvents (appId: string, menuId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId?: number, storeIdList?: Array<number>, storeGroupId?: number, userId?: number, menuId2?: number, campaignId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/events/menu/{menuId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getMenuEvents.');
        }

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuEvents.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (storeIdList !== undefined) {
            localVarQueryParameters['storeIdList'] = ObjectSerializer.serialize(storeIdList, "Array<number>");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }

        if (menuId2 !== undefined) {
            localVarQueryParameters['menuId'] = ObjectSerializer.serialize(menuId2, "number");
        }

        if (campaignId !== undefined) {
            localVarQueryParameters['campaignId'] = ObjectSerializer.serialize(campaignId, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param orderId 
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId2 Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeIdList Events that have Store Id List
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param menuId Events that have Menu Id
     * @param campaignId Events that have Campaign Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getOrderEvents (appId: string, orderId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId2?: number, storeId?: number, storeIdList?: Array<number>, storeGroupId?: number, userId?: number, menuId?: number, campaignId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/events/order/{orderId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'orderId' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOrderEvents.');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getOrderEvents.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId2 !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId2, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (storeIdList !== undefined) {
            localVarQueryParameters['storeIdList'] = ObjectSerializer.serialize(storeIdList, "Array<number>");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }

        if (menuId !== undefined) {
            localVarQueryParameters['menuId'] = ObjectSerializer.serialize(menuId, "number");
        }

        if (campaignId !== undefined) {
            localVarQueryParameters['campaignId'] = ObjectSerializer.serialize(campaignId, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param customerId 
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeIdList Events that have Store Id List
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param menuId Events that have Menu Id
     * @param campaignId Events that have Campaign Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getOrderEventsByCustomer (appId: string, customerId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId?: number, storeIdList?: Array<number>, storeGroupId?: number, userId?: number, menuId?: number, campaignId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/events/order'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOrderEventsByCustomer.');
        }

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling getOrderEventsByCustomer.');
        }

        if (customerId !== undefined) {
            localVarQueryParameters['customerId'] = ObjectSerializer.serialize(customerId, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (storeIdList !== undefined) {
            localVarQueryParameters['storeIdList'] = ObjectSerializer.serialize(storeIdList, "Array<number>");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }

        if (menuId !== undefined) {
            localVarQueryParameters['menuId'] = ObjectSerializer.serialize(menuId, "number");
        }

        if (campaignId !== undefined) {
            localVarQueryParameters['campaignId'] = ObjectSerializer.serialize(campaignId, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param storeId 
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId2 Events that have Store Id
     * @param storeIdList Events that have Store Id List
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param menuId Events that have Menu Id
     * @param campaignId Events that have Campaign Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getStoreEvents (appId: string, storeId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId2?: number, storeIdList?: Array<number>, storeGroupId?: number, userId?: number, menuId?: number, campaignId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/events/store/{storeId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getStoreEvents.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getStoreEvents.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId, "number");
        }

        if (storeId2 !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId2, "number");
        }

        if (storeIdList !== undefined) {
            localVarQueryParameters['storeIdList'] = ObjectSerializer.serialize(storeIdList, "Array<number>");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }

        if (menuId !== undefined) {
            localVarQueryParameters['menuId'] = ObjectSerializer.serialize(menuId, "number");
        }

        if (campaignId !== undefined) {
            localVarQueryParameters['campaignId'] = ObjectSerializer.serialize(campaignId, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param userId 
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeIdList Events that have Store Id List
     * @param storeGroupId Events that have Store Group Id
     * @param userId2 Events that have User Id
     * @param menuId Events that have Menu Id
     * @param campaignId Events that have Campaign Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getUserEvents (appId: string, userId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId?: number, storeIdList?: Array<number>, storeGroupId?: number, userId2?: number, menuId?: number, campaignId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/events/user/{userId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getUserEvents.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserEvents.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (storeIdList !== undefined) {
            localVarQueryParameters['storeIdList'] = ObjectSerializer.serialize(storeIdList, "Array<number>");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId2 !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId2, "number");
        }

        if (menuId !== undefined) {
            localVarQueryParameters['menuId'] = ObjectSerializer.serialize(menuId, "number");
        }

        if (campaignId !== undefined) {
            localVarQueryParameters['campaignId'] = ObjectSerializer.serialize(campaignId, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param whitelabelId 
     * @param limit The maximum elements to return
     * @param page The index of the page to return, starting by 1
     * @param start Start date
     * @param end End date
     * @param orderId Events that have Order Id
     * @param storeId Events that have Store Id
     * @param storeIdList Events that have Store Id List
     * @param storeGroupId Events that have Store Group Id
     * @param userId Events that have User Id
     * @param menuId Events that have Menu Id
     * @param campaignId Events that have Campaign Id
     * @param userEmail Events that have User Email
     * @param userName Events that have User Name
     * @param voucherCode Events that have voucher code
     * @param eventType Events that have event type\\s
     * @param flipdishEventId Unique Identifier of Event, if this is specified, all other criteria are ignored.
     * @param {*} [options] Override http request options.
     */
    public getWhiteLabelEvents (appId: string, whitelabelId: number, limit?: number, page?: number, start?: Date, end?: Date, orderId?: number, storeId?: number, storeIdList?: Array<number>, storeGroupId?: number, userId?: number, menuId?: number, campaignId?: number, userEmail?: string, userName?: string, voucherCode?: string, eventType?: Array<string>, flipdishEventId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/events/whitelabel/{whitelabelId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'whitelabelId' + '}', encodeURIComponent(String(whitelabelId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getWhiteLabelEvents.');
        }

        // verify required parameter 'whitelabelId' is not null or undefined
        if (whitelabelId === null || whitelabelId === undefined) {
            throw new Error('Required parameter whitelabelId was null or undefined when calling getWhiteLabelEvents.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (orderId !== undefined) {
            localVarQueryParameters['orderId'] = ObjectSerializer.serialize(orderId, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (storeIdList !== undefined) {
            localVarQueryParameters['storeIdList'] = ObjectSerializer.serialize(storeIdList, "Array<number>");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }

        if (menuId !== undefined) {
            localVarQueryParameters['menuId'] = ObjectSerializer.serialize(menuId, "number");
        }

        if (campaignId !== undefined) {
            localVarQueryParameters['campaignId'] = ObjectSerializer.serialize(campaignId, "number");
        }

        if (userEmail !== undefined) {
            localVarQueryParameters['userEmail'] = ObjectSerializer.serialize(userEmail, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (voucherCode !== undefined) {
            localVarQueryParameters['voucherCode'] = ObjectSerializer.serialize(voucherCode, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "Array<string>");
        }

        if (flipdishEventId !== undefined) {
            localVarQueryParameters['flipdishEventId'] = ObjectSerializer.serialize(flipdishEventId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiEventSearchPaginationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiEventSearchPaginationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FeaturesApiApiKeys {
}

export class FeaturesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: FeaturesApiApiKeys, value: string) {
        (this.authentications as any)[FeaturesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param features 
     * @param {*} [options] Override http request options.
     */
    public disableFeatures (appId: string, features: Array<string>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringArrayResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/features/disable'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling disableFeatures.');
        }

        // verify required parameter 'features' is not null or undefined
        if (features === null || features === undefined) {
            throw new Error('Required parameter features was null or undefined when calling disableFeatures.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(features, "Array<string>")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringArrayResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringArrayResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param features 
     * @param {*} [options] Override http request options.
     */
    public enableFeatures (appId: string, features: Array<string>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringArrayResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/features/enable'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling enableFeatures.');
        }

        // verify required parameter 'features' is not null or undefined
        if (features === null || features === undefined) {
            throw new Error('Required parameter features was null or undefined when calling enableFeatures.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(features, "Array<string>")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringArrayResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringArrayResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FilesApiApiKeys {
}

export class FilesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: FilesApiApiKeys, value: string) {
        (this.authentications as any)[FilesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param fileId 
     * @param {*} [options] Override http request options.
     */
    public downloadFile (appId: string, fileId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultFileDownloadResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/files/download/{fileId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'fileId' + '}', encodeURIComponent(String(fileId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling downloadFile.');
        }

        // verify required parameter 'fileId' is not null or undefined
        if (fileId === null || fileId === undefined) {
            throw new Error('Required parameter fileId was null or undefined when calling downloadFile.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultFileDownloadResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultFileDownloadResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FirebaseAppsApiApiKeys {
}

export class FirebaseAppsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: FirebaseAppsApiApiKeys, value: string) {
        (this.authentications as any)[FirebaseAppsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param firebaseApp 
     * @param {*} [options] Override http request options.
     */
    public firebaseAppsAddFirebaseApp (firebaseApp: FirebaseApp, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/FirebaseApp';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'firebaseApp' is not null or undefined
        if (firebaseApp === null || firebaseApp === undefined) {
            throw new Error('Required parameter firebaseApp was null or undefined when calling firebaseAppsAddFirebaseApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(firebaseApp, "FirebaseApp")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param whitelabelId 
     * @param {*} [options] Override http request options.
     */
    public firebaseAppsGetFirebaseApp (whitelabelId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/FirebaseApp/{whitelabelId}'
            .replace('{' + 'whitelabelId' + '}', encodeURIComponent(String(whitelabelId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'whitelabelId' is not null or undefined
        if (whitelabelId === null || whitelabelId === undefined) {
            throw new Error('Required parameter whitelabelId was null or undefined when calling firebaseAppsGetFirebaseApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FpmApiApiKeys {
}

export class FpmApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: FpmApiApiKeys, value: string) {
        (this.authentications as any)[FpmApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param storeId 
     * @param phoneNumber 
     * @param {*} [options] Override http request options.
     */
    public createFpmForStore (storeId: number, phoneNumber: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{storeId}/fpm'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling createFpmForStore.');
        }

        // verify required parameter 'phoneNumber' is not null or undefined
        if (phoneNumber === null || phoneNumber === undefined) {
            throw new Error('Required parameter phoneNumber was null or undefined when calling createFpmForStore.');
        }

        if (phoneNumber !== undefined) {
            localVarQueryParameters['phoneNumber'] = ObjectSerializer.serialize(phoneNumber, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param telephonyConfig 
     * @param {*} [options] Override http request options.
     */
    public editFpmForStore (storeId: number, telephonyConfig: TelephonyConfig, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{storeId}/fpm/edit'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling editFpmForStore.');
        }

        // verify required parameter 'telephonyConfig' is not null or undefined
        if (telephonyConfig === null || telephonyConfig === undefined) {
            throw new Error('Required parameter telephonyConfig was null or undefined when calling editFpmForStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(telephonyConfig, "TelephonyConfig")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FulfillmentStateConfigurationApiApiKeys {
}

export class FulfillmentStateConfigurationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: FulfillmentStateConfigurationApiApiKeys, value: string) {
        (this.authentications as any)[FulfillmentStateConfigurationApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param fulfillmentStateConfiguration 
     * @param {*} [options] Override http request options.
     */
    public createFulfillmentStatesConfig (appId: string, fulfillmentStateConfiguration: CreateFulfillmentStatesConfiguration, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultFulfillmentStatesConfiguration;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/fulfillment/configuration/states'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createFulfillmentStatesConfig.');
        }

        // verify required parameter 'fulfillmentStateConfiguration' is not null or undefined
        if (fulfillmentStateConfiguration === null || fulfillmentStateConfiguration === undefined) {
            throw new Error('Required parameter fulfillmentStateConfiguration was null or undefined when calling createFulfillmentStatesConfig.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(fulfillmentStateConfiguration, "CreateFulfillmentStatesConfiguration")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultFulfillmentStatesConfiguration;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultFulfillmentStatesConfiguration");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param configId 
     * @param {*} [options] Override http request options.
     */
    public deleteFulfillmentStatesConfig (appId: string, configId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/fulfillment/configuration/states/{configId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'configId' + '}', encodeURIComponent(String(configId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteFulfillmentStatesConfig.');
        }

        // verify required parameter 'configId' is not null or undefined
        if (configId === null || configId === undefined) {
            throw new Error('Required parameter configId was null or undefined when calling deleteFulfillmentStatesConfig.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param configId 
     * @param {*} [options] Override http request options.
     */
    public getFulfillmentStatesConfiguration (appId: string, configId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FulfillmentStatesConfiguration;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/fulfillment/configuration/states/{configId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'configId' + '}', encodeURIComponent(String(configId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getFulfillmentStatesConfiguration.');
        }

        // verify required parameter 'configId' is not null or undefined
        if (configId === null || configId === undefined) {
            throw new Error('Required parameter configId was null or undefined when calling getFulfillmentStatesConfiguration.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FulfillmentStatesConfiguration;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FulfillmentStatesConfiguration");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getFulfillmentStatesConfigurationTemplate (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FulfillmentStatesConfiguration;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/fulfillment/configuration/states_template'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getFulfillmentStatesConfigurationTemplate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FulfillmentStatesConfiguration;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FulfillmentStatesConfiguration");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public searchFulfillmentStatesConfigurations (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultFulfillmentStatesConfigurationSummary;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/fulfillment/configuration/states'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling searchFulfillmentStatesConfigurations.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultFulfillmentStatesConfigurationSummary;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultFulfillmentStatesConfigurationSummary");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param configId 
     * @param updateFulfillmentStatesConfiguration 
     * @param {*} [options] Override http request options.
     */
    public updateFulfillmentStatesConfig (appId: string, configId: string, updateFulfillmentStatesConfiguration: UpdateFulfillmentStatesConfiguration, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/fulfillment/configuration/states/{configId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'configId' + '}', encodeURIComponent(String(configId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateFulfillmentStatesConfig.');
        }

        // verify required parameter 'configId' is not null or undefined
        if (configId === null || configId === undefined) {
            throw new Error('Required parameter configId was null or undefined when calling updateFulfillmentStatesConfig.');
        }

        // verify required parameter 'updateFulfillmentStatesConfiguration' is not null or undefined
        if (updateFulfillmentStatesConfiguration === null || updateFulfillmentStatesConfiguration === undefined) {
            throw new Error('Required parameter updateFulfillmentStatesConfiguration was null or undefined when calling updateFulfillmentStatesConfig.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateFulfillmentStatesConfiguration, "UpdateFulfillmentStatesConfiguration")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum GoogleFoodOrderPrototypeApiApiKeys {
}

export class GoogleFoodOrderPrototypeApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: GoogleFoodOrderPrototypeApiApiKeys, value: string) {
        (this.authentications as any)[GoogleFoodOrderPrototypeApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param orderRequest 
     * @param {*} [options] Override http request options.
     */
    public createOrder (appId: string, orderRequest: CreateOrderRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultSubmitOrderResponseDm;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/googleorder'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createOrder.');
        }

        // verify required parameter 'orderRequest' is not null or undefined
        if (orderRequest === null || orderRequest === undefined) {
            throw new Error('Required parameter orderRequest was null or undefined when calling createOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(orderRequest, "CreateOrderRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultSubmitOrderResponseDm;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultSubmitOrderResponseDm");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param orderId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public submitOrder (appId: string, orderId: number, request: SubmitOrderRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultSubmitOrderResponseDm;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/googleorder/{orderId}/submit'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'orderId' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling submitOrder.');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling submitOrder.');
        }

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling submitOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "SubmitOrderRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultSubmitOrderResponseDm;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultSubmitOrderResponseDm");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum HeartbeatApiApiKeys {
}

export class HeartbeatApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: HeartbeatApiApiKeys, value: string) {
        (this.authentications as any)[HeartbeatApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public headHostname (options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/heartbeat/Hostname';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'HEAD',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public headPing (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/heartbeat';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'HEAD',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public hostname (options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/heartbeat/Hostname';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public ping (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/heartbeat';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum HomeApiApiKeys {
}

export class HomeApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: HomeApiApiKeys, value: string) {
        (this.authentications as any)[HomeApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param homeActionId 
     * @param isDismissed 
     * @param {*} [options] Override http request options.
     */
    public completeHomeAction (appId: string, homeActionId: number, isDismissed: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/home/{homeActionId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'homeActionId' + '}', encodeURIComponent(String(homeActionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling completeHomeAction.');
        }

        // verify required parameter 'homeActionId' is not null or undefined
        if (homeActionId === null || homeActionId === undefined) {
            throw new Error('Required parameter homeActionId was null or undefined when calling completeHomeAction.');
        }

        // verify required parameter 'isDismissed' is not null or undefined
        if (isDismissed === null || isDismissed === undefined) {
            throw new Error('Required parameter isDismissed was null or undefined when calling completeHomeAction.');
        }

        if (isDismissed !== undefined) {
            localVarQueryParameters['isDismissed'] = ObjectSerializer.serialize(isDismissed, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getHomeActions (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultHomeAction;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/home'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getHomeActions.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultHomeAction;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultHomeAction");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getHomeStatistics (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultHomeStatistics;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/home/stats'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getHomeStatistics.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultHomeStatistics;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultHomeStatistics");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public getOktaPortalFeatureFlag (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultOktaPortalFeatureFlag;  }> {
        const localVarPath = this.basePath + '/api/v1.0/home/okta-portal';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultOktaPortalFeatureFlag;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultOktaPortalFeatureFlag");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum HttpRequestResponseLogsApiApiKeys {
}

export class HttpRequestResponseLogsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: HttpRequestResponseLogsApiApiKeys, value: string) {
        (this.authentications as any)[HttpRequestResponseLogsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param start 
     * @param end 
     * @param appId 
     * @param filterByUserId 
     * @param guid 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getLogs (start: Date, end: Date, appId: string, filterByUserId?: number, guid?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultHttpRequestAndResponseLog;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/interactions/logs'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'start' is not null or undefined
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling getLogs.');
        }

        // verify required parameter 'end' is not null or undefined
        if (end === null || end === undefined) {
            throw new Error('Required parameter end was null or undefined when calling getLogs.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getLogs.');
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (filterByUserId !== undefined) {
            localVarQueryParameters['filterByUserId'] = ObjectSerializer.serialize(filterByUserId, "number");
        }

        if (guid !== undefined) {
            localVarQueryParameters['guid'] = ObjectSerializer.serialize(guid, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultHttpRequestAndResponseLog;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultHttpRequestAndResponseLog");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum HydraApiApiKeys {
}

export class HydraApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: HydraApiApiKeys, value: string) {
        (this.authentications as any)[HydraApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param hydraConfigId 
     * @param emvTerminalId 
     * @param {*} [options] Override http request options.
     */
    public assignEmv (appId: string, hydraConfigId: number, emvTerminalId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/emvterminal/assign/{hydraConfigId}/{emvTerminalId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'hydraConfigId' + '}', encodeURIComponent(String(hydraConfigId)))
            .replace('{' + 'emvTerminalId' + '}', encodeURIComponent(String(emvTerminalId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling assignEmv.');
        }

        // verify required parameter 'hydraConfigId' is not null or undefined
        if (hydraConfigId === null || hydraConfigId === undefined) {
            throw new Error('Required parameter hydraConfigId was null or undefined when calling assignEmv.');
        }

        // verify required parameter 'emvTerminalId' is not null or undefined
        if (emvTerminalId === null || emvTerminalId === undefined) {
            throw new Error('Required parameter emvTerminalId was null or undefined when calling assignEmv.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param storeId 
     * @param deviceId 
     * @param {*} [options] Override http request options.
     */
    public attachStoreToKiosk (appId: string, storeId: number, deviceId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/AttachStoreToKiosk/{deviceId}/store/{storeId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling attachStoreToKiosk.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling attachStoreToKiosk.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling attachStoreToKiosk.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultHydraStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param deviceId 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public attachStoreToTerminal (appId: string, deviceId: string, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/{deviceId}/attach/{storeId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling attachStoreToTerminal.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling attachStoreToTerminal.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling attachStoreToTerminal.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultHydraStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param orderId 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public cancelEmvPayment (orderId: number, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/cancelemvpayment/{orderId}'
            .replace('{' + 'orderId' + '}', encodeURIComponent(String(orderId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling cancelEmvPayment.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling cancelEmvPayment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param deviceId 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public detachStoreFromTerminal (appId: string, deviceId: string, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/{deviceId}/detach/{storeId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling detachStoreFromTerminal.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling detachStoreFromTerminal.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling detachStoreFromTerminal.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultHydraStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public getAblyToken (options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/hydra/ably_token';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param deviceType 
     * @param deviceId 
     * @param {*} [options] Override http request options.
     */
    public getAttachedDevice (appId: string, deviceType: 'Kiosk' | 'Terminal' | 'LegacyPrinter', deviceId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultHydraDeviceDetails;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/{deviceType}/{deviceId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceType' + '}', encodeURIComponent(String(deviceType)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getAttachedDevice.');
        }

        // verify required parameter 'deviceType' is not null or undefined
        if (deviceType === null || deviceType === undefined) {
            throw new Error('Required parameter deviceType was null or undefined when calling getAttachedDevice.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling getAttachedDevice.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultHydraDeviceDetails;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultHydraDeviceDetails");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param deviceType 
     * @param pageIndex 
     * @param pageSize 
     * @param storeId 
     * @param deviceName 
     * @param deviceSerial 
     * @param {*} [options] Override http request options.
     */
    public getAttachedDevices (appId: string, deviceType: 'Kiosk' | 'Terminal' | 'LegacyPrinter', pageIndex?: number, pageSize?: number, storeId?: number, deviceName?: string, deviceSerial?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultHydraDeviceDetails;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/{deviceType}/list'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceType' + '}', encodeURIComponent(String(deviceType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getAttachedDevices.');
        }

        // verify required parameter 'deviceType' is not null or undefined
        if (deviceType === null || deviceType === undefined) {
            throw new Error('Required parameter deviceType was null or undefined when calling getAttachedDevices.');
        }

        if (pageIndex !== undefined) {
            localVarQueryParameters['pageIndex'] = ObjectSerializer.serialize(pageIndex, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (deviceName !== undefined) {
            localVarQueryParameters['deviceName'] = ObjectSerializer.serialize(deviceName, "string");
        }

        if (deviceSerial !== undefined) {
            localVarQueryParameters['deviceSerial'] = ObjectSerializer.serialize(deviceSerial, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultHydraDeviceDetails;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultHydraDeviceDetails");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getEMVTerminalDetails (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultPaymentTerminalDetails;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/emvterminal'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getEMVTerminalDetails.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultPaymentTerminalDetails;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultPaymentTerminalDetails");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param orderId 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getEmvOrderState (orderId: number, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultPaymentTerminalTransactionDetails;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/emvorderstate/{orderId}'
            .replace('{' + 'orderId' + '}', encodeURIComponent(String(orderId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getEmvOrderState.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getEmvOrderState.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultPaymentTerminalTransactionDetails;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultPaymentTerminalTransactionDetails");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param deviceId 
     * @param {*} [options] Override http request options.
     */
    public getKioskCashPaymentSettings (appId: string, deviceId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultKioskCashPaymentSettings;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/kioskcashsettings/{deviceId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getKioskCashPaymentSettings.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling getKioskCashPaymentSettings.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultKioskCashPaymentSettings;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultKioskCashPaymentSettings");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param deviceId 
     * @param {*} [options] Override http request options.
     */
    public getKioskSettings (appId: string, deviceId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultKioskSettings;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/kiosksettings/{deviceId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getKioskSettings.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling getKioskSettings.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultKioskSettings;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultKioskSettings");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public getRegistration (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }> {
        const localVarPath = this.basePath + '/api/v1.0/hydra/registration';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultHydraStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public getSettings (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultHydraConfig;  }> {
        const localVarPath = this.basePath + '/api/v1.0/hydra/settings';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultHydraConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultHydraConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param emv 
     * @param {*} [options] Override http request options.
     */
    public hydraCreateEmv (appId: string, emv: EmvTerminal, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/emvterminals'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling hydraCreateEmv.');
        }

        // verify required parameter 'emv' is not null or undefined
        if (emv === null || emv === undefined) {
            throw new Error('Required parameter emv was null or undefined when calling hydraCreateEmv.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(emv, "EmvTerminal")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public hydraDeleteEmv (appId: string, id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/emvterminals/{id}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling hydraDeleteEmv.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling hydraDeleteEmv.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param storeId 
     * @param deviceId 
     * @param {*} [options] Override http request options.
     */
    public hydraDetachStoreFromKiosk (appId: string, storeId: number, deviceId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/DetachStoreFromKiosk/{deviceId}/store/{storeId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling hydraDetachStoreFromKiosk.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling hydraDetachStoreFromKiosk.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling hydraDetachStoreFromKiosk.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultHydraStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public hydraGetEmvsForAppId (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultEmvTerminalWithAssignments;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/emvterminals'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling hydraGetEmvsForAppId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultEmvTerminalWithAssignments;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultEmvTerminalWithAssignments");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param deviceId 
     * @param hydraUserType 
     * @param serialNumber 
     * @param {*} [options] Override http request options.
     */
    public loginWithDeviceId (deviceId: string, hydraUserType?: 'Kiosk' | 'Terminal' | 'LegacyPrinter', serialNumber?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/hydra/{deviceId}/login'
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling loginWithDeviceId.');
        }

        if (hydraUserType !== undefined) {
            localVarQueryParameters['hydraUserType'] = ObjectSerializer.serialize(hydraUserType, "'Kiosk' | 'Terminal' | 'LegacyPrinter'");
        }

        if (serialNumber !== undefined) {
            localVarQueryParameters['serialNumber'] = ObjectSerializer.serialize(serialNumber, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param hydraRegistration 
     * @param {*} [options] Override http request options.
     */
    public register (appId: string, hydraRegistration: HydraRegistrationRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/registration'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling register.');
        }

        // verify required parameter 'hydraRegistration' is not null or undefined
        if (hydraRegistration === null || hydraRegistration === undefined) {
            throw new Error('Required parameter hydraRegistration was null or undefined when calling register.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(hydraRegistration, "HydraRegistrationRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultHydraStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultHydraStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param deviceId 
     * @param {*} [options] Override http request options.
     */
    public unAssign (appId: string, deviceId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/{deviceId}/registration'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling unAssign.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling unAssign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param hydraConfigId 
     * @param {*} [options] Override http request options.
     */
    public unassignEmv (appId: string, hydraConfigId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/hydra/emvterminal/unassign/{hydraConfigId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'hydraConfigId' + '}', encodeURIComponent(String(hydraConfigId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling unassignEmv.');
        }

        // verify required parameter 'hydraConfigId' is not null or undefined
        if (hydraConfigId === null || hydraConfigId === undefined) {
            throw new Error('Required parameter hydraConfigId was null or undefined when calling unassignEmv.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param deviceId 
     * @param isCashEnabled 
     * @param {*} [options] Override http request options.
     */
    public updateKioskCashVisibilitySettings (appId: string, deviceId: string, isCashEnabled: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/kioskupdatecashsettings'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateKioskCashVisibilitySettings.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling updateKioskCashVisibilitySettings.');
        }

        // verify required parameter 'isCashEnabled' is not null or undefined
        if (isCashEnabled === null || isCashEnabled === undefined) {
            throw new Error('Required parameter isCashEnabled was null or undefined when calling updateKioskCashVisibilitySettings.');
        }

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (isCashEnabled !== undefined) {
            localVarQueryParameters['isCashEnabled'] = ObjectSerializer.serialize(isCashEnabled, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param deviceId 
     * @param settings 
     * @param {*} [options] Override http request options.
     */
    public updateKioskSettings (appId: string, deviceId: string, settings: KioskSettings, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/kiosksettings/{deviceId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateKioskSettings.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling updateKioskSettings.');
        }

        // verify required parameter 'settings' is not null or undefined
        if (settings === null || settings === undefined) {
            throw new Error('Required parameter settings was null or undefined when calling updateKioskSettings.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(settings, "KioskSettings")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum IntercomApiApiKeys {
}

export class IntercomApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: IntercomApiApiKeys, value: string) {
        (this.authentications as any)[IntercomApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public userHash (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultIntercomUserHash;  }> {
        const localVarPath = this.basePath + '/api/v1.0/intercom/userHash';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultIntercomUserHash;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultIntercomUserHash");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum InvoicesApiApiKeys {
}

export class InvoicesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: InvoicesApiApiKeys, value: string) {
        (this.authentications as any)[InvoicesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param subscriptionId 
     * @param limit 
     * @param pageId 
     * @param excludeNotOwnedInvoices 
     * @param dateFrom 
     * @param dateTo 
     * @param invoiceNumber 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public getInvoices (appId: string, subscriptionId?: string, limit?: number, pageId?: string, excludeNotOwnedInvoices?: boolean, dateFrom?: Date, dateTo?: Date, invoiceNumber?: string, storeId?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiFinanceSearchPaginationResultInvoice;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/invoices'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getInvoices.');
        }

        if (subscriptionId !== undefined) {
            localVarQueryParameters['subscriptionId'] = ObjectSerializer.serialize(subscriptionId, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (pageId !== undefined) {
            localVarQueryParameters['pageId'] = ObjectSerializer.serialize(pageId, "string");
        }

        if (excludeNotOwnedInvoices !== undefined) {
            localVarQueryParameters['excludeNotOwnedInvoices'] = ObjectSerializer.serialize(excludeNotOwnedInvoices, "boolean");
        }

        if (dateFrom !== undefined) {
            localVarQueryParameters['dateFrom'] = ObjectSerializer.serialize(dateFrom, "Date");
        }

        if (dateTo !== undefined) {
            localVarQueryParameters['dateTo'] = ObjectSerializer.serialize(dateTo, "Date");
        }

        if (invoiceNumber !== undefined) {
            localVarQueryParameters['invoiceNumber'] = ObjectSerializer.serialize(invoiceNumber, "string");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiFinanceSearchPaginationResultInvoice;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiFinanceSearchPaginationResultInvoice");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum KioskEntitlementsApiApiKeys {
}

export class KioskEntitlementsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: KioskEntitlementsApiApiKeys, value: string) {
        (this.authentications as any)[KioskEntitlementsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public queryKioskEntitlements (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultKioskEntitlementsResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/kiosk/entitlements'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling queryKioskEntitlements.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultKioskEntitlementsResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultKioskEntitlementsResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum KioskIotApiApiKeys {
}

export class KioskIotApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: KioskIotApiApiKeys, value: string) {
        (this.authentications as any)[KioskIotApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public getKioskIotConnection (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultKioskIotConnectionParameters;  }> {
        const localVarPath = this.basePath + '/api/v1.0/kioskiot/connect';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultKioskIotConnectionParameters;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultKioskIotConnectionParameters");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param queryParams 
     * @param {*} [options] Override http request options.
     */
    public queryTelemetrySeries (appId: string, queryParams: TelemetrySeriesQueryParameters, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultTelemetrySeriesResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/kioskiot/timeseries/query'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling queryTelemetrySeries.');
        }

        // verify required parameter 'queryParams' is not null or undefined
        if (queryParams === null || queryParams === undefined) {
            throw new Error('Required parameter queryParams was null or undefined when calling queryTelemetrySeries.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(queryParams, "TelemetrySeriesQueryParameters")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultTelemetrySeriesResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultTelemetrySeriesResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LightspeedApiApiKeys {
}

export class LightspeedApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LightspeedApiApiKeys, value: string) {
        (this.authentications as any)[LightspeedApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public lightspeedGenerateMenu (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/lightspeed/{storeId}/menu/generate'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling lightspeedGenerateMenu.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public lightspeedGetStoreSettings (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultLightspeedSettings;  }> {
        const localVarPath = this.basePath + '/api/v1.0/lightspeed/{storeId}/settings'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling lightspeedGetStoreSettings.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultLightspeedSettings;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultLightspeedSettings");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param lightspeedSettings 
     * @param {*} [options] Override http request options.
     */
    public lightspeedSaveStoreSettings (storeId: number, lightspeedSettings: LightspeedSettings, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultLightspeedSettings;  }> {
        const localVarPath = this.basePath + '/api/v1.0/lightspeed/{storeId}/settings'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling lightspeedSaveStoreSettings.');
        }

        // verify required parameter 'lightspeedSettings' is not null or undefined
        if (lightspeedSettings === null || lightspeedSettings === undefined) {
            throw new Error('Required parameter lightspeedSettings was null or undefined when calling lightspeedSaveStoreSettings.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(lightspeedSettings, "LightspeedSettings")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultLightspeedSettings;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultLightspeedSettings");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LocationApiApiKeys {
}

export class LocationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LocationApiApiKeys, value: string) {
        (this.authentications as any)[LocationApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param createLocationInput 
     * @param locationAreaId 
     * @param appId 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public createLocation (createLocationInput: Array<CreateLocation>, locationAreaId: number, appId: string, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stores/{storeId}/location-areas/{locationAreaId}/location'
            .replace('{' + 'locationAreaId' + '}', encodeURIComponent(String(locationAreaId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'createLocationInput' is not null or undefined
        if (createLocationInput === null || createLocationInput === undefined) {
            throw new Error('Required parameter createLocationInput was null or undefined when calling createLocation.');
        }

        // verify required parameter 'locationAreaId' is not null or undefined
        if (locationAreaId === null || locationAreaId === undefined) {
            throw new Error('Required parameter locationAreaId was null or undefined when calling createLocation.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createLocation.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling createLocation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createLocationInput, "Array<CreateLocation>")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param locationId 
     * @param locationAreaId 
     * @param appId 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public deleteLocation (locationId: number, locationAreaId: number, appId: string, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stores/{storeId}/location-areas/{locationAreaId}/location/{locationId}/delete'
            .replace('{' + 'locationId' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'locationAreaId' + '}', encodeURIComponent(String(locationAreaId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling deleteLocation.');
        }

        // verify required parameter 'locationAreaId' is not null or undefined
        if (locationAreaId === null || locationAreaId === undefined) {
            throw new Error('Required parameter locationAreaId was null or undefined when calling deleteLocation.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteLocation.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling deleteLocation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param locationId 
     * @param locationAreaId 
     * @param appId 
     * @param storeId 
     * @param externalLocationId 
     * @param {*} [options] Override http request options.
     */
    public mapLocationToExternalId (locationId: number, locationAreaId: number, appId: string, storeId: number, externalLocationId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMappedLocation;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stores/{storeId}/location-areas/{locationAreaId}/location/{locationId}/map-external'
            .replace('{' + 'locationId' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'locationAreaId' + '}', encodeURIComponent(String(locationAreaId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling mapLocationToExternalId.');
        }

        // verify required parameter 'locationAreaId' is not null or undefined
        if (locationAreaId === null || locationAreaId === undefined) {
            throw new Error('Required parameter locationAreaId was null or undefined when calling mapLocationToExternalId.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling mapLocationToExternalId.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling mapLocationToExternalId.');
        }

        if (externalLocationId !== undefined) {
            localVarQueryParameters['externalLocationId'] = ObjectSerializer.serialize(externalLocationId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMappedLocation;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMappedLocation");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param locationId 
     * @param locationAreaId 
     * @param newLocationAreaId 
     * @param appId 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public moveLocation (locationId: number, locationAreaId: number, newLocationAreaId: number, appId: string, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stores/{storeId}/location-areas/{locationAreaId}/location/{locationId}/move'
            .replace('{' + 'locationId' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'locationAreaId' + '}', encodeURIComponent(String(locationAreaId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling moveLocation.');
        }

        // verify required parameter 'locationAreaId' is not null or undefined
        if (locationAreaId === null || locationAreaId === undefined) {
            throw new Error('Required parameter locationAreaId was null or undefined when calling moveLocation.');
        }

        // verify required parameter 'newLocationAreaId' is not null or undefined
        if (newLocationAreaId === null || newLocationAreaId === undefined) {
            throw new Error('Required parameter newLocationAreaId was null or undefined when calling moveLocation.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling moveLocation.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling moveLocation.');
        }

        if (newLocationAreaId !== undefined) {
            localVarQueryParameters['newLocationAreaId'] = ObjectSerializer.serialize(newLocationAreaId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param updateLocationInput 
     * @param locationAreaId 
     * @param locationId 
     * @param appId 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public updateLocation (updateLocationInput: CreateLocation, locationAreaId: number, locationId: number, appId: string, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultLocationAreaLocation;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stores/{storeId}/location-areas/{locationAreaId}/location/{locationId}/update'
            .replace('{' + 'locationAreaId' + '}', encodeURIComponent(String(locationAreaId)))
            .replace('{' + 'locationId' + '}', encodeURIComponent(String(locationId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'updateLocationInput' is not null or undefined
        if (updateLocationInput === null || updateLocationInput === undefined) {
            throw new Error('Required parameter updateLocationInput was null or undefined when calling updateLocation.');
        }

        // verify required parameter 'locationAreaId' is not null or undefined
        if (locationAreaId === null || locationAreaId === undefined) {
            throw new Error('Required parameter locationAreaId was null or undefined when calling updateLocation.');
        }

        // verify required parameter 'locationId' is not null or undefined
        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling updateLocation.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateLocation.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updateLocation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateLocationInput, "CreateLocation")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultLocationAreaLocation;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultLocationAreaLocation");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LocationAreasApiApiKeys {
}

export class LocationAreasApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LocationAreasApiApiKeys, value: string) {
        (this.authentications as any)[LocationAreasApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param locationAreaInput 
     * @param appId 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public createLocationArea (locationAreaInput: CreateLocationArea, appId: string, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stores/{storeId}/location-areas'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationAreaInput' is not null or undefined
        if (locationAreaInput === null || locationAreaInput === undefined) {
            throw new Error('Required parameter locationAreaInput was null or undefined when calling createLocationArea.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createLocationArea.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling createLocationArea.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(locationAreaInput, "CreateLocationArea")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param locationAreaId 
     * @param appId 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public getLocationArea (locationAreaId: number, appId: string, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultLocationAreaWithLocations;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stores/{storeId}/location-areas/{locationAreaId}'
            .replace('{' + 'locationAreaId' + '}', encodeURIComponent(String(locationAreaId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationAreaId' is not null or undefined
        if (locationAreaId === null || locationAreaId === undefined) {
            throw new Error('Required parameter locationAreaId was null or undefined when calling getLocationArea.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getLocationArea.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getLocationArea.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultLocationAreaWithLocations;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultLocationAreaWithLocations");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public getLocationAreasForStore (appId: string, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultLocationAreaWithLocations;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stores/{storeId}/location-areas'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getLocationAreasForStore.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getLocationAreasForStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultLocationAreaWithLocations;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultLocationAreaWithLocations");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param locationAreaInput 
     * @param appId 
     * @param storeId 
     * @param locationAreaId 
     * @param {*} [options] Override http request options.
     */
    public updateLocationArea (locationAreaInput: UpdateLocationArea, appId: string, storeId: number, locationAreaId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultLocationArea;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stores/{storeId}/location-areas/{locationAreaId}/update'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'locationAreaId' + '}', encodeURIComponent(String(locationAreaId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locationAreaInput' is not null or undefined
        if (locationAreaInput === null || locationAreaInput === undefined) {
            throw new Error('Required parameter locationAreaInput was null or undefined when calling updateLocationArea.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateLocationArea.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updateLocationArea.');
        }

        // verify required parameter 'locationAreaId' is not null or undefined
        if (locationAreaId === null || locationAreaId === undefined) {
            throw new Error('Required parameter locationAreaId was null or undefined when calling updateLocationArea.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(locationAreaInput, "UpdateLocationArea")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultLocationArea;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultLocationArea");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LookerDashboardApiApiKeys {
}

export class LookerDashboardApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LookerDashboardApiApiKeys, value: string) {
        (this.authentications as any)[LookerDashboardApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public lookerDashboardGetAll (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/looker/dashboards'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling lookerDashboardGetAll.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LookerSingleSignOnApiApiKeys {
}

export class LookerSingleSignOnApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LookerSingleSignOnApiApiKeys, value: string) {
        (this.authentications as any)[LookerSingleSignOnApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param embedPath 
     * @param filters 
     * @param {*} [options] Override http request options.
     */
    public getSSOEndpoint (appId: string, embedPath: string, filters?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: DashboardEmbed;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/looker/sso'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getSSOEndpoint.');
        }

        // verify required parameter 'embedPath' is not null or undefined
        if (embedPath === null || embedPath === undefined) {
            throw new Error('Required parameter embedPath was null or undefined when calling getSSOEndpoint.');
        }

        if (embedPath !== undefined) {
            localVarQueryParameters['embedPath'] = ObjectSerializer.serialize(embedPath, "string");
        }

        if (filters !== undefined) {
            localVarQueryParameters['filters'] = ObjectSerializer.serialize(filters, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DashboardEmbed;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DashboardEmbed");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenuOptionSetItemsApiApiKeys {
}

export class MenuOptionSetItemsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MenuOptionSetItemsApiApiKeys, value: string) {
        (this.authentications as any)[MenuOptionSetItemsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Create menu item option set item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItem Option set item
     * @param {*} [options] Override http request options.
     */
    public addMenuItemOptionSetItem (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItem: MenuItemOptionSetItemBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling addMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling addMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling addMenuItemOptionSetItem.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling addMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuItemOptionSetItem' is not null or undefined
        if (menuItemOptionSetItem === null || menuItemOptionSetItem === undefined) {
            throw new Error('Required parameter menuItemOptionSetItem was null or undefined when calling addMenuItemOptionSetItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuItemOptionSetItem, "MenuItemOptionSetItemBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu item option set item image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItemId Option set item identifier
     * @param {*} [options] Override http request options.
     */
    public deleteOptionSetItemImage (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)))
            .replace('{' + 'menuItemOptionSetItemId' + '}', encodeURIComponent(String(menuItemOptionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteOptionSetItemImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteOptionSetItemImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling deleteOptionSetItemImage.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling deleteOptionSetItemImage.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling deleteOptionSetItemImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item option set item by identifier
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItemId Option set item identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItemOptionSetItemById (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenuItemOptionSetItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)))
            .replace('{' + 'menuItemOptionSetItemId' + '}', encodeURIComponent(String(menuItemOptionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemOptionSetItemById.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItemOptionSetItemById.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling getMenuItemOptionSetItemById.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling getMenuItemOptionSetItemById.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling getMenuItemOptionSetItemById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenuItemOptionSetItem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenuItemOptionSetItem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item option set items
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItemOptionSetItems (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuItemOptionSetItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemOptionSetItems.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItemOptionSetItems.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling getMenuItemOptionSetItems.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling getMenuItemOptionSetItems.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuItemOptionSetItem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuItemOptionSetItem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu item option set item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItemId Option set item identifier
     * @param {*} [options] Override http request options.
     */
    public removeMenuItemOptionSetItem (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)))
            .replace('{' + 'menuItemOptionSetItemId' + '}', encodeURIComponent(String(menuItemOptionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling removeMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling removeMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling removeMenuItemOptionSetItem.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling removeMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling removeMenuItemOptionSetItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set Tax Rate on OptionSetItem
     * @param menuId Menu identifier
     * @param menuSectionId 
     * @param menuSectionItemId 
     * @param optionSetId 
     * @param menuItemOptionSetItemId Option set item identifier
     * @param taxRateId Tax Rate to use
     * @param {*} [options] Override http request options.
     */
    public setOptionSetItemTax (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number, taxRateId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}/taxrate/{taxRateId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)))
            .replace('{' + 'menuItemOptionSetItemId' + '}', encodeURIComponent(String(menuItemOptionSetItemId)))
            .replace('{' + 'taxRateId' + '}', encodeURIComponent(String(taxRateId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setOptionSetItemTax.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling setOptionSetItemTax.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling setOptionSetItemTax.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling setOptionSetItemTax.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling setOptionSetItemTax.');
        }

        // verify required parameter 'taxRateId' is not null or undefined
        if (taxRateId === null || taxRateId === undefined) {
            throw new Error('Required parameter taxRateId was null or undefined when calling setOptionSetItemTax.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu item option set item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItemId Option set item identifier
     * @param menuItemOptionSetItem Option set item (delta)
     * @param undoAfter An optional time period, in hours, after which the hide-section operation will be undone.
     * @param {*} [options] Override http request options.
     */
    public updateMenuItemOptionSetItem (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number, menuItemOptionSetItem: MenuItemOptionSetItemBase, undoAfter?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)))
            .replace('{' + 'menuItemOptionSetItemId' + '}', encodeURIComponent(String(menuItemOptionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        // verify required parameter 'menuItemOptionSetItem' is not null or undefined
        if (menuItemOptionSetItem === null || menuItemOptionSetItem === undefined) {
            throw new Error('Required parameter menuItemOptionSetItem was null or undefined when calling updateMenuItemOptionSetItem.');
        }

        if (undoAfter !== undefined) {
            localVarQueryParameters['undoAfter'] = ObjectSerializer.serialize(undoAfter, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuItemOptionSetItem, "MenuItemOptionSetItemBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload menu item option set item image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSetItemId Option set item identifier
     * @param Image Option set item image
     * @param {*} [options] Override http request options.
     */
    public uploadOptionSetItemImage (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSetItemId: number, Image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/optionsetitems/{menuItemOptionSetItemId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)))
            .replace('{' + 'menuItemOptionSetItemId' + '}', encodeURIComponent(String(menuItemOptionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling uploadOptionSetItemImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling uploadOptionSetItemImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling uploadOptionSetItemImage.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling uploadOptionSetItemImage.');
        }

        // verify required parameter 'menuItemOptionSetItemId' is not null or undefined
        if (menuItemOptionSetItemId === null || menuItemOptionSetItemId === undefined) {
            throw new Error('Required parameter menuItemOptionSetItemId was null or undefined when calling uploadOptionSetItemImage.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadOptionSetItemImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenuOptionSetsApiApiKeys {
}

export class MenuOptionSetsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MenuOptionSetsApiApiKeys, value: string) {
        (this.authentications as any)[MenuOptionSetsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Create menu item option set
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param menuItemOptionSet Menu item option set
     * @param {*} [options] Override http request options.
     */
    public createMenuItemOptionSet (menuId: number, menuSectionId: number, menuSectionItemId: number, menuItemOptionSet: MenuItemOptionSetBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling createMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling createMenuItemOptionSet.');
        }

        // verify required parameter 'menuItemOptionSet' is not null or undefined
        if (menuItemOptionSet === null || menuItemOptionSet === undefined) {
            throw new Error('Required parameter menuItemOptionSet was null or undefined when calling createMenuItemOptionSet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuItemOptionSet, "MenuItemOptionSetBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu item option set
     * @param menuId Menu identifier
     * @param menuSectionItemId Menu section item identifier
     * @param menuSectionId Menu section identifier
     * @param optionSetId Option set identifier
     * @param {*} [options] Override http request options.
     */
    public deleteMenuItemOptionSet (menuId: number, menuSectionItemId: number, menuSectionId: number, optionSetId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling deleteMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteMenuItemOptionSet.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling deleteMenuItemOptionSet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete option set image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param {*} [options] Override http request options.
     */
    public deleteOptionSetImage (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteOptionSetImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteOptionSetImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling deleteOptionSetImage.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling deleteOptionSetImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item option set by identifier
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Menu item option set identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItemOptionSetById (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenuItemOptionSet;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemOptionSetById.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItemOptionSetById.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling getMenuItemOptionSetById.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling getMenuItemOptionSetById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenuItemOptionSet;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenuItemOptionSet");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item option sets
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItemOptionSets (menuId: number, menuSectionId: number, menuSectionItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuItemOptionSet;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemOptionSets.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItemOptionSets.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling getMenuItemOptionSets.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuItemOptionSet;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuItemOptionSet");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu item option set
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param menuItemOptionSet Menu item option set (delta)
     * @param {*} [options] Override http request options.
     */
    public updateMenuItemOptionSet (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, menuItemOptionSet: MenuItemOptionSetBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling updateMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling updateMenuItemOptionSet.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling updateMenuItemOptionSet.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling updateMenuItemOptionSet.');
        }

        // verify required parameter 'menuItemOptionSet' is not null or undefined
        if (menuItemOptionSet === null || menuItemOptionSet === undefined) {
            throw new Error('Required parameter menuItemOptionSet was null or undefined when calling updateMenuItemOptionSet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuItemOptionSet, "MenuItemOptionSetBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload menu item option set image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param optionSetId Option set identifier
     * @param Image Option set image
     * @param {*} [options] Override http request options.
     */
    public uploadOptionSetImage (menuId: number, menuSectionId: number, menuSectionItemId: number, optionSetId: number, Image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/optionsets/{optionSetId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'optionSetId' + '}', encodeURIComponent(String(optionSetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling uploadOptionSetImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling uploadOptionSetImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling uploadOptionSetImage.');
        }

        // verify required parameter 'optionSetId' is not null or undefined
        if (optionSetId === null || optionSetId === undefined) {
            throw new Error('Required parameter optionSetId was null or undefined when calling uploadOptionSetImage.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadOptionSetImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenuSectionItemsApiApiKeys {
}

export class MenuSectionItemsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MenuSectionItemsApiApiKeys, value: string) {
        (this.authentications as any)[MenuSectionItemsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Clone menu section item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param {*} [options] Override http request options.
     */
    public cloneMenuSectionItem (menuId: number, menuSectionId: number, menuSectionItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSectionItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/clone'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling cloneMenuSectionItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling cloneMenuSectionItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling cloneMenuSectionItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSectionItem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenuSectionItem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create menu section item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItem Menu section item
     * @param {*} [options] Override http request options.
     */
    public createMenuSectionItem (menuId: number, menuSectionId: number, menuSectionItem: MenuSectionItemBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createMenuSectionItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling createMenuSectionItem.');
        }

        // verify required parameter 'menuSectionItem' is not null or undefined
        if (menuSectionItem === null || menuSectionItem === undefined) {
            throw new Error('Required parameter menuSectionItem was null or undefined when calling createMenuSectionItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuSectionItem, "MenuSectionItemBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * BETA - this endpoint is under development, do not use it in your production system
     * @summary Create menu section items from a list of Catalog Items
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param createFromCatalogItems Information to create the new MenuSectionItems
     * @param {*} [options] Override http request options.
     */
    public createMenuSectionItemFromCatalogItems (menuId: number, menuSectionId: number, createFromCatalogItems: CreateMenuSectionItemFromCatalogItems, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/add-catalogitems'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createMenuSectionItemFromCatalogItems.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling createMenuSectionItemFromCatalogItems.');
        }

        // verify required parameter 'createFromCatalogItems' is not null or undefined
        if (createFromCatalogItems === null || createFromCatalogItems === undefined) {
            throw new Error('Required parameter createFromCatalogItems was null or undefined when calling createMenuSectionItemFromCatalogItems.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createFromCatalogItems, "CreateMenuSectionItemFromCatalogItems")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu section item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param {*} [options] Override http request options.
     */
    public deleteMenuSectionItem (menuId: number, menuSectionId: number, menuSectionItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuSectionItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteMenuSectionItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling deleteMenuSectionItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu section item image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param {*} [options] Override http request options.
     */
    public deleteMenuSectionItemImage (menuId: number, menuSectionId: number, menuSectionItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuSectionItemImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteMenuSectionItemImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling deleteMenuSectionItemImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item by identifier
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu item identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItemById (menuId: number, menuSectionId: number, menuSectionItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSectionItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemById.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItemById.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling getMenuItemById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSectionItem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenuSectionItem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu items
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItems (menuId: number, menuSectionId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuSectionItem;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItems.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuItems.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuSectionItem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuSectionItem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Move an Item within a menu
     * @param menuId Menu identifier
     * @param menuSectionId Section to put item in (will usually be original section)
     * @param menuSectionItemId ID of Item to be moved
     * @param destinationDisplayOrder New Display Order of item
     * @param {*} [options] Override http request options.
     */
    public moveMenuItem (menuId: number, menuSectionId: number, menuSectionItemId: number, destinationDisplayOrder: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/setorder/{destinationDisplayOrder}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'destinationDisplayOrder' + '}', encodeURIComponent(String(destinationDisplayOrder)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling moveMenuItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling moveMenuItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling moveMenuItem.');
        }

        // verify required parameter 'destinationDisplayOrder' is not null or undefined
        if (destinationDisplayOrder === null || destinationDisplayOrder === undefined) {
            throw new Error('Required parameter destinationDisplayOrder was null or undefined when calling moveMenuItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set tax rate for menu item
     * @param menuId Menu identifier
     * @param menuSectionId Section to put item in (will usually be original section)
     * @param menuSectionItemId ID of Item to be moved
     * @param taxRateId tax rate to be set against item
     * @param {*} [options] Override http request options.
     */
    public setSectionItemTax (menuId: number, menuSectionId: number, menuSectionItemId: number, taxRateId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/taxrate/{taxRateId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)))
            .replace('{' + 'taxRateId' + '}', encodeURIComponent(String(taxRateId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setSectionItemTax.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling setSectionItemTax.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling setSectionItemTax.');
        }

        // verify required parameter 'taxRateId' is not null or undefined
        if (taxRateId === null || taxRateId === undefined) {
            throw new Error('Required parameter taxRateId was null or undefined when calling setSectionItemTax.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu section item
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param menuSectionItem Menu section item (delta)
     * @param undoAfter An optional time period, in hours, after which the hide-section operation will be undone
     * @param {*} [options] Override http request options.
     */
    public updateMenuSectionItem (menuId: number, menuSectionId: number, menuSectionItemId: number, menuSectionItem: MenuSectionItemBase, undoAfter?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling updateMenuSectionItem.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling updateMenuSectionItem.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling updateMenuSectionItem.');
        }

        // verify required parameter 'menuSectionItem' is not null or undefined
        if (menuSectionItem === null || menuSectionItem === undefined) {
            throw new Error('Required parameter menuSectionItem was null or undefined when calling updateMenuSectionItem.');
        }

        if (undoAfter !== undefined) {
            localVarQueryParameters['undoAfter'] = ObjectSerializer.serialize(undoAfter, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuSectionItem, "MenuSectionItemBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload menu section item image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionItemId Menu section item identifier
     * @param Image Menu section item image
     * @param {*} [options] Override http request options.
     */
    public uploadMenuSectionItemImage (menuId: number, menuSectionId: number, menuSectionItemId: number, Image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitems/{menuSectionItemId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuSectionItemId' + '}', encodeURIComponent(String(menuSectionItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling uploadMenuSectionItemImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling uploadMenuSectionItemImage.');
        }

        // verify required parameter 'menuSectionItemId' is not null or undefined
        if (menuSectionItemId === null || menuSectionItemId === undefined) {
            throw new Error('Required parameter menuSectionItemId was null or undefined when calling uploadMenuSectionItemImage.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadMenuSectionItemImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenuSectionsApiApiKeys {
}

export class MenuSectionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MenuSectionsApiApiKeys, value: string) {
        (this.authentications as any)[MenuSectionsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Clone menu section
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param {*} [options] Override http request options.
     */
    public cloneMenuSection (menuId: number, menuSectionId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSection;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/clone'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling cloneMenuSection.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling cloneMenuSection.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenuSection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set/update menu section availability hours.
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param dayOfWeek Day of the  week
     * @param businessHoursPeriod Menu section active hours, note: DayOfWeek property will be overriden by the path parameter.
     * @param {*} [options] Override http request options.
     */
    public createMenuAvailabilityForDay (menuId: number, menuSectionId: number, dayOfWeek: 'Sunday' | 'Monday' | 'Tuesday' | 'Wednesday' | 'Thursday' | 'Friday' | 'Saturday', businessHoursPeriod: BusinessHoursPeriodBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/availability/times/{dayOfWeek}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'dayOfWeek' + '}', encodeURIComponent(String(dayOfWeek)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createMenuAvailabilityForDay.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling createMenuAvailabilityForDay.');
        }

        // verify required parameter 'dayOfWeek' is not null or undefined
        if (dayOfWeek === null || dayOfWeek === undefined) {
            throw new Error('Required parameter dayOfWeek was null or undefined when calling createMenuAvailabilityForDay.');
        }

        // verify required parameter 'businessHoursPeriod' is not null or undefined
        if (businessHoursPeriod === null || businessHoursPeriod === undefined) {
            throw new Error('Required parameter businessHoursPeriod was null or undefined when calling createMenuAvailabilityForDay.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(businessHoursPeriod, "BusinessHoursPeriodBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create menu section
     * @param menuId Menu identifier
     * @param menuSection Menu section
     * @param {*} [options] Override http request options.
     */
    public createMenuSection (menuId: number, menuSection: MenuSectionBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createMenuSection.');
        }

        // verify required parameter 'menuSection' is not null or undefined
        if (menuSection === null || menuSection === undefined) {
            throw new Error('Required parameter menuSection was null or undefined when calling createMenuSection.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuSection, "MenuSectionBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create menu availability type
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSectionAvailability DisplayAlways, DisplayBasedOnTimes, DisplayAlwaysStartCollapsed, DisplayAlwaysStartCollapsedBasedOnTimes
     * @param {*} [options] Override http request options.
     */
    public createMenuSectionAvailability (menuId: number, menuSectionId: number, menuSectionAvailability: MenuSectionAvailabilityBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/availability'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createMenuSectionAvailability.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling createMenuSectionAvailability.');
        }

        // verify required parameter 'menuSectionAvailability' is not null or undefined
        if (menuSectionAvailability === null || menuSectionAvailability === undefined) {
            throw new Error('Required parameter menuSectionAvailability was null or undefined when calling createMenuSectionAvailability.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuSectionAvailability, "MenuSectionAvailabilityBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu section
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param {*} [options] Override http request options.
     */
    public deleteMenuSection (menuId: number, menuSectionId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuSection.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteMenuSection.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu section image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param {*} [options] Override http request options.
     */
    public deleteMenuSectionImage (menuId: number, menuSectionId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuSectionImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling deleteMenuSectionImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu section by identifier
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuSectionById (menuId: number, menuSectionId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSection;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuSectionById.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling getMenuSectionById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenuSection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenuSection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu sections
     * @param menuId Menu identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuSections (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuSection;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuSections.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuSection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuSection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Re-arrange Items within a Section
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param displayOrders Item Ids and their new display order
     * @param {*} [options] Override http request options.
     */
    public menuSectionsSetItemDisplayOrders (menuId: number, menuSectionId: number, displayOrders: MenuObjectDisplayOrders, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/sectionitemdisplayorders'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling menuSectionsSetItemDisplayOrders.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling menuSectionsSetItemDisplayOrders.');
        }

        // verify required parameter 'displayOrders' is not null or undefined
        if (displayOrders === null || displayOrders === undefined) {
            throw new Error('Required parameter displayOrders was null or undefined when calling menuSectionsSetItemDisplayOrders.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(displayOrders, "MenuObjectDisplayOrders")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu section
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param menuSection Menu section changes (delta)
     * @param undoAfter An optional time period, in hours, after which the hide-section operation will be undone.
     * @param {*} [options] Override http request options.
     */
    public updateMenuSection (menuId: number, menuSectionId: number, menuSection: MenuSectionBase, undoAfter?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling updateMenuSection.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling updateMenuSection.');
        }

        // verify required parameter 'menuSection' is not null or undefined
        if (menuSection === null || menuSection === undefined) {
            throw new Error('Required parameter menuSection was null or undefined when calling updateMenuSection.');
        }

        if (undoAfter !== undefined) {
            localVarQueryParameters['undoAfter'] = ObjectSerializer.serialize(undoAfter, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuSection, "MenuSectionBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload menu section image
     * @param menuId Menu identifier
     * @param menuSectionId Menu section identifier
     * @param Image Menu section image
     * @param {*} [options] Override http request options.
     */
    public uploadMenuSectionImage (menuId: number, menuSectionId: number, Image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sections/{menuSectionId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling uploadMenuSectionImage.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling uploadMenuSectionImage.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadMenuSectionImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenuZonesApiApiKeys {
}

export class MenuZonesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MenuZonesApiApiKeys, value: string) {
        (this.authentications as any)[MenuZonesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Adds a new menu zone to a menu.
     * @param menuId The menu id.
     * @param menuZone The object containing the new zone. This is optional and not supplying it will generate an empty default zone.
     * @param {*} [options] Override http request options.
     */
    public addMenuZone (menuId: number, menuZone: MenuZone, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenuZone;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/zones'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling addMenuZone.');
        }

        // verify required parameter 'menuZone' is not null or undefined
        if (menuZone === null || menuZone === undefined) {
            throw new Error('Required parameter menuZone was null or undefined when calling addMenuZone.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuZone, "MenuZone")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenuZone;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenuZone");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a menu zone.
     * @param menuZoneId The menu zone id.
     * @param menuId 
     * @param {*} [options] Override http request options.
     */
    public deleteMenuZone (menuZoneId: number, menuId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/zones/{menuZoneId}'
            .replace('{' + 'menuZoneId' + '}', encodeURIComponent(String(menuZoneId)))
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuZoneId' is not null or undefined
        if (menuZoneId === null || menuZoneId === undefined) {
            throw new Error('Required parameter menuZoneId was null or undefined when calling deleteMenuZone.');
        }

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuZone.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a menu zone image.
     * @param menuZoneId The zone Id/
     * @param menuId 
     * @param {*} [options] Override http request options.
     */
    public deleteMenuZoneImage (menuZoneId: number, menuId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/zones/{menuZoneId}/image'
            .replace('{' + 'menuZoneId' + '}', encodeURIComponent(String(menuZoneId)))
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuZoneId' is not null or undefined
        if (menuZoneId === null || menuZoneId === undefined) {
            throw new Error('Required parameter menuZoneId was null or undefined when calling deleteMenuZoneImage.');
        }

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuZoneImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Flips the order of two menu zones.
     * @param menuZoneId Source.
     * @param menuZoneI2 Destination.
     * @param menuId 
     * @param {*} [options] Override http request options.
     */
    public flipMenuZones (menuZoneId: number, menuZoneI2: number, menuId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/zones/{menuZoneId}/flip/{menuZoneI2}'
            .replace('{' + 'menuZoneId' + '}', encodeURIComponent(String(menuZoneId)))
            .replace('{' + 'menuZoneI2' + '}', encodeURIComponent(String(menuZoneI2)))
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuZoneId' is not null or undefined
        if (menuZoneId === null || menuZoneId === undefined) {
            throw new Error('Required parameter menuZoneId was null or undefined when calling flipMenuZones.');
        }

        // verify required parameter 'menuZoneI2' is not null or undefined
        if (menuZoneI2 === null || menuZoneI2 === undefined) {
            throw new Error('Required parameter menuZoneI2 was null or undefined when calling flipMenuZones.');
        }

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling flipMenuZones.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets a specific menu zone for a given zone id
     * @param menuId The menu id.
     * @param menuZoneId The menu zone id.
     * @param {*} [options] Override http request options.
     */
    public getMenuZone (menuId: number, menuZoneId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenuZone;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/zones/{menuZoneId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuZoneId' + '}', encodeURIComponent(String(menuZoneId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuZone.');
        }

        // verify required parameter 'menuZoneId' is not null or undefined
        if (menuZoneId === null || menuZoneId === undefined) {
            throw new Error('Required parameter menuZoneId was null or undefined when calling getMenuZone.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenuZone;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenuZone");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets all the menu zones for a menu
     * @param menuId The menu id to load zones for
     * @param {*} [options] Override http request options.
     */
    public getMenuZonesForMenuId (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuZone;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/zones'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuZonesForMenuId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuZone;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuZone");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Sets a zone to a menu section.
     * @param menuZoneId The menu id.
     * @param menuSectionId The menu section id.
     * @param menuId 
     * @param {*} [options] Override http request options.
     */
    public setMenuSectionMenuZone (menuZoneId: number, menuSectionId: number, menuId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/zones/{menuZoneId}/section/{menuSectionId}'
            .replace('{' + 'menuZoneId' + '}', encodeURIComponent(String(menuZoneId)))
            .replace('{' + 'menuSectionId' + '}', encodeURIComponent(String(menuSectionId)))
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuZoneId' is not null or undefined
        if (menuZoneId === null || menuZoneId === undefined) {
            throw new Error('Required parameter menuZoneId was null or undefined when calling setMenuSectionMenuZone.');
        }

        // verify required parameter 'menuSectionId' is not null or undefined
        if (menuSectionId === null || menuSectionId === undefined) {
            throw new Error('Required parameter menuSectionId was null or undefined when calling setMenuSectionMenuZone.');
        }

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setMenuSectionMenuZone.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Sets the description of a menu zone.
     * @param menuZoneId The zone id.
     * @param description The new description. Add as a raw string in the request, without any JSON wrapper.
     * @param menuId 
     * @param {*} [options] Override http request options.
     */
    public setMenuZoneDescription (menuZoneId: number, description: string, menuId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/zones/{menuZoneId}/description'
            .replace('{' + 'menuZoneId' + '}', encodeURIComponent(String(menuZoneId)))
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuZoneId' is not null or undefined
        if (menuZoneId === null || menuZoneId === undefined) {
            throw new Error('Required parameter menuZoneId was null or undefined when calling setMenuZoneDescription.');
        }

        // verify required parameter 'description' is not null or undefined
        if (description === null || description === undefined) {
            throw new Error('Required parameter description was null or undefined when calling setMenuZoneDescription.');
        }

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setMenuZoneDescription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(description, "string")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Sets the name of a menu zone.
     * @param menuZoneId The menu zone id.
     * @param menuZoneName The new name.
     * @param menuId 
     * @param {*} [options] Override http request options.
     */
    public setMenuZoneName (menuZoneId: number, menuZoneName: string, menuId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/zones/{menuZoneId}/name/{menuZoneName}'
            .replace('{' + 'menuZoneId' + '}', encodeURIComponent(String(menuZoneId)))
            .replace('{' + 'menuZoneName' + '}', encodeURIComponent(String(menuZoneName)))
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuZoneId' is not null or undefined
        if (menuZoneId === null || menuZoneId === undefined) {
            throw new Error('Required parameter menuZoneId was null or undefined when calling setMenuZoneName.');
        }

        // verify required parameter 'menuZoneName' is not null or undefined
        if (menuZoneName === null || menuZoneName === undefined) {
            throw new Error('Required parameter menuZoneName was null or undefined when calling setMenuZoneName.');
        }

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setMenuZoneName.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a menu zone.
     * @param menuId The menu id.
     * @param menuZoneId The menu zone id.
     * @param menuZone The object containing the updated values.
     * @param {*} [options] Override http request options.
     */
    public updateMenuZone (menuId: number, menuZoneId: number, menuZone: MenuZone, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/zones/{menuZoneId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'menuZoneId' + '}', encodeURIComponent(String(menuZoneId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling updateMenuZone.');
        }

        // verify required parameter 'menuZoneId' is not null or undefined
        if (menuZoneId === null || menuZoneId === undefined) {
            throw new Error('Required parameter menuZoneId was null or undefined when calling updateMenuZone.');
        }

        // verify required parameter 'menuZone' is not null or undefined
        if (menuZone === null || menuZone === undefined) {
            throw new Error('Required parameter menuZone was null or undefined when calling updateMenuZone.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuZone, "MenuZone")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Uploads an image for a menu zone.
     * @param menuZoneId The zone id.
     * @param file The file to upload.
     * @param menuId 
     * @param {*} [options] Override http request options.
     */
    public uploadMenuZoneImage (menuZoneId: number, file: Array<HttpPostedFileBase>, menuId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/zones/{menuZoneId}/image'
            .replace('{' + 'menuZoneId' + '}', encodeURIComponent(String(menuZoneId)))
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuZoneId' is not null or undefined
        if (menuZoneId === null || menuZoneId === undefined) {
            throw new Error('Required parameter menuZoneId was null or undefined when calling uploadMenuZoneImage.');
        }

        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling uploadMenuZoneImage.');
        }

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling uploadMenuZoneImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(file, "Array<HttpPostedFileBase>")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenusApiApiKeys {
}

export class MenusApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MenusApiApiKeys, value: string) {
        (this.authentications as any)[MenusApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Clone a menu, (without attaching stores)
     * @param menuId Menu identifier
     * @param newName Name of the new Menu
     * @param {*} [options] Override http request options.
     */
    public createDraftMenuFromExistingMenu (menuId: number, newName: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenu;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/clone/{newName}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'newName' + '}', encodeURIComponent(String(newName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling createDraftMenuFromExistingMenu.');
        }

        // verify required parameter 'newName' is not null or undefined
        if (newName === null || newName === undefined) {
            throw new Error('Required parameter newName was null or undefined when calling createDraftMenuFromExistingMenu.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenu;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenu");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * You must listen to the webhook menu.async_creation.completed to know when the menu is ready
     * @summary Create a new menu asynchronously
     * @param appId App id
     * @param menu Menu
     * @param {*} [options] Override http request options.
     */
    public createNewMenuAsync (appId: string, menu: CreateFullMenu, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/menus/async'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createNewMenuAsync.');
        }

        // verify required parameter 'menu' is not null or undefined
        if (menu === null || menu === undefined) {
            throw new Error('Required parameter menu was null or undefined when calling createNewMenuAsync.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menu, "CreateFullMenu")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * [DEPRECATED] - Please use the async version as this endpoint may timeout for large menus
     * @summary Create a new menu
     * @param appId App identifier
     * @param menu Menu. If empty the system will create a menu with default items
     * @param {*} [options] Override http request options.
     */
    public createNewMenuForApp (appId: string, menu: CreateFullMenu, options: any = {}) : Promise<{ response: http.IncomingMessage; body: number;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/menus'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createNewMenuForApp.');
        }

        // verify required parameter 'menu' is not null or undefined
        if (menu === null || menu === undefined) {
            throw new Error('Required parameter menu was null or undefined when calling createNewMenuForApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menu, "CreateFullMenu")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: number;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "number");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Mark a Menu as Deleted
     * @param menuId Menu Identifier
     * @param {*} [options] Override http request options.
     */
    public deleteMenu (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenu.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu image
     * @param menuId Menu identifier
     * @param {*} [options] Override http request options.
     */
    public deleteMenuImage (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu item metadata
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param menuItemId Menu item identifier
     * @param key Metadata key
     * @param {*} [options] Override http request options.
     */
    public deleteMenuItemMetadata (menuId: number, storeId: number, menuItemId: number, key: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/menuitem/{menuItemId}/metadata/{key}/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'menuItemId' + '}', encodeURIComponent(String(menuItemId)))
            .replace('{' + 'key' + '}', encodeURIComponent(String(key)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuItemMetadata.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling deleteMenuItemMetadata.');
        }

        // verify required parameter 'menuItemId' is not null or undefined
        if (menuItemId === null || menuItemId === undefined) {
            throw new Error('Required parameter menuItemId was null or undefined when calling deleteMenuItemMetadata.');
        }

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling deleteMenuItemMetadata.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all menu metadata by menu ID and store ID
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param {*} [options] Override http request options.
     */
    public getAllMenuMetadataByMenuIdAndStoreId (menuId: number, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultAllMetadataResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/metadata/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getAllMenuMetadataByMenuIdAndStoreId.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getAllMenuMetadataByMenuIdAndStoreId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultAllMetadataResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultAllMetadataResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu by identifier
     * @param menuId Menu identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuById (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenu;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenu;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenu");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item metadata
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param menuItemId Menu item identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItemMetadata (menuId: number, storeId: number, menuItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMetadata;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/menuitem/{menuItemId}/metadata/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'menuItemId' + '}', encodeURIComponent(String(menuItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemMetadata.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getMenuItemMetadata.');
        }

        // verify required parameter 'menuItemId' is not null or undefined
        if (menuItemId === null || menuItemId === undefined) {
            throw new Error('Required parameter menuItemId was null or undefined when calling getMenuItemMetadata.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMetadata;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMetadata");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item metadata by key
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param menuItemId Menu item identifier
     * @param key Metadata key
     * @param {*} [options] Override http request options.
     */
    public getMenuItemMetadataByKey (menuId: number, storeId: number, menuItemId: number, key: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMetadata;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/menuitem/{menuItemId}/metadata/{key}/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'menuItemId' + '}', encodeURIComponent(String(menuItemId)))
            .replace('{' + 'key' + '}', encodeURIComponent(String(key)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemMetadataByKey.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getMenuItemMetadataByKey.');
        }

        // verify required parameter 'menuItemId' is not null or undefined
        if (menuItemId === null || menuItemId === undefined) {
            throw new Error('Required parameter menuItemId was null or undefined when calling getMenuItemMetadataByKey.');
        }

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling getMenuItemMetadataByKey.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMetadata;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMetadata");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu item option set item metadata by key
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param optionSetItemId Menu item option set item identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuItemOptionSetItemMetadata (menuId: number, storeId: number, optionSetItemId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMetadata;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/optionsetitem/{optionSetItemId}/metadata/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'optionSetItemId' + '}', encodeURIComponent(String(optionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuItemOptionSetItemMetadata.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getMenuItemOptionSetItemMetadata.');
        }

        // verify required parameter 'optionSetItemId' is not null or undefined
        if (optionSetItemId === null || optionSetItemId === undefined) {
            throw new Error('Required parameter optionSetItemId was null or undefined when calling getMenuItemOptionSetItemMetadata.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMetadata;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMetadata");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get Menus Name
     * @param menuId Menu identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuName (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/name'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuName.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menus store names
     * @param menuId Menu identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuStoreNames (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuStoreNames;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/stores'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuStoreNames.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuStoreNames;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuStoreNames");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menus tax details
     * @param menuId Menu identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuTaxDetails (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuTaxDetails;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/tax'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuTaxDetails.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuTaxDetails;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuTaxDetails");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menus by appId
     * @param appId Get Menus for this appId
     * @param {*} [options] Override http request options.
     */
    public getMenusByAppId (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuSummary;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/menus'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getMenusByAppId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuSummary;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuSummary");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a Menus Checkpoints
     * @param menuId Menu identifier
     * @param {*} [options] Override http request options.
     */
    public getMenusCheckpoints (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuCheckpoint;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/checkpoints'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenusCheckpoints.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuCheckpoint;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuCheckpoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Remove a Menus Tax Rate, can only remove a tax rate that does not have items/optionSetItems attached
     * @param menuId Menu identifier
     * @param taxId Id of Menu Tax to be removed
     * @param {*} [options] Override http request options.
     */
    public menusDeleteTaxRate (menuId: number, taxId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/tax/{taxId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'taxId' + '}', encodeURIComponent(String(taxId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling menusDeleteTaxRate.');
        }

        // verify required parameter 'taxId' is not null or undefined
        if (taxId === null || taxId === undefined) {
            throw new Error('Required parameter taxId was null or undefined when calling menusDeleteTaxRate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get bulk show/hide menu items and option set items
     * @param menuId Menu id
     * @param isAvailable Is available flag
     * @param {*} [options] Override http request options.
     */
    public menusGetMenuBulkShowHide (menuId: number, isAvailable: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuElementListResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/bulkshowhide/list'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling menusGetMenuBulkShowHide.');
        }

        // verify required parameter 'isAvailable' is not null or undefined
        if (isAvailable === null || isAvailable === undefined) {
            throw new Error('Required parameter isAvailable was null or undefined when calling menusGetMenuBulkShowHide.');
        }

        if (isAvailable !== undefined) {
            localVarQueryParameters['isAvailable'] = ObjectSerializer.serialize(isAvailable, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuElementListResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuElementListResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set if tax shows for a Menu
     * @param menuId Menu identifier
     * @param show Boolean show or dont show tax (Exclusive tax type can only ever be TRUE)
     * @param {*} [options] Override http request options.
     */
    public menusSetDisplayOnMenuTax (menuId: number, show: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/tax/show/{show}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'show' + '}', encodeURIComponent(String(show)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling menusSetDisplayOnMenuTax.');
        }

        // verify required parameter 'show' is not null or undefined
        if (show === null || show === undefined) {
            throw new Error('Required parameter show was null or undefined when calling menusSetDisplayOnMenuTax.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Re-arrange Sections within a Menu
     * @param menuId Menu identifier
     * @param displayOrders Section Ids and their new display order
     * @param {*} [options] Override http request options.
     */
    public menusSetItemDisplayOrders (menuId: number, displayOrders: MenuObjectDisplayOrders, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/sectiondisplayorders'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling menusSetItemDisplayOrders.');
        }

        // verify required parameter 'displayOrders' is not null or undefined
        if (displayOrders === null || displayOrders === undefined) {
            throw new Error('Required parameter displayOrders was null or undefined when calling menusSetItemDisplayOrders.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(displayOrders, "MenuObjectDisplayOrders")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Bulk show/hide menu items or option set items
     * @param menuId Menu id
     * @param menuElements Elements to be show/hide
     * @param isAvailable Is available flag
     * @param {*} [options] Override http request options.
     */
    public menusShowHideBulkItems (menuId: number, menuElements: Array<MenuElementHide>, isAvailable: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuElementEditResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/bulkshowhide'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling menusShowHideBulkItems.');
        }

        // verify required parameter 'menuElements' is not null or undefined
        if (menuElements === null || menuElements === undefined) {
            throw new Error('Required parameter menuElements was null or undefined when calling menusShowHideBulkItems.');
        }

        // verify required parameter 'isAvailable' is not null or undefined
        if (isAvailable === null || isAvailable === undefined) {
            throw new Error('Required parameter isAvailable was null or undefined when calling menusShowHideBulkItems.');
        }

        if (isAvailable !== undefined) {
            localVarQueryParameters['isAvailable'] = ObjectSerializer.serialize(isAvailable, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuElements, "Array<MenuElementHide>")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMenuElementEditResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMenuElementEditResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set the type of Tax on a Menu
     * @param menuId Menu identifier
     * @param type Type of Tax
     * @param {*} [options] Override http request options.
     */
    public menusUpdateTaxType (menuId: number, type: 'IncludedInBasePrice' | 'ExcludedFromBasePrice', options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/tax/type/{type}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'type' + '}', encodeURIComponent(String(type)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling menusUpdateTaxType.');
        }

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling menusUpdateTaxType.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add/Update a Tax Rate
     * @param menuId Menu identifier
     * @param taxRate Tax rate to add/update
     * @param {*} [options] Override http request options.
     */
    public menusUpsertTaxRate (menuId: number, taxRate: MenuTaxRate, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MenuTaxRate;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/taxrate'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling menusUpsertTaxRate.');
        }

        // verify required parameter 'taxRate' is not null or undefined
        if (taxRate === null || taxRate === undefined) {
            throw new Error('Required parameter taxRate was null or undefined when calling menusUpsertTaxRate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(taxRate, "MenuTaxRate")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MenuTaxRate;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MenuTaxRate");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Restore a Menu to a checkpoint
     * @param menuId Menu identifier
     * @param checkpointId Checkpoint to restore menu to
     * @param {*} [options] Override http request options.
     */
    public restoreAMenuCheckpoint (menuId: number, checkpointId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/checkpoints/{checkpointId}/restore'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'checkpointId' + '}', encodeURIComponent(String(checkpointId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling restoreAMenuCheckpoint.');
        }

        // verify required parameter 'checkpointId' is not null or undefined
        if (checkpointId === null || checkpointId === undefined) {
            throw new Error('Required parameter checkpointId was null or undefined when calling restoreAMenuCheckpoint.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu item metadata
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param menuItemId Menu item identifier
     * @param metadata Metadata object
     * @param {*} [options] Override http request options.
     */
    public setMenuItemMetadata (menuId: number, storeId: number, menuItemId: number, metadata: Metadata, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/menuitem/{menuItemId}/metadata/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'menuItemId' + '}', encodeURIComponent(String(menuItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setMenuItemMetadata.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling setMenuItemMetadata.');
        }

        // verify required parameter 'menuItemId' is not null or undefined
        if (menuItemId === null || menuItemId === undefined) {
            throw new Error('Required parameter menuItemId was null or undefined when calling setMenuItemMetadata.');
        }

        // verify required parameter 'metadata' is not null or undefined
        if (metadata === null || metadata === undefined) {
            throw new Error('Required parameter metadata was null or undefined when calling setMenuItemMetadata.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(metadata, "Metadata")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu item option set item metadata
     * @param menuId Menu identifier
     * @param storeId Store identifier
     * @param optionSetItemId Menu item option set item identifier
     * @param metadata Metadata object
     * @param {*} [options] Override http request options.
     */
    public setMenuItemOptionSetItemMetadata (menuId: number, storeId: number, optionSetItemId: number, metadata: Metadata, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/optionsetitem/{optionSetItemId}/metadata/store/{storeId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'optionSetItemId' + '}', encodeURIComponent(String(optionSetItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setMenuItemOptionSetItemMetadata.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling setMenuItemOptionSetItemMetadata.');
        }

        // verify required parameter 'optionSetItemId' is not null or undefined
        if (optionSetItemId === null || optionSetItemId === undefined) {
            throw new Error('Required parameter optionSetItemId was null or undefined when calling setMenuItemOptionSetItemMetadata.');
        }

        // verify required parameter 'metadata' is not null or undefined
        if (metadata === null || metadata === undefined) {
            throw new Error('Required parameter metadata was null or undefined when calling setMenuItemOptionSetItemMetadata.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(metadata, "Metadata")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Lock/Unlock a Menu for Editing
     * @param menuId Menu identifier
     * @param locked True: Locks menu for editing, False: Unlocks for editing
     * @param {*} [options] Override http request options.
     */
    public setMenuLock (menuId: number, locked: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/lock'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setMenuLock.');
        }

        // verify required parameter 'locked' is not null or undefined
        if (locked === null || locked === undefined) {
            throw new Error('Required parameter locked was null or undefined when calling setMenuLock.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(locked, "boolean")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set Menus Name
     * @param menuId Menu identifier
     * @param name Name to set for this Menu
     * @param {*} [options] Override http request options.
     */
    public setMenuName (menuId: number, name: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/name'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling setMenuName.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling setMenuName.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(name, "string")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update menu
     * @param menuId Menu identifier
     * @param menu Full menu data
     * @param {*} [options] Override http request options.
     */
    public updateMenu (menuId: number, menu: MenuBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling updateMenu.');
        }

        // verify required parameter 'menu' is not null or undefined
        if (menu === null || menu === undefined) {
            throw new Error('Required parameter menu was null or undefined when calling updateMenu.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menu, "MenuBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload menu image
     * @param menuId Menu identifier
     * @param Image Menu image
     * @param {*} [options] Override http request options.
     */
    public uploadMenuImage (menuId: number, Image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/image'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling uploadMenuImage.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadMenuImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new menu from xlsx file.
     * @param appId App identifier
     * @param Menu Uploaded xlsx menu
     * @param {*} [options] Override http request options.
     */
    public uploadNewMenuForApp (appId: string, Menu: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: number;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/menus/xlsx'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling uploadNewMenuForApp.');
        }

        // verify required parameter 'Menu' is not null or undefined
        if (Menu === null || Menu === undefined) {
            throw new Error('Required parameter Menu was null or undefined when calling uploadNewMenuForApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Menu !== undefined) {
            localVarFormParams['Menu'] = Menu;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: number;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "number");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenusNutritionInfoApiApiKeys {
}

export class MenusNutritionInfoApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MenusNutritionInfoApiApiKeys, value: string) {
        (this.authentications as any)[MenusNutritionInfoApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Add or update menuitem nutrition info by menu item's publicId
     * @param menuId Menu identifier
     * @param publicId Menu item&#39;s publicId
     * @param addOrUpdateModel 
     * @param {*} [options] Override http request options.
     */
    public addOrUpdateMenuItemNutritionInfo (menuId: number, publicId: string, addOrUpdateModel: ItemNutritionInfoAddUpdateModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenuNutritionInfoHeader;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/menuItem/{publicId}/nutrition'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'publicId' + '}', encodeURIComponent(String(publicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling addOrUpdateMenuItemNutritionInfo.');
        }

        // verify required parameter 'publicId' is not null or undefined
        if (publicId === null || publicId === undefined) {
            throw new Error('Required parameter publicId was null or undefined when calling addOrUpdateMenuItemNutritionInfo.');
        }

        // verify required parameter 'addOrUpdateModel' is not null or undefined
        if (addOrUpdateModel === null || addOrUpdateModel === undefined) {
            throw new Error('Required parameter addOrUpdateModel was null or undefined when calling addOrUpdateMenuItemNutritionInfo.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(addOrUpdateModel, "ItemNutritionInfoAddUpdateModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenuNutritionInfoHeader;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenuNutritionInfoHeader");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add or update menuitem optionsetitem nutrition info its publicId
     * @param menuId Menu identifier
     * @param publicId Menu item&#39;s publicId
     * @param addOrUpdateModel 
     * @param {*} [options] Override http request options.
     */
    public addOrUpdateMenuItemOptionSetItemNutritionInfo (menuId: number, publicId: string, addOrUpdateModel: ItemNutritionInfoAddUpdateModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenuNutritionInfoHeader;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/menuItemOption/{publicId}/nutrition'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'publicId' + '}', encodeURIComponent(String(publicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling addOrUpdateMenuItemOptionSetItemNutritionInfo.');
        }

        // verify required parameter 'publicId' is not null or undefined
        if (publicId === null || publicId === undefined) {
            throw new Error('Required parameter publicId was null or undefined when calling addOrUpdateMenuItemOptionSetItemNutritionInfo.');
        }

        // verify required parameter 'addOrUpdateModel' is not null or undefined
        if (addOrUpdateModel === null || addOrUpdateModel === undefined) {
            throw new Error('Required parameter addOrUpdateModel was null or undefined when calling addOrUpdateMenuItemOptionSetItemNutritionInfo.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(addOrUpdateModel, "ItemNutritionInfoAddUpdateModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenuNutritionInfoHeader;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenuNutritionInfoHeader");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add or update menu nutrition by identifier
     * @param menuId Menu identifier
     * @param {*} [options] Override http request options.
     */
    public addOrUpdateMenuNutritionInfoByMenuId (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMenuNutritionInfoHeader;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/nutrition'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling addOrUpdateMenuNutritionInfoByMenuId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMenuNutritionInfoHeader;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMenuNutritionInfoHeader");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete menu nutrition information by menuId
     * @param menuId Menu identifier
     * @param {*} [options] Override http request options.
     */
    public deleteMenuNutritionInfoByMenuId (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/nutrition'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteMenuNutritionInfoByMenuId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get allergens
     * @param appId 
     * @param languageId 
     * @param {*} [options] Override http request options.
     */
    public getAllergens (appId: string, languageId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultAllergen;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/menus/nutrition/allergens'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getAllergens.');
        }

        if (languageId !== undefined) {
            localVarQueryParameters['languageId'] = ObjectSerializer.serialize(languageId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultAllergen;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultAllergen");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu nutrition by menuId
     * @param menuId Menu identifier
     * @param {*} [options] Override http request options.
     */
    public getMenuNutritionInfoByMenuId (menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultNutritionInfo;  }> {
        const localVarPath = this.basePath + '/api/v1.0/menus/{menuId}/nutrition'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuNutritionInfoByMenuId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultNutritionInfo;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultNutritionInfo");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenusNutritionInfoV2ApiApiKeys {
}

export class MenusNutritionInfoV2Api {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MenusNutritionInfoV2ApiApiKeys, value: string) {
        (this.authentications as any)[MenusNutritionInfoV2ApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @summary Add or update menuitem nutrition info by menu item's publicId
     * @param menuId Menu identifier
     * @param publicId Menu item&#39;s publicId
     * @param addOrUpdateModel Allergen ids
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public addOrUpdateMenuItemNutritionInfoV2 (menuId: number, publicId: string, addOrUpdateModel: ItemNutritionInfoV2AddUpdateModel, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/menus/{menuId}/menuItem/{publicId}/nutritionv2'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'publicId' + '}', encodeURIComponent(String(publicId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling addOrUpdateMenuItemNutritionInfoV2.');
        }

        // verify required parameter 'publicId' is not null or undefined
        if (publicId === null || publicId === undefined) {
            throw new Error('Required parameter publicId was null or undefined when calling addOrUpdateMenuItemNutritionInfoV2.');
        }

        // verify required parameter 'addOrUpdateModel' is not null or undefined
        if (addOrUpdateModel === null || addOrUpdateModel === undefined) {
            throw new Error('Required parameter addOrUpdateModel was null or undefined when calling addOrUpdateMenuItemNutritionInfoV2.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling addOrUpdateMenuItemNutritionInfoV2.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(addOrUpdateModel, "ItemNutritionInfoV2AddUpdateModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add or update menuitem option set item's nutrition info by its publicId
     * @param menuId Menu identifier
     * @param publicId Menu item option set item&#39;s publicId
     * @param addOrUpdateModel Allergen ids
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public addOrUpdateMenuItemOptionSetItemNutritionInfoV2 (menuId: number, publicId: string, addOrUpdateModel: ItemNutritionInfoV2AddUpdateModel, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/menus/{menuId}/menuItemOption/{publicId}/nutritionv2'
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)))
            .replace('{' + 'publicId' + '}', encodeURIComponent(String(publicId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling addOrUpdateMenuItemOptionSetItemNutritionInfoV2.');
        }

        // verify required parameter 'publicId' is not null or undefined
        if (publicId === null || publicId === undefined) {
            throw new Error('Required parameter publicId was null or undefined when calling addOrUpdateMenuItemOptionSetItemNutritionInfoV2.');
        }

        // verify required parameter 'addOrUpdateModel' is not null or undefined
        if (addOrUpdateModel === null || addOrUpdateModel === undefined) {
            throw new Error('Required parameter addOrUpdateModel was null or undefined when calling addOrUpdateMenuItemOptionSetItemNutritionInfoV2.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling addOrUpdateMenuItemOptionSetItemNutritionInfoV2.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(addOrUpdateModel, "ItemNutritionInfoV2AddUpdateModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get allergens
     * @param appId 
     * @param languageId 
     * @param {*} [options] Override http request options.
     */
    public getAllergensV2 (appId: string, languageId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultAllergen;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/menus/nutritionv2/allergens'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getAllergensV2.');
        }

        if (languageId !== undefined) {
            localVarQueryParameters['languageId'] = ObjectSerializer.serialize(languageId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultAllergen;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultAllergen");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get menu nutrition by menuId
     * @param appId 
     * @param menuId Menu identifier
     * @param languageId 
     * @param {*} [options] Override http request options.
     */
    public getMenuNutritionInfoV2ByMenuId (appId: string, menuId: number, languageId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultNutritionInfoV2;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/menus/{menuId}/nutritionv2'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getMenuNutritionInfoV2ByMenuId.');
        }

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getMenuNutritionInfoV2ByMenuId.');
        }

        if (languageId !== undefined) {
            localVarQueryParameters['languageId'] = ObjectSerializer.serialize(languageId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultNutritionInfoV2;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultNutritionInfoV2");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MetafieldDefinitionsApiApiKeys {
}

export class MetafieldDefinitionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MetafieldDefinitionsApiApiKeys, value: string) {
        (this.authentications as any)[MetafieldDefinitionsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param ownerEntity 
     * @param createMetafieldDefinition 
     * @param {*} [options] Override http request options.
     */
    public createMetafieldDefinition (appId: string, ownerEntity: 'CatalogItem' | 'CatalogGroup' | 'Menu', createMetafieldDefinition: CreateMetafieldDefinition, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMetafieldDefinition;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/metafields/definitions/{ownerEntity}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'ownerEntity' + '}', encodeURIComponent(String(ownerEntity)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createMetafieldDefinition.');
        }

        // verify required parameter 'ownerEntity' is not null or undefined
        if (ownerEntity === null || ownerEntity === undefined) {
            throw new Error('Required parameter ownerEntity was null or undefined when calling createMetafieldDefinition.');
        }

        // verify required parameter 'createMetafieldDefinition' is not null or undefined
        if (createMetafieldDefinition === null || createMetafieldDefinition === undefined) {
            throw new Error('Required parameter createMetafieldDefinition was null or undefined when calling createMetafieldDefinition.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createMetafieldDefinition, "CreateMetafieldDefinition")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMetafieldDefinition;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMetafieldDefinition");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param ownerEntity 
     * @param key 
     * @param {*} [options] Override http request options.
     */
    public getMetafieldDefinitionByKey (appId: string, ownerEntity: 'CatalogItem' | 'CatalogGroup' | 'Menu', key: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMetafieldDefinition;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/metafields/definitions/{ownerEntity}/{key}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'ownerEntity' + '}', encodeURIComponent(String(ownerEntity)))
            .replace('{' + 'key' + '}', encodeURIComponent(String(key)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getMetafieldDefinitionByKey.');
        }

        // verify required parameter 'ownerEntity' is not null or undefined
        if (ownerEntity === null || ownerEntity === undefined) {
            throw new Error('Required parameter ownerEntity was null or undefined when calling getMetafieldDefinitionByKey.');
        }

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling getMetafieldDefinitionByKey.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMetafieldDefinition;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMetafieldDefinition");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param ownerEntity 
     * @param searchTerm 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getMetafieldDefinitions (appId: string, ownerEntity: 'CatalogItem' | 'CatalogGroup' | 'Menu', searchTerm?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultMetafieldDefinition;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/metafields/definitions/{ownerEntity}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'ownerEntity' + '}', encodeURIComponent(String(ownerEntity)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getMetafieldDefinitions.');
        }

        // verify required parameter 'ownerEntity' is not null or undefined
        if (ownerEntity === null || ownerEntity === undefined) {
            throw new Error('Required parameter ownerEntity was null or undefined when calling getMetafieldDefinitions.');
        }

        if (searchTerm !== undefined) {
            localVarQueryParameters['searchTerm'] = ObjectSerializer.serialize(searchTerm, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultMetafieldDefinition;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultMetafieldDefinition");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getOwnerEntityConfigurations (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: OwnerEntityConfigurations;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/metafields/definitions'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOwnerEntityConfigurations.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: OwnerEntityConfigurations;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OwnerEntityConfigurations");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param ownerEntity 
     * @param searchTerm 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getOwnerEntityRecommendations (appId: string, ownerEntity: 'CatalogItem' | 'CatalogGroup' | 'Menu', searchTerm?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultMetafieldDefinitionRecommendation;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/metafields/definitions/recommendations/{ownerEntity}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'ownerEntity' + '}', encodeURIComponent(String(ownerEntity)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOwnerEntityRecommendations.');
        }

        // verify required parameter 'ownerEntity' is not null or undefined
        if (ownerEntity === null || ownerEntity === undefined) {
            throw new Error('Required parameter ownerEntity was null or undefined when calling getOwnerEntityRecommendations.');
        }

        if (searchTerm !== undefined) {
            localVarQueryParameters['searchTerm'] = ObjectSerializer.serialize(searchTerm, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultMetafieldDefinitionRecommendation;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultMetafieldDefinitionRecommendation");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param ownerEntity 
     * @param key 
     * @param updateMetafieldDefinition 
     * @param {*} [options] Override http request options.
     */
    public updateMetafieldDefinition (appId: string, ownerEntity: 'CatalogItem' | 'CatalogGroup' | 'Menu', key: string, updateMetafieldDefinition: UpdateMetafieldDefinition, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMetafieldDefinition;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/metafields/definitions/{ownerEntity}/{key}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'ownerEntity' + '}', encodeURIComponent(String(ownerEntity)))
            .replace('{' + 'key' + '}', encodeURIComponent(String(key)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateMetafieldDefinition.');
        }

        // verify required parameter 'ownerEntity' is not null or undefined
        if (ownerEntity === null || ownerEntity === undefined) {
            throw new Error('Required parameter ownerEntity was null or undefined when calling updateMetafieldDefinition.');
        }

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling updateMetafieldDefinition.');
        }

        // verify required parameter 'updateMetafieldDefinition' is not null or undefined
        if (updateMetafieldDefinition === null || updateMetafieldDefinition === undefined) {
            throw new Error('Required parameter updateMetafieldDefinition was null or undefined when calling updateMetafieldDefinition.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateMetafieldDefinition, "UpdateMetafieldDefinition")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMetafieldDefinition;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMetafieldDefinition");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MobileAppsApiApiKeys {
}

export class MobileAppsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MobileAppsApiApiKeys, value: string) {
        (this.authentications as any)[MobileAppsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getAppConfigSalesChannel (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultAppConfigSalesChannel;  }> {
        const localVarPath = this.basePath + '/api/v1.0/mobileapps/{appId}/saleschannel/details'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getAppConfigSalesChannel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultAppConfigSalesChannel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultAppConfigSalesChannel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param platformTypes 
     * @param {*} [options] Override http request options.
     */
    public getStatistics (appId: string, platformTypes: Array<'None' | 'Android' | 'IOS'>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMobileAppsStatistics;  }> {
        const localVarPath = this.basePath + '/api/v1.0/mobileapps/{appId}/statistics'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getStatistics.');
        }

        // verify required parameter 'platformTypes' is not null or undefined
        if (platformTypes === null || platformTypes === undefined) {
            throw new Error('Required parameter platformTypes was null or undefined when calling getStatistics.');
        }

        if (platformTypes !== undefined) {
            localVarQueryParameters['platformTypes'] = ObjectSerializer.serialize(platformTypes, "Array<'None' | 'Android' | 'IOS'>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultMobileAppsStatistics;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultMobileAppsStatistics");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getSubmissionDetails (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMobileAppsSubmissionDetails;  }> {
        const localVarPath = this.basePath + '/api/v1.0/mobileapps/{appId}/submission/details'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getSubmissionDetails.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMobileAppsSubmissionDetails;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMobileAppsSubmissionDetails");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param submissionId 
     * @param {*} [options] Override http request options.
     */
    public getSubmissionStatus (appId: string, submissionId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMobileAppsSubmissionStatus;  }> {
        const localVarPath = this.basePath + '/api/v1.0/mobileapps/{appId}/submission/{submissionId}/status'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'submissionId' + '}', encodeURIComponent(String(submissionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getSubmissionStatus.');
        }

        // verify required parameter 'submissionId' is not null or undefined
        if (submissionId === null || submissionId === undefined) {
            throw new Error('Required parameter submissionId was null or undefined when calling getSubmissionStatus.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMobileAppsSubmissionStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMobileAppsSubmissionStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param submissionId 
     * @param platformType 
     * @param {*} [options] Override http request options.
     */
    public publish (appId: string, submissionId: number, platformType?: 'None' | 'Android' | 'IOS', options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultRestApiIntegerResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/mobileapps/{appId}/submission/{submissionId}/publish'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'submissionId' + '}', encodeURIComponent(String(submissionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling publish.');
        }

        // verify required parameter 'submissionId' is not null or undefined
        if (submissionId === null || submissionId === undefined) {
            throw new Error('Required parameter submissionId was null or undefined when calling publish.');
        }

        if (platformType !== undefined) {
            localVarQueryParameters['platformType'] = ObjectSerializer.serialize(platformType, "'None' | 'Android' | 'IOS'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultRestApiIntegerResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultRestApiIntegerResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param mobileAppsSubmission 
     * @param {*} [options] Override http request options.
     */
    public resubmission (appId: string, mobileAppsSubmission: MobileAppsSubmission, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMobileAppsSubmission;  }> {
        const localVarPath = this.basePath + '/api/v1.0/mobileapps/{appId}/resubmission'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling resubmission.');
        }

        // verify required parameter 'mobileAppsSubmission' is not null or undefined
        if (mobileAppsSubmission === null || mobileAppsSubmission === undefined) {
            throw new Error('Required parameter mobileAppsSubmission was null or undefined when calling resubmission.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(mobileAppsSubmission, "MobileAppsSubmission")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMobileAppsSubmission;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMobileAppsSubmission");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param mobileAppsSubmission 
     * @param {*} [options] Override http request options.
     */
    public submission (appId: string, mobileAppsSubmission: MobileAppsSubmission, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMobileAppsSubmission;  }> {
        const localVarPath = this.basePath + '/api/v1.0/mobileapps/{appId}/submission'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling submission.');
        }

        // verify required parameter 'mobileAppsSubmission' is not null or undefined
        if (mobileAppsSubmission === null || mobileAppsSubmission === undefined) {
            throw new Error('Required parameter mobileAppsSubmission was null or undefined when calling submission.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(mobileAppsSubmission, "MobileAppsSubmission")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMobileAppsSubmission;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMobileAppsSubmission");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param submissionId 
     * @param platformType 
     * @param {*} [options] Override http request options.
     */
    public unpublish (appId: string, submissionId: number, platformType?: 'None' | 'Android' | 'IOS', options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiIntegerResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/mobileapps/{appId}/submission/{submissionId}/unpublish'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'submissionId' + '}', encodeURIComponent(String(submissionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling unpublish.');
        }

        // verify required parameter 'submissionId' is not null or undefined
        if (submissionId === null || submissionId === undefined) {
            throw new Error('Required parameter submissionId was null or undefined when calling unpublish.');
        }

        if (platformType !== undefined) {
            localVarQueryParameters['platformType'] = ObjectSerializer.serialize(platformType, "'None' | 'Android' | 'IOS'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiIntegerResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiIntegerResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param appConfigSalesChannel 
     * @param {*} [options] Override http request options.
     */
    public updateAppConfigSalesChannel (appId: string, appConfigSalesChannel: AppConfigSalesChannel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultAppConfigSalesChannel;  }> {
        const localVarPath = this.basePath + '/api/v1.0/mobileapps/{appId}/saleschannel'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateAppConfigSalesChannel.');
        }

        // verify required parameter 'appConfigSalesChannel' is not null or undefined
        if (appConfigSalesChannel === null || appConfigSalesChannel === undefined) {
            throw new Error('Required parameter appConfigSalesChannel was null or undefined when calling updateAppConfigSalesChannel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(appConfigSalesChannel, "AppConfigSalesChannel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultAppConfigSalesChannel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultAppConfigSalesChannel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param submissionId 
     * @param updateSubmissionStatus 
     * @param {*} [options] Override http request options.
     */
    public updateSubmissionStatus (appId: string, submissionId: number, updateSubmissionStatus: UpdateMobileAppsSubmissionStatus, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultUpdateMobileAppsSubmissionStatus;  }> {
        const localVarPath = this.basePath + '/api/v1.0/mobileapps/{appId}/submission/{submissionId}/status'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'submissionId' + '}', encodeURIComponent(String(submissionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateSubmissionStatus.');
        }

        // verify required parameter 'submissionId' is not null or undefined
        if (submissionId === null || submissionId === undefined) {
            throw new Error('Required parameter submissionId was null or undefined when calling updateSubmissionStatus.');
        }

        // verify required parameter 'updateSubmissionStatus' is not null or undefined
        if (updateSubmissionStatus === null || updateSubmissionStatus === undefined) {
            throw new Error('Required parameter updateSubmissionStatus was null or undefined when calling updateSubmissionStatus.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateSubmissionStatus, "UpdateMobileAppsSubmissionStatus")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultUpdateMobileAppsSubmissionStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultUpdateMobileAppsSubmissionStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param Image Mobile Apps image
     * @param {*} [options] Override http request options.
     */
    public uploadImage (appId: string, Image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultMobileAppsImage;  }> {
        const localVarPath = this.basePath + '/api/v1.0/mobileapps/{appId}/submission/image'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling uploadImage.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultMobileAppsImage;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultMobileAppsImage");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OAuthClientsApiApiKeys {
}

export class OAuthClientsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OAuthClientsApiApiKeys, value: string) {
        (this.authentications as any)[OAuthClientsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param oauthAppId 
     * @param uri 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public addRedirectUri (oauthAppId: string, uri: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultOauthClientRedirectUri;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}/redirecturis'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling addRedirectUri.');
        }

        // verify required parameter 'uri' is not null or undefined
        if (uri === null || uri === undefined) {
            throw new Error('Required parameter uri was null or undefined when calling addRedirectUri.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling addRedirectUri.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(uri, "string")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultOauthClientRedirectUri;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultOauthClientRedirectUri");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param oAuthApp 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public createOAuthApp (oAuthApp: OAuthApp, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oAuthApp' is not null or undefined
        if (oAuthApp === null || oAuthApp === undefined) {
            throw new Error('Required parameter oAuthApp was null or undefined when calling createOAuthApp.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createOAuthApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(oAuthApp, "OAuthApp")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param oauthAppId 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public deleteOAuthApp (oauthAppId: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling deleteOAuthApp.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteOAuthApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param oauthAppName 
     * @param {*} [options] Override http request options.
     */
    public getOAuthApps (appId: string, oauthAppName?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultOAuthApp;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOAuthApps.');
        }

        if (oauthAppName !== undefined) {
            localVarQueryParameters['oauthAppName'] = ObjectSerializer.serialize(oauthAppName, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultOAuthApp;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultOAuthApp");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param oauthAppId 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getOAuthClientByClientId (oauthAppId: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultOAuthApp;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getOAuthClientByClientId.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOAuthClientByClientId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultOAuthApp;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultOAuthApp");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param oauthAppId 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getOAuthClientSecret (oauthAppId: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}/secret'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getOAuthClientSecret.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOAuthClientSecret.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param oauthAppId 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getOauthAccessToken (oauthAppId: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}/accesstoken'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getOauthAccessToken.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOauthAccessToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param oauthAppId 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getRedirectUris (oauthAppId: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultOauthClientRedirectUri;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}/redirecturis'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getRedirectUris.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getRedirectUris.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultOauthClientRedirectUri;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultOauthClientRedirectUri");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public oAuthClientsGetApplications (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/appnames'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling oAuthClientsGetApplications.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param oauthAppId 
     * @param uriId 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public removeRedirectUri (oauthAppId: string, uriId: number, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}/redirecturis/{uriId}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'uriId' + '}', encodeURIComponent(String(uriId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling removeRedirectUri.');
        }

        // verify required parameter 'uriId' is not null or undefined
        if (uriId === null || uriId === undefined) {
            throw new Error('Required parameter uriId was null or undefined when calling removeRedirectUri.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling removeRedirectUri.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param oauthAppId 
     * @param oAuthApp 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public updateOAuthApp (oauthAppId: string, oAuthApp: OAuthApp, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/oauthclients/{oauthAppId}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling updateOAuthApp.');
        }

        // verify required parameter 'oAuthApp' is not null or undefined
        if (oAuthApp === null || oAuthApp === undefined) {
            throw new Error('Required parameter oAuthApp was null or undefined when calling updateOAuthApp.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateOAuthApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(oAuthApp, "OAuthApp")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OnboardingApiApiKeys {
}

export class OnboardingApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OnboardingApiApiKeys, value: string) {
        (this.authentications as any)[OnboardingApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public onboardingGetOnboardingConfig (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/clients/{appId}/onboarding/config'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling onboardingGetOnboardingConfig.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public onboardingGetOnboardingConfigs (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/clients/{appId}/onboarding/configs'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling onboardingGetOnboardingConfigs.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param storeId 
     * @param milestoneId 
     * @param {*} [options] Override http request options.
     */
    public onboardingGetOnboardingItems (appId: string, storeId: number, milestoneId?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/clients/{appId}/onboarding/stores/{storeId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling onboardingGetOnboardingItems.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling onboardingGetOnboardingItems.');
        }

        if (milestoneId !== undefined) {
            localVarQueryParameters['milestoneId'] = ObjectSerializer.serialize(milestoneId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param storeId 
     * @param milestoneId 
     * @param {*} [options] Override http request options.
     */
    public onboardingGetOnboardingItemsV2 (appId: string, storeId?: number, milestoneId?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/clients/{appId}/onboarding/stores'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling onboardingGetOnboardingItemsV2.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        if (milestoneId !== undefined) {
            localVarQueryParameters['milestoneId'] = ObjectSerializer.serialize(milestoneId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param configUpdate 
     * @param {*} [options] Override http request options.
     */
    public onboardingUpdateOnboardingConfig (appId: string, configUpdate: OnboardingConfigUpdate, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/clients/{appId}/onboarding/config'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling onboardingUpdateOnboardingConfig.');
        }

        // verify required parameter 'configUpdate' is not null or undefined
        if (configUpdate === null || configUpdate === undefined) {
            throw new Error('Required parameter configUpdate was null or undefined when calling onboardingUpdateOnboardingConfig.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(configUpdate, "OnboardingConfigUpdate")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param configId 
     * @param configUpdate 
     * @param {*} [options] Override http request options.
     */
    public onboardingUpdateOnboardingConfigById (appId: string, configId: number, configUpdate: OnboardingConfigUpdate, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/clients/{appId}/onboarding/config/{configId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'configId' + '}', encodeURIComponent(String(configId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling onboardingUpdateOnboardingConfigById.');
        }

        // verify required parameter 'configId' is not null or undefined
        if (configId === null || configId === undefined) {
            throw new Error('Required parameter configId was null or undefined when calling onboardingUpdateOnboardingConfigById.');
        }

        // verify required parameter 'configUpdate' is not null or undefined
        if (configUpdate === null || configUpdate === undefined) {
            throw new Error('Required parameter configUpdate was null or undefined when calling onboardingUpdateOnboardingConfigById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(configUpdate, "OnboardingConfigUpdate")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param storeId 
     * @param onboardingItemId 
     * @param itemUpdate 
     * @param {*} [options] Override http request options.
     */
    public onboardingUpdateOnboardingItem (appId: string, storeId: number, onboardingItemId: number, itemUpdate: OnboardingItemUpdate, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/clients/{appId}/onboarding/stores/{storeId}/items/{onboardingItemId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'onboardingItemId' + '}', encodeURIComponent(String(onboardingItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling onboardingUpdateOnboardingItem.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling onboardingUpdateOnboardingItem.');
        }

        // verify required parameter 'onboardingItemId' is not null or undefined
        if (onboardingItemId === null || onboardingItemId === undefined) {
            throw new Error('Required parameter onboardingItemId was null or undefined when calling onboardingUpdateOnboardingItem.');
        }

        // verify required parameter 'itemUpdate' is not null or undefined
        if (itemUpdate === null || itemUpdate === undefined) {
            throw new Error('Required parameter itemUpdate was null or undefined when calling onboardingUpdateOnboardingItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(itemUpdate, "OnboardingItemUpdate")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param onboardingItemId 
     * @param itemUpdate 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public onboardingUpdateOnboardingItemV2 (appId: string, onboardingItemId: number, itemUpdate: OnboardingItemUpdate, storeId?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/clients/{appId}/onboarding/stores/items/{onboardingItemId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'onboardingItemId' + '}', encodeURIComponent(String(onboardingItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling onboardingUpdateOnboardingItemV2.');
        }

        // verify required parameter 'onboardingItemId' is not null or undefined
        if (onboardingItemId === null || onboardingItemId === undefined) {
            throw new Error('Required parameter onboardingItemId was null or undefined when calling onboardingUpdateOnboardingItemV2.');
        }

        // verify required parameter 'itemUpdate' is not null or undefined
        if (itemUpdate === null || itemUpdate === undefined) {
            throw new Error('Required parameter itemUpdate was null or undefined when calling onboardingUpdateOnboardingItemV2.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(itemUpdate, "OnboardingItemUpdate")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OrderBatchesApiApiKeys {
}

export class OrderBatchesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OrderBatchesApiApiKeys, value: string) {
        (this.authentications as any)[OrderBatchesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param storeIds 
     * @param createdFrom 
     * @param createdTo 
     * @param {*} [options] Override http request options.
     */
    public getAllOrderBatches (appId: string, storeIds?: Array<number>, createdFrom?: Date, createdTo?: Date, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultOrderBatch;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/order-batches'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getAllOrderBatches.');
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        if (createdFrom !== undefined) {
            localVarQueryParameters['createdFrom'] = ObjectSerializer.serialize(createdFrom, "Date");
        }

        if (createdTo !== undefined) {
            localVarQueryParameters['createdTo'] = ObjectSerializer.serialize(createdTo, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultOrderBatch;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultOrderBatch");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param orderBatchId 
     * @param {*} [options] Override http request options.
     */
    public getOrderBatch (appId: string, orderBatchId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultOrderBatch;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/order-batches/{orderBatchId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'orderBatchId' + '}', encodeURIComponent(String(orderBatchId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOrderBatch.');
        }

        // verify required parameter 'orderBatchId' is not null or undefined
        if (orderBatchId === null || orderBatchId === undefined) {
            throw new Error('Required parameter orderBatchId was null or undefined when calling getOrderBatch.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultOrderBatch;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultOrderBatch");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OrderBatchingConfigurationApiApiKeys {
}

export class OrderBatchingConfigurationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OrderBatchingConfigurationApiApiKeys, value: string) {
        (this.authentications as any)[OrderBatchingConfigurationApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public get (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultOrderBatchingConfiguration;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/order-batching-configuration'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling get.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultOrderBatchingConfiguration;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultOrderBatchingConfiguration");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param setOrderBatchingConfiguration 
     * @param {*} [options] Override http request options.
     */
    public post (storeId: number, setOrderBatchingConfiguration: SetOrderBatchingConfiguration, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/order-batching-configuration'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling post.');
        }

        // verify required parameter 'setOrderBatchingConfiguration' is not null or undefined
        if (setOrderBatchingConfiguration === null || setOrderBatchingConfiguration === undefined) {
            throw new Error('Required parameter setOrderBatchingConfiguration was null or undefined when calling post.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(setOrderBatchingConfiguration, "SetOrderBatchingConfiguration")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OrderIngestApiApiKeys {
}

export class OrderIngestApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OrderIngestApiApiKeys, value: string) {
        (this.authentications as any)[OrderIngestApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param order 
     * @param appNameId 
     * @param {*} [options] Override http request options.
     */
    public orderIngestSubmitNewOrder (order: OrderIngestSubmitOrderRequest, appNameId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultOrderIngestSubmitOrderResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appNameId}/order-ingest/submit'
            .replace('{' + 'appNameId' + '}', encodeURIComponent(String(appNameId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'order' is not null or undefined
        if (order === null || order === undefined) {
            throw new Error('Required parameter order was null or undefined when calling orderIngestSubmitNewOrder.');
        }

        // verify required parameter 'appNameId' is not null or undefined
        if (appNameId === null || appNameId === undefined) {
            throw new Error('Required parameter appNameId was null or undefined when calling orderIngestSubmitNewOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(order, "OrderIngestSubmitOrderRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultOrderIngestSubmitOrderResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultOrderIngestSubmitOrderResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OrdersApiApiKeys {
}

export class OrdersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OrdersApiApiKeys, value: string) {
        (this.authentications as any)[OrdersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param id 
     * @param acceptObject 
     * @param {*} [options] Override http request options.
     */
    public acceptOrder (id: number, acceptObject: Accept, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{id}/accept'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling acceptOrder.');
        }

        // verify required parameter 'acceptObject' is not null or undefined
        if (acceptObject === null || acceptObject === undefined) {
            throw new Error('Required parameter acceptObject was null or undefined when calling acceptOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(acceptObject, "Accept")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public dispatchOrder (id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{id}/dispatch'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling dispatchOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param orderId 
     * @param {*} [options] Override http request options.
     */
    public getDeliveryInformation (orderId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultOrderDeliveryInformation;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{orderId}/deliveryinfo'
            .replace('{' + 'orderId' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getDeliveryInformation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultOrderDeliveryInformation;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultOrderDeliveryInformation");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param orderId 
     * @param {*} [options] Override http request options.
     */
    public getFulfillmentState (orderId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultOrderFulfillmentStatus;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{orderId}/fulfillment/state'
            .replace('{' + 'orderId' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getFulfillmentState.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultOrderFulfillmentStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultOrderFulfillmentStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param orderId 
     * @param {*} [options] Override http request options.
     */
    public getFulfillmentStatusWithDetailsAndActions (orderId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultOrderFulfillmentStatusWithConfigurationActions;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{orderId}/fulfillment/state/details'
            .replace('{' + 'orderId' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getFulfillmentStatusWithDetailsAndActions.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultOrderFulfillmentStatusWithConfigurationActions;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultOrderFulfillmentStatusWithConfigurationActions");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public getOrderById (id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultOrder;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getOrderById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultOrder;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultOrder");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param physicalRestaurantId 
     * @param state 
     * @param from 
     * @param to 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getOrders (physicalRestaurantId?: Array<number>, state?: Array<'Created' | 'PlacedCanBeCancelled' | 'ReadyToProcess' | 'AcceptedByRestaurant' | 'Dispatched' | 'Delivered' | 'Cancelled' | 'ManualReview' | 'RejectedByStore' | 'RejectedByFlipdish' | 'RejectedAutomatically' | 'RejectedAfterBeingAccepted' | 'AcceptedAndRefunded'>, from?: Date, to?: Date, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultOrder;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (physicalRestaurantId !== undefined) {
            localVarQueryParameters['physicalRestaurantId'] = ObjectSerializer.serialize(physicalRestaurantId, "Array<number>");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "Array<'Created' | 'PlacedCanBeCancelled' | 'ReadyToProcess' | 'AcceptedByRestaurant' | 'Dispatched' | 'Delivered' | 'Cancelled' | 'ManualReview' | 'RejectedByStore' | 'RejectedByFlipdish' | 'RejectedAutomatically' | 'RejectedAfterBeingAccepted' | 'AcceptedAndRefunded'>");
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "Date");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "Date");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultOrder;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultOrder");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param searchQuery 
     * @param physicalRestaurantId 
     * @param state 
     * @param page 
     * @param limit 
     * @param orderByRequestedForTime 
     * @param channels 
     * @param orderIds 
     * @param from 
     * @param to 
     * @param logSql 
     * @param {*} [options] Override http request options.
     */
    public getOrdersSummary (appId: string, searchQuery?: string, physicalRestaurantId?: Array<number>, state?: Array<'Created' | 'PlacedCanBeCancelled' | 'ReadyToProcess' | 'AcceptedByRestaurant' | 'Dispatched' | 'Delivered' | 'Cancelled' | 'ManualReview' | 'RejectedByStore' | 'RejectedByFlipdish' | 'RejectedAutomatically' | 'RejectedAfterBeingAccepted' | 'AcceptedAndRefunded'>, page?: number, limit?: number, orderByRequestedForTime?: boolean, channels?: Array<'Unknown' | 'Ios' | 'Android' | 'Web' | 'Kiosk' | 'Pos' | 'TelephoneCall' | 'Sms' | 'PwaAndroid' | 'PwaIos' | 'Google' | 'Photon'>, orderIds?: Array<number>, from?: Date, to?: Date, logSql?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultOrderSummary;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/orders/summaries'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOrdersSummary.');
        }

        if (searchQuery !== undefined) {
            localVarQueryParameters['searchQuery'] = ObjectSerializer.serialize(searchQuery, "string");
        }

        if (physicalRestaurantId !== undefined) {
            localVarQueryParameters['physicalRestaurantId'] = ObjectSerializer.serialize(physicalRestaurantId, "Array<number>");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "Array<'Created' | 'PlacedCanBeCancelled' | 'ReadyToProcess' | 'AcceptedByRestaurant' | 'Dispatched' | 'Delivered' | 'Cancelled' | 'ManualReview' | 'RejectedByStore' | 'RejectedByFlipdish' | 'RejectedAutomatically' | 'RejectedAfterBeingAccepted' | 'AcceptedAndRefunded'>");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (orderByRequestedForTime !== undefined) {
            localVarQueryParameters['orderByRequestedForTime'] = ObjectSerializer.serialize(orderByRequestedForTime, "boolean");
        }

        if (channels !== undefined) {
            localVarQueryParameters['channels'] = ObjectSerializer.serialize(channels, "Array<'Unknown' | 'Ios' | 'Android' | 'Web' | 'Kiosk' | 'Pos' | 'TelephoneCall' | 'Sms' | 'PwaAndroid' | 'PwaIos' | 'Google' | 'Photon'>");
        }

        if (orderIds !== undefined) {
            localVarQueryParameters['orderIds'] = ObjectSerializer.serialize(orderIds, "Array<number>");
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "Date");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "Date");
        }

        if (logSql !== undefined) {
            localVarQueryParameters['logSql'] = ObjectSerializer.serialize(logSql, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultOrderSummary;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultOrderSummary");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param searchQuery 
     * @param physicalRestaurantId 
     * @param state 
     * @param page 
     * @param limit 
     * @param orderByRequestedForTime 
     * @param channels 
     * @param orderIds 
     * @param from 
     * @param to 
     * @param logSql 
     * @param {*} [options] Override http request options.
     */
    public getOrdersSummaryNew (appId: string, searchQuery?: string, physicalRestaurantId?: Array<number>, state?: Array<'Created' | 'PlacedCanBeCancelled' | 'ReadyToProcess' | 'AcceptedByRestaurant' | 'Dispatched' | 'Delivered' | 'Cancelled' | 'ManualReview' | 'RejectedByStore' | 'RejectedByFlipdish' | 'RejectedAutomatically' | 'RejectedAfterBeingAccepted' | 'AcceptedAndRefunded'>, page?: number, limit?: number, orderByRequestedForTime?: boolean, channels?: Array<'Unknown' | 'Ios' | 'Android' | 'Web' | 'Kiosk' | 'Pos' | 'TelephoneCall' | 'Sms' | 'PwaAndroid' | 'PwaIos' | 'Google' | 'Photon'>, orderIds?: Array<number>, from?: Date, to?: Date, logSql?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultOrderSummary;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/orders/summariesNew'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getOrdersSummaryNew.');
        }

        if (searchQuery !== undefined) {
            localVarQueryParameters['searchQuery'] = ObjectSerializer.serialize(searchQuery, "string");
        }

        if (physicalRestaurantId !== undefined) {
            localVarQueryParameters['physicalRestaurantId'] = ObjectSerializer.serialize(physicalRestaurantId, "Array<number>");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "Array<'Created' | 'PlacedCanBeCancelled' | 'ReadyToProcess' | 'AcceptedByRestaurant' | 'Dispatched' | 'Delivered' | 'Cancelled' | 'ManualReview' | 'RejectedByStore' | 'RejectedByFlipdish' | 'RejectedAutomatically' | 'RejectedAfterBeingAccepted' | 'AcceptedAndRefunded'>");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (orderByRequestedForTime !== undefined) {
            localVarQueryParameters['orderByRequestedForTime'] = ObjectSerializer.serialize(orderByRequestedForTime, "boolean");
        }

        if (channels !== undefined) {
            localVarQueryParameters['channels'] = ObjectSerializer.serialize(channels, "Array<'Unknown' | 'Ios' | 'Android' | 'Web' | 'Kiosk' | 'Pos' | 'TelephoneCall' | 'Sms' | 'PwaAndroid' | 'PwaIos' | 'Google' | 'Photon'>");
        }

        if (orderIds !== undefined) {
            localVarQueryParameters['orderIds'] = ObjectSerializer.serialize(orderIds, "Array<number>");
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "Date");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "Date");
        }

        if (logSql !== undefined) {
            localVarQueryParameters['logSql'] = ObjectSerializer.serialize(logSql, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultOrderSummary;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultOrderSummary");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public getReadyToProcess (appId: string, storeId?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: OrderList;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/orders/ready_to_process'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getReadyToProcess.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: OrderList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OrderList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id 
     * @param refundObject 
     * @param {*} [options] Override http request options.
     */
    public refundOrder (id: number, refundObject: Refund, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{id}/refund'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling refundOrder.');
        }

        // verify required parameter 'refundObject' is not null or undefined
        if (refundObject === null || refundObject === undefined) {
            throw new Error('Required parameter refundObject was null or undefined when calling refundOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(refundObject, "Refund")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id 
     * @param rejectObject 
     * @param {*} [options] Override http request options.
     */
    public rejectOrder (id: number, rejectObject: Reject, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{id}/reject'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling rejectOrder.');
        }

        // verify required parameter 'rejectObject' is not null or undefined
        if (rejectObject === null || rejectObject === undefined) {
            throw new Error('Required parameter rejectObject was null or undefined when calling rejectOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(rejectObject, "Reject")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param orderIds 
     * @param {*} [options] Override http request options.
     */
    public searchFulfillmentStatuses (appId: string, orderIds: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultOrderFulfillmentStatus;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/orders/fulfillmentstatuses'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling searchFulfillmentStatuses.');
        }

        // verify required parameter 'orderIds' is not null or undefined
        if (orderIds === null || orderIds === undefined) {
            throw new Error('Required parameter orderIds was null or undefined when calling searchFulfillmentStatuses.');
        }

        if (orderIds !== undefined) {
            localVarQueryParameters['orderIds'] = ObjectSerializer.serialize(orderIds, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultOrderFulfillmentStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultOrderFulfillmentStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param orderId 
     * @param deliveryInformation 
     * @param {*} [options] Override http request options.
     */
    public updateDeliveryInformation (orderId: number, deliveryInformation: OrderDeliveryInformationBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{orderId}/deliveryinfo'
            .replace('{' + 'orderId' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling updateDeliveryInformation.');
        }

        // verify required parameter 'deliveryInformation' is not null or undefined
        if (deliveryInformation === null || deliveryInformation === undefined) {
            throw new Error('Required parameter deliveryInformation was null or undefined when calling updateDeliveryInformation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(deliveryInformation, "OrderDeliveryInformationBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param orderId 
     * @param fulfillmentStatusRequest 
     * @param {*} [options] Override http request options.
     */
    public updateFulfillmentState (orderId: number, fulfillmentStatusRequest: OrderFulfillmentStatusUpdate, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/orders/{orderId}/fulfillment/state'
            .replace('{' + 'orderId' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling updateFulfillmentState.');
        }

        // verify required parameter 'fulfillmentStatusRequest' is not null or undefined
        if (fulfillmentStatusRequest === null || fulfillmentStatusRequest === undefined) {
            throw new Error('Required parameter fulfillmentStatusRequest was null or undefined when calling updateFulfillmentState.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(fulfillmentStatusRequest, "OrderFulfillmentStatusUpdate")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PaymentIntentsApiApiKeys {
}

export class PaymentIntentsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PaymentIntentsApiApiKeys, value: string) {
        (this.authentications as any)[PaymentIntentsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param paymentIntentId 
     * @param {*} [options] Override http request options.
     */
    public getPaymentIntent (paymentIntentId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultPaymentIntent;  }> {
        const localVarPath = this.basePath + '/api/v1.0/payment_intents/{paymentIntentId}'
            .replace('{' + 'paymentIntentId' + '}', encodeURIComponent(String(paymentIntentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'paymentIntentId' is not null or undefined
        if (paymentIntentId === null || paymentIntentId === undefined) {
            throw new Error('Required parameter paymentIntentId was null or undefined when calling getPaymentIntent.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultPaymentIntent;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultPaymentIntent");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PaymentsApiApiKeys {
}

export class PaymentsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PaymentsApiApiKeys, value: string) {
        (this.authentications as any)[PaymentsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param orderId 
     * @param {*} [options] Override http request options.
     */
    public getOrderPaymentInformation (orderId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultOrderPaymentInformation;  }> {
        const localVarPath = this.basePath + '/api/v1.0/payments/payment/{orderId}/refundable'
            .replace('{' + 'orderId' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getOrderPaymentInformation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultOrderPaymentInformation;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultOrderPaymentInformation");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PayoutReportsApiApiKeys {
}

export class PayoutReportsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PayoutReportsApiApiKeys, value: string) {
        (this.authentications as any)[PayoutReportsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param storeIds 
     * @param {*} [options] Override http request options.
     */
    public getPayoutReport3Details (appId: string, bankAccountId: number, payoutId: number, storeIds?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultPayoutReport3Details;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/reporting/reports/payouts3/{bankAccountId}/{payoutId}/details'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'payoutId' + '}', encodeURIComponent(String(payoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPayoutReport3Details.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling getPayoutReport3Details.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling getPayoutReport3Details.');
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultPayoutReport3Details;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultPayoutReport3Details");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param storeIds 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getPayoutReport3Orders (appId: string, bankAccountId: number, payoutId: number, storeIds?: Array<number>, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayoutReport3PayoutOrder;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/reporting/reports/payouts3/{bankAccountId}/{payoutId}/orders'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'payoutId' + '}', encodeURIComponent(String(payoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPayoutReport3Orders.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling getPayoutReport3Orders.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling getPayoutReport3Orders.');
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayoutReport3PayoutOrder;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultPayoutReport3PayoutOrder");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param {*} [options] Override http request options.
     */
    public getPayoutReport3Overview (appId: string, bankAccountId: number, payoutId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultPayoutReport3Overview;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/reporting/reports/payouts3/{bankAccountId}/{payoutId}/overview'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'payoutId' + '}', encodeURIComponent(String(payoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPayoutReport3Overview.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling getPayoutReport3Overview.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling getPayoutReport3Overview.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultPayoutReport3Overview;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultPayoutReport3Overview");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param stores 
     * @param {*} [options] Override http request options.
     */
    public payoutReport3ExportPayoutChargebacks (appId: string, bankAccountId: number, payoutId: number, stores?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultFileCreationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/reporting/reports/payouts3/{bankAccountId}/{payoutId}/export/chargebacks'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'payoutId' + '}', encodeURIComponent(String(payoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling payoutReport3ExportPayoutChargebacks.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling payoutReport3ExportPayoutChargebacks.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling payoutReport3ExportPayoutChargebacks.');
        }

        if (stores !== undefined) {
            localVarQueryParameters['stores'] = ObjectSerializer.serialize(stores, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultFileCreationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultFileCreationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param stores 
     * @param {*} [options] Override http request options.
     */
    public payoutReport3ExportPayoutLedgerEntries (appId: string, bankAccountId: number, payoutId: number, stores?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultFileCreationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/reporting/reports/payouts3/{bankAccountId}/{payoutId}/export/ledgerentries'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'payoutId' + '}', encodeURIComponent(String(payoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling payoutReport3ExportPayoutLedgerEntries.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling payoutReport3ExportPayoutLedgerEntries.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling payoutReport3ExportPayoutLedgerEntries.');
        }

        if (stores !== undefined) {
            localVarQueryParameters['stores'] = ObjectSerializer.serialize(stores, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultFileCreationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultFileCreationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param stores 
     * @param {*} [options] Override http request options.
     */
    public payoutReport3ExportPayoutOrders (appId: string, bankAccountId: number, payoutId: number, stores?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultFileCreationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/reporting/reports/payouts3/{bankAccountId}/{payoutId}/export/orders'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'payoutId' + '}', encodeURIComponent(String(payoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling payoutReport3ExportPayoutOrders.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling payoutReport3ExportPayoutOrders.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling payoutReport3ExportPayoutOrders.');
        }

        if (stores !== undefined) {
            localVarQueryParameters['stores'] = ObjectSerializer.serialize(stores, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultFileCreationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultFileCreationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param stores 
     * @param {*} [options] Override http request options.
     */
    public payoutReport3ExportPayoutPosSales (appId: string, bankAccountId: number, payoutId: number, stores?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultFileCreationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/reporting/reports/payouts3/{bankAccountId}/{payoutId}/export/possales'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'payoutId' + '}', encodeURIComponent(String(payoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling payoutReport3ExportPayoutPosSales.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling payoutReport3ExportPayoutPosSales.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling payoutReport3ExportPayoutPosSales.');
        }

        if (stores !== undefined) {
            localVarQueryParameters['stores'] = ObjectSerializer.serialize(stores, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultFileCreationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultFileCreationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param stores 
     * @param {*} [options] Override http request options.
     */
    public payoutReport3ExportPayoutRefundedRejected (appId: string, bankAccountId: number, payoutId: number, stores?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultFileCreationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/reporting/reports/payouts3/{bankAccountId}/{payoutId}/export/refundedrejected'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'payoutId' + '}', encodeURIComponent(String(payoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling payoutReport3ExportPayoutRefundedRejected.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling payoutReport3ExportPayoutRefundedRejected.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling payoutReport3ExportPayoutRefundedRejected.');
        }

        if (stores !== undefined) {
            localVarQueryParameters['stores'] = ObjectSerializer.serialize(stores, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultFileCreationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultFileCreationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PayoutsApiApiKeys {
}

export class PayoutsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PayoutsApiApiKeys, value: string) {
        (this.authentications as any)[PayoutsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param {*} [options] Override http request options.
     */
    public getPayout (appId: string, bankAccountId: number, payoutId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PayoutDetail;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'payoutId' + '}', encodeURIComponent(String(payoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPayout.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling getPayout.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling getPayout.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PayoutDetail;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PayoutDetail");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param page 
     * @param limit 
     * @param storeIds 
     * @param {*} [options] Override http request options.
     */
    public getPayoutChargebacks (appId: string, bankAccountId: number, payoutId: number, page?: number, limit?: number, storeIds?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayoutChargeback;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}/chargebacks'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'payoutId' + '}', encodeURIComponent(String(payoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPayoutChargebacks.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling getPayoutChargebacks.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling getPayoutChargebacks.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayoutChargeback;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultPayoutChargeback");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param page 
     * @param limit 
     * @param storeIds 
     * @param {*} [options] Override http request options.
     */
    public getPayoutOrders (appId: string, bankAccountId: number, payoutId: number, page?: number, limit?: number, storeIds?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayoutOrder;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}/orders'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'payoutId' + '}', encodeURIComponent(String(payoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPayoutOrders.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling getPayoutOrders.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling getPayoutOrders.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayoutOrder;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultPayoutOrder");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param page 
     * @param limit 
     * @param storeIds 
     * @param {*} [options] Override http request options.
     */
    public getPayoutOtherCharges (appId: string, bankAccountId: number, payoutId: number, page?: number, limit?: number, storeIds?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayoutOtherCharge;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}/othercharges'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'payoutId' + '}', encodeURIComponent(String(payoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPayoutOtherCharges.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling getPayoutOtherCharges.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling getPayoutOtherCharges.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayoutOtherCharge;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultPayoutOtherCharge");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param page 
     * @param limit 
     * @param storeIds 
     * @param {*} [options] Override http request options.
     */
    public getPayoutRefunds (appId: string, bankAccountId: number, payoutId: number, page?: number, limit?: number, storeIds?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayoutRefund;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}/refunds'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'payoutId' + '}', encodeURIComponent(String(payoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPayoutRefunds.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling getPayoutRefunds.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling getPayoutRefunds.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayoutRefund;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultPayoutRefund");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param startDate 
     * @param endDate 
     * @param payoutRequestIds_bankAccountIds List of bank account ids to search for
     * @param payoutRequestIds_states List of {Flipdish.PublicModels.V1.Payouts.PayoutStatus} so search for
     * @param {*} [options] Override http request options.
     */
    public getPayoutSummaries (appId: string, startDate?: Date, endDate?: Date, payoutRequestIds_bankAccountIds?: Array<number>, payoutRequestIds_states?: Array<'Pending' | 'InTransit' | 'Paid' | 'Failed' | 'Cancelled'>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultPayoutSummary;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/payouts/summaries'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPayoutSummaries.');
        }

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "Date");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "Date");
        }

        if (payoutRequestIds_bankAccountIds !== undefined) {
            localVarQueryParameters['payoutRequestIds.bankAccountIds'] = ObjectSerializer.serialize(payoutRequestIds_bankAccountIds, "Array<number>");
        }

        if (payoutRequestIds_states !== undefined) {
            localVarQueryParameters['payoutRequestIds.states'] = ObjectSerializer.serialize(payoutRequestIds_states, "Array<'Pending' | 'InTransit' | 'Paid' | 'Failed' | 'Cancelled'>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultPayoutSummary;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultPayoutSummary");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param startDate 
     * @param endDate 
     * @param page 
     * @param limit 
     * @param payoutRequestIds_bankAccountIds List of bank account ids to search for
     * @param payoutRequestIds_states List of {Flipdish.PublicModels.V1.Payouts.PayoutStatus} so search for
     * @param {*} [options] Override http request options.
     */
    public getPayouts (appId: string, startDate?: Date, endDate?: Date, page?: number, limit?: number, payoutRequestIds_bankAccountIds?: Array<number>, payoutRequestIds_states?: Array<'Pending' | 'InTransit' | 'Paid' | 'Failed' | 'Cancelled'>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayout;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/payouts'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPayouts.');
        }

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "Date");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "Date");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (payoutRequestIds_bankAccountIds !== undefined) {
            localVarQueryParameters['payoutRequestIds.bankAccountIds'] = ObjectSerializer.serialize(payoutRequestIds_bankAccountIds, "Array<number>");
        }

        if (payoutRequestIds_states !== undefined) {
            localVarQueryParameters['payoutRequestIds.states'] = ObjectSerializer.serialize(payoutRequestIds_states, "Array<'Pending' | 'InTransit' | 'Paid' | 'Failed' | 'Cancelled'>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPayout;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultPayout");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PayoutsExportApiApiKeys {
}

export class PayoutsExportApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PayoutsExportApiApiKeys, value: string) {
        (this.authentications as any)[PayoutsExportApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param storeIds 
     * @param {*} [options] Override http request options.
     */
    public exportPayoutChargebacks (appId: string, bankAccountId: number, payoutId: number, storeIds?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}/chargebacks/export'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'payoutId' + '}', encodeURIComponent(String(payoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling exportPayoutChargebacks.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling exportPayoutChargebacks.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling exportPayoutChargebacks.');
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param storeIds 
     * @param {*} [options] Override http request options.
     */
    public exportPayoutOrders (appId: string, bankAccountId: number, payoutId: number, storeIds?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}/orders/export'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'payoutId' + '}', encodeURIComponent(String(payoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling exportPayoutOrders.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling exportPayoutOrders.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling exportPayoutOrders.');
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param storeIds 
     * @param {*} [options] Override http request options.
     */
    public exportPayoutOtherCharges (appId: string, bankAccountId: number, payoutId: number, storeIds?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}/othercharges/export'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'payoutId' + '}', encodeURIComponent(String(payoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling exportPayoutOtherCharges.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling exportPayoutOtherCharges.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling exportPayoutOtherCharges.');
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param storeIds 
     * @param {*} [options] Override http request options.
     */
    public exportPayoutRefunds (appId: string, bankAccountId: number, payoutId: number, storeIds?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}/refunds/export'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'payoutId' + '}', encodeURIComponent(String(payoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling exportPayoutRefunds.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling exportPayoutRefunds.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling exportPayoutRefunds.');
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param bankAccountId 
     * @param payoutId 
     * @param storeIds 
     * @param {*} [options] Override http request options.
     */
    public exportPayoutStores (appId: string, bankAccountId: number, payoutId: number, storeIds?: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/bankaccounts/{bankAccountId}/payouts/{payoutId}/export'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)))
            .replace('{' + 'payoutId' + '}', encodeURIComponent(String(payoutId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling exportPayoutStores.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling exportPayoutStores.');
        }

        // verify required parameter 'payoutId' is not null or undefined
        if (payoutId === null || payoutId === undefined) {
            throw new Error('Required parameter payoutId was null or undefined when calling exportPayoutStores.');
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param startDate 
     * @param endDate 
     * @param payoutRequestIds_bankAccountIds List of bank account ids to search for
     * @param payoutRequestIds_states List of {Flipdish.PublicModels.V1.Payouts.PayoutStatus} so search for
     * @param {*} [options] Override http request options.
     */
    public exportPayouts (appId: string, startDate?: Date, endDate?: Date, payoutRequestIds_bankAccountIds?: Array<number>, payoutRequestIds_states?: Array<'Pending' | 'InTransit' | 'Paid' | 'Failed' | 'Cancelled'>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/payouts/export'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling exportPayouts.');
        }

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "Date");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "Date");
        }

        if (payoutRequestIds_bankAccountIds !== undefined) {
            localVarQueryParameters['payoutRequestIds.bankAccountIds'] = ObjectSerializer.serialize(payoutRequestIds_bankAccountIds, "Array<number>");
        }

        if (payoutRequestIds_states !== undefined) {
            localVarQueryParameters['payoutRequestIds.states'] = ObjectSerializer.serialize(payoutRequestIds_states, "Array<'Pending' | 'InTransit' | 'Paid' | 'Failed' | 'Cancelled'>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ProcessingFeeConfigsApiApiKeys {
}

export class ProcessingFeeConfigsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ProcessingFeeConfigsApiApiKeys, value: string) {
        (this.authentications as any)[ProcessingFeeConfigsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param storeIds 
     * @param {*} [options] Override http request options.
     */
    public getProcessingFeeConfigsByStoreIds (storeIds: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultProcessingFeeConfig;  }> {
        const localVarPath = this.basePath + '/api/v1.0/processingfeeconfigs';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeIds' is not null or undefined
        if (storeIds === null || storeIds === undefined) {
            throw new Error('Required parameter storeIds was null or undefined when calling getProcessingFeeConfigsByStoreIds.');
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultProcessingFeeConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultProcessingFeeConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PushNotificationsApiApiKeys {
}

export class PushNotificationsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PushNotificationsApiApiKeys, value: string) {
        (this.authentications as any)[PushNotificationsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param scheduledPushNotificationId 
     * @param {*} [options] Override http request options.
     */
    public deletePushNotification (appId: string, scheduledPushNotificationId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/pushnotifications/{scheduledPushNotificationId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'scheduledPushNotificationId' + '}', encodeURIComponent(String(scheduledPushNotificationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deletePushNotification.');
        }

        // verify required parameter 'scheduledPushNotificationId' is not null or undefined
        if (scheduledPushNotificationId === null || scheduledPushNotificationId === undefined) {
            throw new Error('Required parameter scheduledPushNotificationId was null or undefined when calling deletePushNotification.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getPushNotifications (appId: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPushNotificationResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/pushnotifications'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPushNotifications.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultPushNotificationResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultPushNotificationResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param notification 
     * @param {*} [options] Override http request options.
     */
    public schedulePushNotification (appId: string, notification: PushNotificationRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultPushNotificationResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/pushnotifications'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling schedulePushNotification.');
        }

        // verify required parameter 'notification' is not null or undefined
        if (notification === null || notification === undefined) {
            throw new Error('Required parameter notification was null or undefined when calling schedulePushNotification.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(notification, "PushNotificationRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultPushNotificationResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultPushNotificationResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param scheduledPushNotificationId 
     * @param notification 
     * @param {*} [options] Override http request options.
     */
    public updatePushNotification (appId: string, scheduledPushNotificationId: number, notification: PushNotificationRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultPushNotificationResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/pushnotifications/{scheduledPushNotificationId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'scheduledPushNotificationId' + '}', encodeURIComponent(String(scheduledPushNotificationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updatePushNotification.');
        }

        // verify required parameter 'scheduledPushNotificationId' is not null or undefined
        if (scheduledPushNotificationId === null || scheduledPushNotificationId === undefined) {
            throw new Error('Required parameter scheduledPushNotificationId was null or undefined when calling updatePushNotification.');
        }

        // verify required parameter 'notification' is not null or undefined
        if (notification === null || notification === undefined) {
            throw new Error('Required parameter notification was null or undefined when calling updatePushNotification.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(notification, "PushNotificationRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultPushNotificationResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultPushNotificationResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ReceiptsApiApiKeys {
}

export class ReceiptsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ReceiptsApiApiKeys, value: string) {
        (this.authentications as any)[ReceiptsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param orderId 
     * @param {*} [options] Override http request options.
     */
    public getReceipt (orderId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetReceiptByOrderIdQueryResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/receipts/{orderId}'
            .replace('{' + 'orderId' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getReceipt.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetReceiptByOrderIdQueryResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetReceiptByOrderIdQueryResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RestaurantVouchersPayGreenApiApiKeys {
}

export class RestaurantVouchersPayGreenApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RestaurantVouchersPayGreenApiApiKeys, value: string) {
        (this.authentications as any)[RestaurantVouchersPayGreenApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public createPayGreenConfiguration (appId: string, request: CreatePayGreenConfigurationRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultRestaurantVoucherPayGreenConfiguration;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/restaurant-vouchers/paygreen'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createPayGreenConfiguration.');
        }

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling createPayGreenConfiguration.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "CreatePayGreenConfigurationRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultRestaurantVoucherPayGreenConfiguration;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultRestaurantVoucherPayGreenConfiguration");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param paygreenConfigurationId 
     * @param {*} [options] Override http request options.
     */
    public deletePayGreenConfiguration (appId: string, paygreenConfigurationId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/restaurant-vouchers/paygreen/{paygreenConfigurationId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'paygreenConfigurationId' + '}', encodeURIComponent(String(paygreenConfigurationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deletePayGreenConfiguration.');
        }

        // verify required parameter 'paygreenConfigurationId' is not null or undefined
        if (paygreenConfigurationId === null || paygreenConfigurationId === undefined) {
            throw new Error('Required parameter paygreenConfigurationId was null or undefined when calling deletePayGreenConfiguration.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getElegibleStores (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestaurantVoucherEligibleStore;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/restaurant-vouchers/paygreen/stores'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getElegibleStores.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestaurantVoucherEligibleStore;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultRestaurantVoucherEligibleStore");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getPayGreenConfigurations (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestaurantVoucherPayGreenConfiguration;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/restaurant-vouchers/paygreen'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getPayGreenConfigurations.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestaurantVoucherPayGreenConfiguration;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultRestaurantVoucherPayGreenConfiguration");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public getStoreAvailablePayGreenConfigurations (appId: string, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestaurantVoucherPayGreenConfigurationSummary;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/restaurant-vouchers/paygreen/stores/{storeId}/available-configurations'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getStoreAvailablePayGreenConfigurations.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getStoreAvailablePayGreenConfigurations.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestaurantVoucherPayGreenConfigurationSummary;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultRestaurantVoucherPayGreenConfigurationSummary");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public getStorePayGreenConfiguration_ (appId: string, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultRestaurantVoucherPayGreenStoreConfiguration;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/restaurant-vouchers/paygreen/stores/{storeId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getStorePayGreenConfiguration_.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getStorePayGreenConfiguration_.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultRestaurantVoucherPayGreenStoreConfiguration;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultRestaurantVoucherPayGreenStoreConfiguration");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param paygreenConfigurationId 
     * @param {*} [options] Override http request options.
     */
    public listPayGreenConfigurations (appId: string, paygreenConfigurationId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultRestaurantVoucherPayGreenConfiguration;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/restaurant-vouchers/paygreen/{paygreenConfigurationId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'paygreenConfigurationId' + '}', encodeURIComponent(String(paygreenConfigurationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling listPayGreenConfigurations.');
        }

        // verify required parameter 'paygreenConfigurationId' is not null or undefined
        if (paygreenConfigurationId === null || paygreenConfigurationId === undefined) {
            throw new Error('Required parameter paygreenConfigurationId was null or undefined when calling listPayGreenConfigurations.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultRestaurantVoucherPayGreenConfiguration;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultRestaurantVoucherPayGreenConfiguration");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param paygreenConfigurationId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public updatePayGreenConfiguration (appId: string, paygreenConfigurationId: number, request: UpdatePayGreenConfigurationRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultRestaurantVoucherPayGreenConfiguration;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/restaurant-vouchers/paygreen/{paygreenConfigurationId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'paygreenConfigurationId' + '}', encodeURIComponent(String(paygreenConfigurationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updatePayGreenConfiguration.');
        }

        // verify required parameter 'paygreenConfigurationId' is not null or undefined
        if (paygreenConfigurationId === null || paygreenConfigurationId === undefined) {
            throw new Error('Required parameter paygreenConfigurationId was null or undefined when calling updatePayGreenConfiguration.');
        }

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling updatePayGreenConfiguration.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "UpdatePayGreenConfigurationRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultRestaurantVoucherPayGreenConfiguration;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultRestaurantVoucherPayGreenConfiguration");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param storeId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public updateStorePayGreenConfiguration_ (appId: string, storeId: number, request: UpdateStorePayGreenConfigurationRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultRestaurantVoucherPayGreenStoreConfiguration;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/restaurant-vouchers/paygreen/stores/{storeId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateStorePayGreenConfiguration_.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updateStorePayGreenConfiguration_.');
        }

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling updateStorePayGreenConfiguration_.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "UpdateStorePayGreenConfigurationRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultRestaurantVoucherPayGreenStoreConfiguration;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultRestaurantVoucherPayGreenStoreConfiguration");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StoreGroupsApiApiKeys {
}

export class StoreGroupsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StoreGroupsApiApiKeys, value: string) {
        (this.authentications as any)[StoreGroupsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appNameId 
     * @param storeGroup 
     * @param {*} [options] Override http request options.
     */
    public createStoreGroup (appNameId: string, storeGroup: StoreGroupBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStoreGroup;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appNameId}/storegroups'
            .replace('{' + 'appNameId' + '}', encodeURIComponent(String(appNameId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appNameId' is not null or undefined
        if (appNameId === null || appNameId === undefined) {
            throw new Error('Required parameter appNameId was null or undefined when calling createStoreGroup.');
        }

        // verify required parameter 'storeGroup' is not null or undefined
        if (storeGroup === null || storeGroup === undefined) {
            throw new Error('Required parameter storeGroup was null or undefined when calling createStoreGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(storeGroup, "StoreGroupBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStoreGroup;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStoreGroup");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeGroupId 
     * @param {*} [options] Override http request options.
     */
    public getStoreGroup (storeGroupId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStoreGroup;  }> {
        const localVarPath = this.basePath + '/api/v1.0/storegroups/{storeGroupId}'
            .replace('{' + 'storeGroupId' + '}', encodeURIComponent(String(storeGroupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeGroupId' is not null or undefined
        if (storeGroupId === null || storeGroupId === undefined) {
            throw new Error('Required parameter storeGroupId was null or undefined when calling getStoreGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStoreGroup;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStoreGroup");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appNameId 
     * @param searchQuery 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getStoreGroups (appNameId: string, searchQuery?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStoreGroup;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appNameId}/storegroups'
            .replace('{' + 'appNameId' + '}', encodeURIComponent(String(appNameId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appNameId' is not null or undefined
        if (appNameId === null || appNameId === undefined) {
            throw new Error('Required parameter appNameId was null or undefined when calling getStoreGroups.');
        }

        if (searchQuery !== undefined) {
            localVarQueryParameters['searchQuery'] = ObjectSerializer.serialize(searchQuery, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStoreGroup;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultStoreGroup");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appNameId 
     * @param searchQuery 
     * @param page 
     * @param limit 
     * @param groupingRadius 
     * @param {*} [options] Override http request options.
     */
    public getStoreGroupsExtended (appNameId: string, searchQuery?: string, page?: number, limit?: number, groupingRadius?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStoreGroupExtended;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appNameId}/storegroups/extended'
            .replace('{' + 'appNameId' + '}', encodeURIComponent(String(appNameId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appNameId' is not null or undefined
        if (appNameId === null || appNameId === undefined) {
            throw new Error('Required parameter appNameId was null or undefined when calling getStoreGroupsExtended.');
        }

        if (searchQuery !== undefined) {
            localVarQueryParameters['searchQuery'] = ObjectSerializer.serialize(searchQuery, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (groupingRadius !== undefined) {
            localVarQueryParameters['groupingRadius'] = ObjectSerializer.serialize(groupingRadius, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStoreGroupExtended;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultStoreGroupExtended");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeGroupId 
     * @param {*} [options] Override http request options.
     */
    public removeStoreGroup (storeGroupId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/storegroups/{storeGroupId}'
            .replace('{' + 'storeGroupId' + '}', encodeURIComponent(String(storeGroupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeGroupId' is not null or undefined
        if (storeGroupId === null || storeGroupId === undefined) {
            throw new Error('Required parameter storeGroupId was null or undefined when calling removeStoreGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeGroupId 
     * @param deliveryType 
     * @param menuMessage 
     * @param {*} [options] Override http request options.
     */
    public setMenuMessagePerDeliveryType (storeGroupId: number, deliveryType: 'Delivery' | 'Pickup', menuMessage: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/storegroups/{storeGroupId}/{deliveryType}/MenuMessagePerDeliveryType'
            .replace('{' + 'storeGroupId' + '}', encodeURIComponent(String(storeGroupId)))
            .replace('{' + 'deliveryType' + '}', encodeURIComponent(String(deliveryType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeGroupId' is not null or undefined
        if (storeGroupId === null || storeGroupId === undefined) {
            throw new Error('Required parameter storeGroupId was null or undefined when calling setMenuMessagePerDeliveryType.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling setMenuMessagePerDeliveryType.');
        }

        // verify required parameter 'menuMessage' is not null or undefined
        if (menuMessage === null || menuMessage === undefined) {
            throw new Error('Required parameter menuMessage was null or undefined when calling setMenuMessagePerDeliveryType.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(menuMessage, "string")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeGroupId 
     * @param storeGroup 
     * @param {*} [options] Override http request options.
     */
    public updateStoreGroup (storeGroupId: number, storeGroup: StoreGroupBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStoreGroupBase;  }> {
        const localVarPath = this.basePath + '/api/v1.0/storegroups/{storeGroupId}'
            .replace('{' + 'storeGroupId' + '}', encodeURIComponent(String(storeGroupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeGroupId' is not null or undefined
        if (storeGroupId === null || storeGroupId === undefined) {
            throw new Error('Required parameter storeGroupId was null or undefined when calling updateStoreGroup.');
        }

        // verify required parameter 'storeGroup' is not null or undefined
        if (storeGroup === null || storeGroup === undefined) {
            throw new Error('Required parameter storeGroup was null or undefined when calling updateStoreGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(storeGroup, "StoreGroupBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStoreGroupBase;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStoreGroupBase");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StoreOrderCapacityApiApiKeys {
}

export class StoreOrderCapacityApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StoreOrderCapacityApiApiKeys, value: string) {
        (this.authentications as any)[StoreOrderCapacityApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param storeId 
     * @param deliveryType 
     * @param {*} [options] Override http request options.
     */
    public getStoreOrderCapacity (appId: string, storeId: number, deliveryType: 'Delivery' | 'Pickup', options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStoreOrderCapacityConfig;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/storeordercapacity/{storeId}/{deliveryType}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryType' + '}', encodeURIComponent(String(deliveryType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getStoreOrderCapacity.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getStoreOrderCapacity.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling getStoreOrderCapacity.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStoreOrderCapacityConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStoreOrderCapacityConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param deliveryType 
     * @param newOrderCapacityConfig 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public updateStoreOrderCapacityConfig (storeId: number, deliveryType: 'Delivery' | 'Pickup', newOrderCapacityConfig: StoreOrderCapacityConfigEditModel, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/storeordercapacity/{storeId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updateStoreOrderCapacityConfig.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling updateStoreOrderCapacityConfig.');
        }

        // verify required parameter 'newOrderCapacityConfig' is not null or undefined
        if (newOrderCapacityConfig === null || newOrderCapacityConfig === undefined) {
            throw new Error('Required parameter newOrderCapacityConfig was null or undefined when calling updateStoreOrderCapacityConfig.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateStoreOrderCapacityConfig.');
        }

        if (deliveryType !== undefined) {
            localVarQueryParameters['deliveryType'] = ObjectSerializer.serialize(deliveryType, "'Delivery' | 'Pickup'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(newOrderCapacityConfig, "StoreOrderCapacityConfigEditModel")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StoresApiApiKeys {
}

export class StoresApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StoresApiApiKeys, value: string) {
        (this.authentications as any)[StoresApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public archiveStore (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/archive'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling archiveStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param menuId 
     * @param {*} [options] Override http request options.
     */
    public assignMenu (storeId: number, menuId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestApiDefaultResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/menu/{menuId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'menuId' + '}', encodeURIComponent(String(menuId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling assignMenu.');
        }

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling assignMenu.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestApiDefaultResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultRestApiDefaultResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param settings 
     * @param {*} [options] Override http request options.
     */
    public cloneStore (storeId: number, settings: StoreCloneSettings, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/clone'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling cloneStore.');
        }

        // verify required parameter 'settings' is not null or undefined
        if (settings === null || settings === undefined) {
            throw new Error('Required parameter settings was null or undefined when calling cloneStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(settings, "StoreCloneSettings")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStore");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param serviceCharge 
     * @param {*} [options] Override http request options.
     */
    public configureStoreServiceCharge (storeId: number, serviceCharge: ServiceCharge, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultServiceCharge;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/servicecharge'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling configureStoreServiceCharge.');
        }

        // verify required parameter 'serviceCharge' is not null or undefined
        if (serviceCharge === null || serviceCharge === undefined) {
            throw new Error('Required parameter serviceCharge was null or undefined when calling configureStoreServiceCharge.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(serviceCharge, "ServiceCharge")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultServiceCharge;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultServiceCharge");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param businessHoursOverride 
     * @param {*} [options] Override http request options.
     */
    public createBusinessHoursOverrideByStoreId (storeId: number, businessHoursOverride: BusinessHoursOverrideBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultBusinessHoursOverride;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/businesshoursoverrides'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling createBusinessHoursOverrideByStoreId.');
        }

        // verify required parameter 'businessHoursOverride' is not null or undefined
        if (businessHoursOverride === null || businessHoursOverride === undefined) {
            throw new Error('Required parameter businessHoursOverride was null or undefined when calling createBusinessHoursOverrideByStoreId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(businessHoursOverride, "BusinessHoursOverrideBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultBusinessHoursOverride;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultBusinessHoursOverride");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeGroupId 
     * @param store 
     * @param {*} [options] Override http request options.
     */
    public createStore (storeGroupId: number, store: StoreCreateBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeGroupId' is not null or undefined
        if (storeGroupId === null || storeGroupId === undefined) {
            throw new Error('Required parameter storeGroupId was null or undefined when calling createStore.');
        }

        // verify required parameter 'store' is not null or undefined
        if (store === null || store === undefined) {
            throw new Error('Required parameter store was null or undefined when calling createStore.');
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(store, "StoreCreateBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStore");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param businessHoursOverrideId 
     * @param {*} [options] Override http request options.
     */
    public deleteBusinessHoursOverride (storeId: number, businessHoursOverrideId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestApiDefaultResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/businesshoursoverrides/{businessHoursOverrideId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'businessHoursOverrideId' + '}', encodeURIComponent(String(businessHoursOverrideId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling deleteBusinessHoursOverride.');
        }

        // verify required parameter 'businessHoursOverrideId' is not null or undefined
        if (businessHoursOverrideId === null || businessHoursOverrideId === undefined) {
            throw new Error('Required parameter businessHoursOverrideId was null or undefined when calling deleteBusinessHoursOverride.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestApiDefaultResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultRestApiDefaultResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public getBankAccountForStore (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultAssignedBankAccount;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/bankaccount'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getBankAccountForStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultAssignedBankAccount;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultAssignedBankAccount");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param deliveryType 
     * @param {*} [options] Override http request options.
     */
    public getBusinessHours (storeId: number, deliveryType: 'Delivery' | 'Pickup', options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultBusinessHoursPeriod;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/availability/{deliveryType}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryType' + '}', encodeURIComponent(String(deliveryType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getBusinessHours.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling getBusinessHours.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultBusinessHoursPeriod;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultBusinessHoursPeriod");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param after 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getBusinessHoursOverrideByStoreId (storeId: number, after?: Date, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultBusinessHoursOverride;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/businesshoursoverrides'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getBusinessHoursOverrideByStoreId.');
        }

        if (after !== undefined) {
            localVarQueryParameters['after'] = ObjectSerializer.serialize(after, "Date");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultBusinessHoursOverride;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultBusinessHoursOverride");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param date 
     * @param {*} [options] Override http request options.
     */
    public getEndOfDayReport (storeId: number, date?: Date, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStoreEndOfDayReport;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/endofdayreport'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getEndOfDayReport.');
        }

        if (date !== undefined) {
            localVarQueryParameters['date'] = ObjectSerializer.serialize(date, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStoreEndOfDayReport;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStoreEndOfDayReport");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param deliveryType 
     * @param {*} [options] Override http request options.
     */
    public getPreOrderConfig (storeId: number, deliveryType: 'Delivery' | 'Pickup', options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultPreOrderConfig;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/preorderconfig/{deliveryType}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryType' + '}', encodeURIComponent(String(deliveryType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getPreOrderConfig.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling getPreOrderConfig.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultPreOrderConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultPreOrderConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param deliveryType 
     * @param preOrderConfig_leadTimeMinutes Lead Time in Minutes
     * @param preOrderConfig_intervalMinutes Interval in minutes
     * @param preOrderConfig_maxOrderAheadDays Max Days to order ahead
     * @param preOrderConfig_includeAsap Show ASAP as option
     * @param preOrderConfig_includeMoreGranularInitialTime Granual Init&#39; Time
     * @param preOrderConfig_cutOffTimePreviousDayBasic Cut off time previous day
     * @param preOrderConfig_cutOffTimeCurrentDayBasic Cut off time current day
     * @param preOrderConfig_preOrderTimeDisplayType Type of time displayed.
     * @param preOrderConfig_alwaysAppearOpen Specifies whether a customer can pre-order outside the store opening hours or not.
     * @param preOrderConfig_requireExplicitSelectAlways Force customer to select collection time.
     * @param {*} [options] Override http request options.
     */
    public getPreOrderPreview (storeId: number, deliveryType: 'Delivery' | 'Pickup', preOrderConfig_leadTimeMinutes?: number, preOrderConfig_intervalMinutes?: number, preOrderConfig_maxOrderAheadDays?: number, preOrderConfig_includeAsap?: boolean, preOrderConfig_includeMoreGranularInitialTime?: boolean, preOrderConfig_cutOffTimePreviousDayBasic?: string, preOrderConfig_cutOffTimeCurrentDayBasic?: string, preOrderConfig_preOrderTimeDisplayType?: 'SingleTime' | 'StartAndEndTime' | 'DayOnly', preOrderConfig_alwaysAppearOpen?: boolean, preOrderConfig_requireExplicitSelectAlways?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultPreOrderTime;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/preorderconfig/{deliveryType}/preview'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryType' + '}', encodeURIComponent(String(deliveryType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getPreOrderPreview.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling getPreOrderPreview.');
        }

        if (preOrderConfig_leadTimeMinutes !== undefined) {
            localVarQueryParameters['preOrderConfig.leadTimeMinutes'] = ObjectSerializer.serialize(preOrderConfig_leadTimeMinutes, "number");
        }

        if (preOrderConfig_intervalMinutes !== undefined) {
            localVarQueryParameters['preOrderConfig.intervalMinutes'] = ObjectSerializer.serialize(preOrderConfig_intervalMinutes, "number");
        }

        if (preOrderConfig_maxOrderAheadDays !== undefined) {
            localVarQueryParameters['preOrderConfig.maxOrderAheadDays'] = ObjectSerializer.serialize(preOrderConfig_maxOrderAheadDays, "number");
        }

        if (preOrderConfig_includeAsap !== undefined) {
            localVarQueryParameters['preOrderConfig.includeAsap'] = ObjectSerializer.serialize(preOrderConfig_includeAsap, "boolean");
        }

        if (preOrderConfig_includeMoreGranularInitialTime !== undefined) {
            localVarQueryParameters['preOrderConfig.includeMoreGranularInitialTime'] = ObjectSerializer.serialize(preOrderConfig_includeMoreGranularInitialTime, "boolean");
        }

        if (preOrderConfig_cutOffTimePreviousDayBasic !== undefined) {
            localVarQueryParameters['preOrderConfig.cutOffTimePreviousDayBasic'] = ObjectSerializer.serialize(preOrderConfig_cutOffTimePreviousDayBasic, "string");
        }

        if (preOrderConfig_cutOffTimeCurrentDayBasic !== undefined) {
            localVarQueryParameters['preOrderConfig.cutOffTimeCurrentDayBasic'] = ObjectSerializer.serialize(preOrderConfig_cutOffTimeCurrentDayBasic, "string");
        }

        if (preOrderConfig_preOrderTimeDisplayType !== undefined) {
            localVarQueryParameters['preOrderConfig.preOrderTimeDisplayType'] = ObjectSerializer.serialize(preOrderConfig_preOrderTimeDisplayType, "'SingleTime' | 'StartAndEndTime' | 'DayOnly'");
        }

        if (preOrderConfig_alwaysAppearOpen !== undefined) {
            localVarQueryParameters['preOrderConfig.alwaysAppearOpen'] = ObjectSerializer.serialize(preOrderConfig_alwaysAppearOpen, "boolean");
        }

        if (preOrderConfig_requireExplicitSelectAlways !== undefined) {
            localVarQueryParameters['preOrderConfig.requireExplicitSelectAlways'] = ObjectSerializer.serialize(preOrderConfig_requireExplicitSelectAlways, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultPreOrderTime;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultPreOrderTime");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param appNameId 
     * @param {*} [options] Override http request options.
     */
    public getProcessingFeeConfigsByStoreId (storeId: number, appNameId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultProcessingFeeConfig;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/processingfeeconfigs'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getProcessingFeeConfigsByStoreId.');
        }

        if (appNameId !== undefined) {
            localVarQueryParameters['appNameId'] = ObjectSerializer.serialize(appNameId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultProcessingFeeConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultProcessingFeeConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param paymentAccountType 
     * @param appNameId 
     * @param {*} [options] Override http request options.
     */
    public getProcessingFeeConfigsByStoreIdAndPaymentAccountType (storeId: number, paymentAccountType: 'Card' | 'Cash' | 'Ideal' | 'Bancontact' | 'Giropay' | 'Eps' | 'Emv' | 'PayPal' | 'PayGreen' | 'GoogleWalletToken', appNameId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultProcessingFeeConfig;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/processingfeeconfigs/{paymentAccountType}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'paymentAccountType' + '}', encodeURIComponent(String(paymentAccountType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getProcessingFeeConfigsByStoreIdAndPaymentAccountType.');
        }

        // verify required parameter 'paymentAccountType' is not null or undefined
        if (paymentAccountType === null || paymentAccountType === undefined) {
            throw new Error('Required parameter paymentAccountType was null or undefined when calling getProcessingFeeConfigsByStoreIdAndPaymentAccountType.');
        }

        if (appNameId !== undefined) {
            localVarQueryParameters['appNameId'] = ObjectSerializer.serialize(appNameId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultProcessingFeeConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultProcessingFeeConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public getStoreById (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getStoreById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStore");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public getStoreDeliveryFeeConfig (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultStoreDeliveryZoneFeeConfig;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/feeConfig/deliveryZones'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getStoreDeliveryFeeConfig.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultStoreDeliveryZoneFeeConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultStoreDeliveryZoneFeeConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public getStoreFeeConfig (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: StoreFeeConfig;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/feeConfig'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getStoreFeeConfig.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: StoreFeeConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "StoreFeeConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param storeNameQuery 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getStoreHeadersByAppId (appId: string, storeNameQuery?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStoreHeader;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stores/header'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getStoreHeadersByAppId.');
        }

        if (storeNameQuery !== undefined) {
            localVarQueryParameters['storeNameQuery'] = ObjectSerializer.serialize(storeNameQuery, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStoreHeader;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultStoreHeader");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public getStoreLeadTimes (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultOrderLeadTimes;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/leadTimes'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getStoreLeadTimes.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultOrderLeadTimes;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultOrderLeadTimes");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public getStoreNetSales (appId: string, storeId: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultStoreStatistics;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stores/stats'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getStoreNetSales.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getStoreNetSales.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultStoreStatistics;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultStoreStatistics");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public getStoreServiceCharge (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ServiceCharge;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/servicecharge'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getStoreServiceCharge.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ServiceCharge;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ServiceCharge");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param searchQuery 
     * @param page 
     * @param limit 
     * @param storeGroupId 
     * @param {*} [options] Override http request options.
     */
    public getStores (searchQuery?: string, page?: number, limit?: number, storeGroupId?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStore;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (searchQuery !== undefined) {
            localVarQueryParameters['searchQuery'] = ObjectSerializer.serialize(searchQuery, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (storeGroupId !== undefined) {
            localVarQueryParameters['storeGroupId'] = ObjectSerializer.serialize(storeGroupId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStore;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultStore");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param searchQuery 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getStoresByAppId (appId: string, searchQuery?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStore;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/stores'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getStoresByAppId.');
        }

        if (searchQuery !== undefined) {
            localVarQueryParameters['searchQuery'] = ObjectSerializer.serialize(searchQuery, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStore;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultStore");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param appId 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getStoresByStoreIdWithValidations (storeId: Array<number>, appId: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStoreValidationConfig;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/storevalidation/kiosk'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getStoresByStoreIdWithValidations.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getStoresByStoreIdWithValidations.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultStoreValidationConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultStoreValidationConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public publishStore (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/publish'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling publishStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param feeConfigUpdateRequest 
     * @param {*} [options] Override http request options.
     */
    public putStoreDeliveryFeeConfig (storeId: number, feeConfigUpdateRequest: StoreDeliveryZoneFeeConfigUpdateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/feeConfig/deliveryZones'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling putStoreDeliveryFeeConfig.');
        }

        // verify required parameter 'feeConfigUpdateRequest' is not null or undefined
        if (feeConfigUpdateRequest === null || feeConfigUpdateRequest === undefined) {
            throw new Error('Required parameter feeConfigUpdateRequest was null or undefined when calling putStoreDeliveryFeeConfig.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(feeConfigUpdateRequest, "StoreDeliveryZoneFeeConfigUpdateRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param deliveryType 
     * @param businessHoursPeriod 
     * @param {*} [options] Override http request options.
     */
    public setBusinessHours (storeId: number, deliveryType: 'Delivery' | 'Pickup', businessHoursPeriod: BusinessHoursPeriodBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultBusinessHoursPeriod;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/availability/{deliveryType}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryType' + '}', encodeURIComponent(String(deliveryType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling setBusinessHours.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling setBusinessHours.');
        }

        // verify required parameter 'businessHoursPeriod' is not null or undefined
        if (businessHoursPeriod === null || businessHoursPeriod === undefined) {
            throw new Error('Required parameter businessHoursPeriod was null or undefined when calling setBusinessHours.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(businessHoursPeriod, "BusinessHoursPeriodBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultBusinessHoursPeriod;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultBusinessHoursPeriod");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param deliveryType 
     * @param enabled 
     * @param {*} [options] Override http request options.
     */
    public setPreOrdeEnabled (storeId: number, deliveryType: 'Delivery' | 'Pickup', enabled: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestApiDefaultResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/preorderconfig/{deliveryType}/enabled'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryType' + '}', encodeURIComponent(String(deliveryType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling setPreOrdeEnabled.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling setPreOrdeEnabled.');
        }

        // verify required parameter 'enabled' is not null or undefined
        if (enabled === null || enabled === undefined) {
            throw new Error('Required parameter enabled was null or undefined when calling setPreOrdeEnabled.');
        }

        if (enabled !== undefined) {
            localVarQueryParameters['enabled'] = ObjectSerializer.serialize(enabled, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestApiDefaultResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultRestApiDefaultResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param leadTime 
     * @param {*} [options] Override http request options.
     */
    public setStoreLeadTimes (storeId: number, leadTime: LeadTime, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultOrderLeadTimes;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/leadTimes'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling setStoreLeadTimes.');
        }

        // verify required parameter 'leadTime' is not null or undefined
        if (leadTime === null || leadTime === undefined) {
            throw new Error('Required parameter leadTime was null or undefined when calling setStoreLeadTimes.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(leadTime, "LeadTime")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultOrderLeadTimes;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultOrderLeadTimes");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public unpublishStore (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/unpublish'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling unpublishStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param deliveryType 
     * @param preOrderConfig 
     * @param {*} [options] Override http request options.
     */
    public updatePreOrderConfig (storeId: number, deliveryType: 'Delivery' | 'Pickup', preOrderConfig: PreOrderConfig, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestApiDefaultResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/preorderconfig/{deliveryType}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'deliveryType' + '}', encodeURIComponent(String(deliveryType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updatePreOrderConfig.');
        }

        // verify required parameter 'deliveryType' is not null or undefined
        if (deliveryType === null || deliveryType === undefined) {
            throw new Error('Required parameter deliveryType was null or undefined when calling updatePreOrderConfig.');
        }

        // verify required parameter 'preOrderConfig' is not null or undefined
        if (preOrderConfig === null || preOrderConfig === undefined) {
            throw new Error('Required parameter preOrderConfig was null or undefined when calling updatePreOrderConfig.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(preOrderConfig, "PreOrderConfig")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultRestApiDefaultResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultRestApiDefaultResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param store 
     * @param {*} [options] Override http request options.
     */
    public updateStore (storeId: number, store: StoreBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updateStore.');
        }

        // verify required parameter 'store' is not null or undefined
        if (store === null || store === undefined) {
            throw new Error('Required parameter store was null or undefined when calling updateStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(store, "StoreBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStore;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStore");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param storeAddress 
     * @param {*} [options] Override http request options.
     */
    public updateStoreAddress (storeId: number, storeAddress: StoreAddressBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStoreAddress;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/address'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updateStoreAddress.');
        }

        // verify required parameter 'storeAddress' is not null or undefined
        if (storeAddress === null || storeAddress === undefined) {
            throw new Error('Required parameter storeAddress was null or undefined when calling updateStoreAddress.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(storeAddress, "StoreAddressBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStoreAddress;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStoreAddress");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param coordinates 
     * @param appNameId 
     * @param {*} [options] Override http request options.
     */
    public updateStoreAddressCoordinates (storeId: number, coordinates: Coordinates, appNameId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultCoordinates;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/address/coordinates'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updateStoreAddressCoordinates.');
        }

        // verify required parameter 'coordinates' is not null or undefined
        if (coordinates === null || coordinates === undefined) {
            throw new Error('Required parameter coordinates was null or undefined when calling updateStoreAddressCoordinates.');
        }

        if (appNameId !== undefined) {
            localVarQueryParameters['appNameId'] = ObjectSerializer.serialize(appNameId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(coordinates, "Coordinates")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultCoordinates;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultCoordinates");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param address 
     * @param {*} [options] Override http request options.
     */
    public updateStoreAddressForm (storeId: number, address: StoreAddressForm, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/addressform'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling updateStoreAddressForm.');
        }

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling updateStoreAddressForm.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(address, "StoreAddressForm")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StripeCustomConnectApiApiKeys {
}

export class StripeCustomConnectApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StripeCustomConnectApiApiKeys, value: string) {
        (this.authentications as any)[StripeCustomConnectApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param account 
     * @param {*} [options] Override http request options.
     */
    public createBankAccountAndConnectedAccount (appId: string, account: BankAccountCreate, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customconnect/bank-account'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createBankAccountAndConnectedAccount.');
        }

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling createBankAccountAndConnectedAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(account, "BankAccountCreate")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultBankAccountDetail");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param bankAccountId 
     * @param {*} [options] Override http request options.
     */
    public createStripeConnectedAccount (appId: string, bankAccountId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStripeConnectedAccount;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customconnect/{bankAccountId}/create-update-account'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createStripeConnectedAccount.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling createStripeConnectedAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStripeConnectedAccount;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStripeConnectedAccount");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param stripeConnectedAccountId 
     * @param stripeAccountLinkRequest 
     * @param {*} [options] Override http request options.
     */
    public createStripeConnectedAccountLink (appId: string, stripeConnectedAccountId: string, stripeAccountLinkRequest: StripeAccountLinkRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStripeConnectedAccount;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customconnect/{stripeConnectedAccountId}/create-account-link'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'stripeConnectedAccountId' + '}', encodeURIComponent(String(stripeConnectedAccountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createStripeConnectedAccountLink.');
        }

        // verify required parameter 'stripeConnectedAccountId' is not null or undefined
        if (stripeConnectedAccountId === null || stripeConnectedAccountId === undefined) {
            throw new Error('Required parameter stripeConnectedAccountId was null or undefined when calling createStripeConnectedAccountLink.');
        }

        // verify required parameter 'stripeAccountLinkRequest' is not null or undefined
        if (stripeAccountLinkRequest === null || stripeAccountLinkRequest === undefined) {
            throw new Error('Required parameter stripeAccountLinkRequest was null or undefined when calling createStripeConnectedAccountLink.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(stripeAccountLinkRequest, "StripeAccountLinkRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStripeConnectedAccount;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStripeConnectedAccount");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getCustomConnect (storeId: number, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultStripeCustomConnectedAccount;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customconnect/{storeId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getCustomConnect.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getCustomConnect.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultStripeCustomConnectedAccount;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultStripeCustomConnectedAccount");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param stripeConnectedAccountId 
     * @param {*} [options] Override http request options.
     */
    public getVerificationStatus (appId: string, stripeConnectedAccountId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStripeConnectedAccount;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customconnect/verification-status'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getVerificationStatus.');
        }

        // verify required parameter 'stripeConnectedAccountId' is not null or undefined
        if (stripeConnectedAccountId === null || stripeConnectedAccountId === undefined) {
            throw new Error('Required parameter stripeConnectedAccountId was null or undefined when calling getVerificationStatus.');
        }

        if (stripeConnectedAccountId !== undefined) {
            localVarQueryParameters['stripeConnectedAccountId'] = ObjectSerializer.serialize(stripeConnectedAccountId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStripeConnectedAccount;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStripeConnectedAccount");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param bankAccountId 
     * @param businessType 
     * @param {*} [options] Override http request options.
     */
    public setBankAccountBusinessType (appId: string, bankAccountId: number, businessType: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customconnect/bank-account/{bankAccountId}/businesstype'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling setBankAccountBusinessType.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling setBankAccountBusinessType.');
        }

        // verify required parameter 'businessType' is not null or undefined
        if (businessType === null || businessType === undefined) {
            throw new Error('Required parameter businessType was null or undefined when calling setBankAccountBusinessType.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(businessType, "string")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultBankAccountDetail");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param linkRequestId 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public stripeCustomConnectRefresh (linkRequestId: number, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customconnect/refresh-link'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'linkRequestId' is not null or undefined
        if (linkRequestId === null || linkRequestId === undefined) {
            throw new Error('Required parameter linkRequestId was null or undefined when calling stripeCustomConnectRefresh.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling stripeCustomConnectRefresh.');
        }

        if (linkRequestId !== undefined) {
            localVarQueryParameters['linkRequestId'] = ObjectSerializer.serialize(linkRequestId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param bankAccountId 
     * @param updateRequest 
     * @param {*} [options] Override http request options.
     */
    public updateBankAccountDetails (appId: string, bankAccountId: number, updateRequest: BankAccountDetailsUpdateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStripeConnectedAccount;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customconnect/{bankAccountId}/update-bank-account-details'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'bankAccountId' + '}', encodeURIComponent(String(bankAccountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateBankAccountDetails.');
        }

        // verify required parameter 'bankAccountId' is not null or undefined
        if (bankAccountId === null || bankAccountId === undefined) {
            throw new Error('Required parameter bankAccountId was null or undefined when calling updateBankAccountDetails.');
        }

        // verify required parameter 'updateRequest' is not null or undefined
        if (updateRequest === null || updateRequest === undefined) {
            throw new Error('Required parameter updateRequest was null or undefined when calling updateBankAccountDetails.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateRequest, "BankAccountDetailsUpdateRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStripeConnectedAccount;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStripeConnectedAccount");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param stripeConnectedAccountId 
     * @param interval 
     * @param {*} [options] Override http request options.
     */
    public updatePayoutSchedule (appId: string, stripeConnectedAccountId: string, interval: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultModelBase;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/customconnect/update-payout-schedule/{stripeConnectedAccountId}/{interval}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'stripeConnectedAccountId' + '}', encodeURIComponent(String(stripeConnectedAccountId)))
            .replace('{' + 'interval' + '}', encodeURIComponent(String(interval)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updatePayoutSchedule.');
        }

        // verify required parameter 'stripeConnectedAccountId' is not null or undefined
        if (stripeConnectedAccountId === null || stripeConnectedAccountId === undefined) {
            throw new Error('Required parameter stripeConnectedAccountId was null or undefined when calling updatePayoutSchedule.');
        }

        // verify required parameter 'interval' is not null or undefined
        if (interval === null || interval === undefined) {
            throw new Error('Required parameter interval was null or undefined when calling updatePayoutSchedule.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultModelBase;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultModelBase");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StripeCustomConnectAdminApiApiKeys {
}

export class StripeCustomConnectAdminApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StripeCustomConnectAdminApiApiKeys, value: string) {
        (this.authentications as any)[StripeCustomConnectAdminApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param accounts 
     * @param {*} [options] Override http request options.
     */
    public initializeBankAccountConnectedAccount (accounts: Array<number>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }> {
        const localVarPath = this.basePath + '/api/v1.0/customconnect/initialize-bank-account';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accounts' is not null or undefined
        if (accounts === null || accounts === undefined) {
            throw new Error('Required parameter accounts was null or undefined when calling initializeBankAccountConnectedAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(accounts, "Array<number>")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultBankAccountDetail;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultBankAccountDetail");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StuartApiApiKeys {
}

export class StuartApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StuartApiApiKeys, value: string) {
        (this.authentications as any)[StuartApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param jobId 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public stuartCancelJob (jobId: number, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stuart/jobs/{jobId}'
            .replace('{' + 'jobId' + '}', encodeURIComponent(String(jobId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'jobId' is not null or undefined
        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling stuartCancelJob.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling stuartCancelJob.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param jobId 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public stuartGetJob (jobId: number, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultJobResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stuart/jobs/{jobId}'
            .replace('{' + 'jobId' + '}', encodeURIComponent(String(jobId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'jobId' is not null or undefined
        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling stuartGetJob.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling stuartGetJob.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultJobResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultJobResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public stuartGetStuartSettings (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultStuartSettings;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stuart/settings/{storeId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling stuartGetStuartSettings.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultStuartSettings;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultStuartSettings");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param stuartSettings 
     * @param {*} [options] Override http request options.
     */
    public stuartPostStuartSettings (storeId: number, stuartSettings: StuartSettings, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stuart/settings/{storeId}'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling stuartPostStuartSettings.');
        }

        // verify required parameter 'stuartSettings' is not null or undefined
        if (stuartSettings === null || stuartSettings === undefined) {
            throw new Error('Required parameter stuartSettings was null or undefined when calling stuartPostStuartSettings.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(stuartSettings, "StuartSettings")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SubscriptionsApiApiKeys {
}

export class SubscriptionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SubscriptionsApiApiKeys, value: string) {
        (this.authentications as any)[SubscriptionsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param subscriptionId 
     * @param {*} [options] Override http request options.
     */
    public getSubscriptionById (appId: string, subscriptionId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultSubscription;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/subscriptions/{subscriptionId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'subscriptionId' + '}', encodeURIComponent(String(subscriptionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getSubscriptionById.');
        }

        // verify required parameter 'subscriptionId' is not null or undefined
        if (subscriptionId === null || subscriptionId === undefined) {
            throw new Error('Required parameter subscriptionId was null or undefined when calling getSubscriptionById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultSubscription;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultSubscription");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param excludeNotOwnedSubscriptions 
     * @param storeId 
     * @param excludeCancelledSubscriptions 
     * @param {*} [options] Override http request options.
     */
    public getSubscriptionsForApp (appId: string, excludeNotOwnedSubscriptions?: boolean, storeId?: Array<number>, excludeCancelledSubscriptions?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultSubscriptionSummary;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/subscriptions'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getSubscriptionsForApp.');
        }

        if (excludeNotOwnedSubscriptions !== undefined) {
            localVarQueryParameters['excludeNotOwnedSubscriptions'] = ObjectSerializer.serialize(excludeNotOwnedSubscriptions, "boolean");
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        if (excludeCancelledSubscriptions !== undefined) {
            localVarQueryParameters['excludeCancelledSubscriptions'] = ObjectSerializer.serialize(excludeCancelledSubscriptions, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultSubscriptionSummary;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultSubscriptionSummary");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param email 
     * @param {*} [options] Override http request options.
     */
    public hasCustomerGotPaymentMethodOnFile (appId: string, email?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultHasPaymentMethodResponse;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/subscriptions/hasPaymentMethod'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling hasCustomerGotPaymentMethodOnFile.');
        }

        if (email !== undefined) {
            localVarQueryParameters['email'] = ObjectSerializer.serialize(email, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultHasPaymentMethodResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultHasPaymentMethodResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TeammatesApiApiKeys {
}

export class TeammatesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TeammatesApiApiKeys, value: string) {
        (this.authentications as any)[TeammatesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param teammate 
     * @param {*} [options] Override http request options.
     */
    public createTeammate (appId: string, teammate: CreateTeammate, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultTeammate;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/teammates'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createTeammate.');
        }

        // verify required parameter 'teammate' is not null or undefined
        if (teammate === null || teammate === undefined) {
            throw new Error('Required parameter teammate was null or undefined when calling createTeammate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(teammate, "CreateTeammate")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultTeammate;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultTeammate");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public deleteTeammate (appId: string, id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/teammates/{id}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteTeammate.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteTeammate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public getTeammateByAppIdAndTeammateId (appId: string, id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultTeammate;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/teammates/{id}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getTeammateByAppIdAndTeammateId.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTeammateByAppIdAndTeammateId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultTeammate;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultTeammate");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getTeammatesByAppId (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultTeammate;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/teammates'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getTeammatesByAppId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultTeammate;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultTeammate");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param otc 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public redeemInvitation (otc: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultRedeemInvitationResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/teammates/redeem/{otc}'
            .replace('{' + 'otc' + '}', encodeURIComponent(String(otc)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'otc' is not null or undefined
        if (otc === null || otc === undefined) {
            throw new Error('Required parameter otc was null or undefined when calling redeemInvitation.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling redeemInvitation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultRedeemInvitationResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultRedeemInvitationResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param id 
     * @param teammate 
     * @param {*} [options] Override http request options.
     */
    public updateTeammate (appId: string, id: string, teammate: TeammateBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultTeammate;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/teammates/{id}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateTeammate.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateTeammate.');
        }

        // verify required parameter 'teammate' is not null or undefined
        if (teammate === null || teammate === undefined) {
            throw new Error('Required parameter teammate was null or undefined when calling updateTeammate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(teammate, "TeammateBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultTeammate;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultTeammate");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TerminalIotApiApiKeys {
}

export class TerminalIotApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TerminalIotApiApiKeys, value: string) {
        (this.authentications as any)[TerminalIotApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public getTerminalIotConnection (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultKioskIotConnectionParameters;  }> {
        const localVarPath = this.basePath + '/api/v1.0/terminaliot/connect';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultKioskIotConnectionParameters;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultKioskIotConnectionParameters");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TipsApiApiKeys {
}

export class TipsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TipsApiApiKeys, value: string) {
        (this.authentications as any)[TipsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public tipConfigGet (storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultTipConfiguration;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/tipconfig'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling tipConfigGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultTipConfiguration;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultTipConfiguration");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param storeId 
     * @param updateConfig 
     * @param {*} [options] Override http request options.
     */
    public tipConfigUpsert (storeId: number, updateConfig: UpdateTipConfiguration, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultTipConfiguration;  }> {
        const localVarPath = this.basePath + '/api/v1.0/stores/{storeId}/tipconfig'
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling tipConfigUpsert.');
        }

        // verify required parameter 'updateConfig' is not null or undefined
        if (updateConfig === null || updateConfig === undefined) {
            throw new Error('Required parameter updateConfig was null or undefined when calling tipConfigUpsert.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateConfig, "UpdateTipConfiguration")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultTipConfiguration;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultTipConfiguration");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UsersApiApiKeys {
}

export class UsersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UsersApiApiKeys, value: string) {
        (this.authentications as any)[UsersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param userId 
     * @param storeId 
     * @param {*} [options] Override http request options.
     */
    public getPreviousOrderCountForStore (userId: number, storeId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/users/{userId}/previousordercount/{storeId}'
            .replace('{' + 'userId' + '}', encodeURIComponent(String(userId)))
            .replace('{' + 'storeId' + '}', encodeURIComponent(String(storeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getPreviousOrderCountForStore.');
        }

        // verify required parameter 'storeId' is not null or undefined
        if (storeId === null || storeId === undefined) {
            throw new Error('Required parameter storeId was null or undefined when calling getPreviousOrderCountForStore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public getRoles (options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringArrayResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/users/roles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringArrayResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringArrayResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum VouchersApiApiKeys {
}

export class VouchersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: VouchersApiApiKeys, value: string) {
        (this.authentications as any)[VouchersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param voucher 
     * @param {*} [options] Override http request options.
     */
    public createVoucher (appId: string, voucher: CreateVoucher, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultVoucherWithStats;  }> {
        const localVarPath = this.basePath + '/api/v1.0/vouchers/{appId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createVoucher.');
        }

        // verify required parameter 'voucher' is not null or undefined
        if (voucher === null || voucher === undefined) {
            throw new Error('Required parameter voucher was null or undefined when calling createVoucher.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(voucher, "CreateVoucher")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultVoucherWithStats;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultVoucherWithStats");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param voucherId 
     * @param {*} [options] Override http request options.
     */
    public getVoucherById (voucherId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultVoucherWithStats;  }> {
        const localVarPath = this.basePath + '/api/v1.0/vouchers/{voucherId}'
            .replace('{' + 'voucherId' + '}', encodeURIComponent(String(voucherId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'voucherId' is not null or undefined
        if (voucherId === null || voucherId === undefined) {
            throw new Error('Required parameter voucherId was null or undefined when calling getVoucherById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultVoucherWithStats;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultVoucherWithStats");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param voucherId 
     * @param aggregateDataBy 
     * @param dataPointLimit 
     * @param {*} [options] Override http request options.
     */
    public getVoucherStatsById (voucherId: number, aggregateDataBy: 'Daily' | 'Weekly' | 'Monthly', dataPointLimit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiArrayResultVoucherDataPoint;  }> {
        const localVarPath = this.basePath + '/api/v1.0/vouchers/stats/{voucherId}'
            .replace('{' + 'voucherId' + '}', encodeURIComponent(String(voucherId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'voucherId' is not null or undefined
        if (voucherId === null || voucherId === undefined) {
            throw new Error('Required parameter voucherId was null or undefined when calling getVoucherStatsById.');
        }

        // verify required parameter 'aggregateDataBy' is not null or undefined
        if (aggregateDataBy === null || aggregateDataBy === undefined) {
            throw new Error('Required parameter aggregateDataBy was null or undefined when calling getVoucherStatsById.');
        }

        if (aggregateDataBy !== undefined) {
            localVarQueryParameters['aggregateDataBy'] = ObjectSerializer.serialize(aggregateDataBy, "'Daily' | 'Weekly' | 'Monthly'");
        }

        if (dataPointLimit !== undefined) {
            localVarQueryParameters['dataPointLimit'] = ObjectSerializer.serialize(dataPointLimit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiArrayResultVoucherDataPoint;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiArrayResultVoucherDataPoint");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param voucherId 
     * @param {*} [options] Override http request options.
     */
    public getVoucherValidityPeriods (appId: string, voucherId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/vouchers/{voucherId}/validity-periods'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'voucherId' + '}', encodeURIComponent(String(voucherId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getVoucherValidityPeriods.');
        }

        // verify required parameter 'voucherId' is not null or undefined
        if (voucherId === null || voucherId === undefined) {
            throw new Error('Required parameter voucherId was null or undefined when calling getVoucherValidityPeriods.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param pageIndex 
     * @param pageSize 
     * @param searchCodes 
     * @param statusSearch 
     * @param typeSearch 
     * @param subTypeSearch 
     * @param storeIds 
     * @param channelRestrictions 
     * @param {*} [options] Override http request options.
     */
    public getVouchers (appId: string, pageIndex?: number, pageSize?: number, searchCodes?: Array<string>, statusSearch?: Array<'Valid' | 'NotYetValid' | 'Expired' | 'Used' | 'Disabled'>, typeSearch?: Array<'PercentageDiscount' | 'LumpDiscount' | 'AddItem' | 'CreditNote' | 'FreeDelivery'>, subTypeSearch?: Array<'None' | 'SignUp' | 'Loyalty' | 'Loyalty25' | 'Retention' | 'SecondaryRetention' | 'Custom'>, storeIds?: Array<number>, channelRestrictions?: Array<'Ios' | 'Android' | 'Web' | 'Kiosk' | 'Pos' | 'Google'>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultVoucherSummary;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/vouchers/summaries'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getVouchers.');
        }

        if (pageIndex !== undefined) {
            localVarQueryParameters['pageIndex'] = ObjectSerializer.serialize(pageIndex, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (searchCodes !== undefined) {
            localVarQueryParameters['searchCodes'] = ObjectSerializer.serialize(searchCodes, "Array<string>");
        }

        if (statusSearch !== undefined) {
            localVarQueryParameters['statusSearch'] = ObjectSerializer.serialize(statusSearch, "Array<'Valid' | 'NotYetValid' | 'Expired' | 'Used' | 'Disabled'>");
        }

        if (typeSearch !== undefined) {
            localVarQueryParameters['typeSearch'] = ObjectSerializer.serialize(typeSearch, "Array<'PercentageDiscount' | 'LumpDiscount' | 'AddItem' | 'CreditNote' | 'FreeDelivery'>");
        }

        if (subTypeSearch !== undefined) {
            localVarQueryParameters['subTypeSearch'] = ObjectSerializer.serialize(subTypeSearch, "Array<'None' | 'SignUp' | 'Loyalty' | 'Loyalty25' | 'Retention' | 'SecondaryRetention' | 'Custom'>");
        }

        if (storeIds !== undefined) {
            localVarQueryParameters['storeIds'] = ObjectSerializer.serialize(storeIds, "Array<number>");
        }

        if (channelRestrictions !== undefined) {
            localVarQueryParameters['channelRestrictions'] = ObjectSerializer.serialize(channelRestrictions, "Array<'Ios' | 'Android' | 'Web' | 'Kiosk' | 'Pos' | 'Google'>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultVoucherSummary;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultVoucherSummary");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param voucherId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public setVoucherValidityPeriodsSimplified (appId: string, voucherId: number, request: SetVoucherValidityPeriodsSimplifiedRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/vouchers/{voucherId}/validity-periods-simplified'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'voucherId' + '}', encodeURIComponent(String(voucherId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling setVoucherValidityPeriodsSimplified.');
        }

        // verify required parameter 'voucherId' is not null or undefined
        if (voucherId === null || voucherId === undefined) {
            throw new Error('Required parameter voucherId was null or undefined when calling setVoucherValidityPeriodsSimplified.');
        }

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling setVoucherValidityPeriodsSimplified.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "SetVoucherValidityPeriodsSimplifiedRequest")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param voucherId 
     * @param voucher 
     * @param storeId 
     * @param percentValue 
     * @param lumpValue 
     * @param maxDiscountAmount 
     * @param {*} [options] Override http request options.
     */
    public updateVoucher (voucherId: number, voucher: UpdateVoucher, storeId?: Array<number>, percentValue?: number, lumpValue?: number, maxDiscountAmount?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultVoucherWithStats;  }> {
        const localVarPath = this.basePath + '/api/v1.0/vouchers/{voucherId}'
            .replace('{' + 'voucherId' + '}', encodeURIComponent(String(voucherId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'voucherId' is not null or undefined
        if (voucherId === null || voucherId === undefined) {
            throw new Error('Required parameter voucherId was null or undefined when calling updateVoucher.');
        }

        // verify required parameter 'voucher' is not null or undefined
        if (voucher === null || voucher === undefined) {
            throw new Error('Required parameter voucher was null or undefined when calling updateVoucher.');
        }

        if (storeId !== undefined) {
            localVarQueryParameters['storeId'] = ObjectSerializer.serialize(storeId, "Array<number>");
        }

        if (percentValue !== undefined) {
            localVarQueryParameters['percentValue'] = ObjectSerializer.serialize(percentValue, "number");
        }

        if (lumpValue !== undefined) {
            localVarQueryParameters['lumpValue'] = ObjectSerializer.serialize(lumpValue, "number");
        }

        if (maxDiscountAmount !== undefined) {
            localVarQueryParameters['maxDiscountAmount'] = ObjectSerializer.serialize(maxDiscountAmount, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(voucher, "UpdateVoucher")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultVoucherWithStats;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultVoucherWithStats");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param voucherId 
     * @param voucherUsage 
     * @param {*} [options] Override http request options.
     */
    public updateVoucherUsage (appId: string, voucherId: number, voucherUsage: UpdateVoucherUsage, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/vouchers/{voucherId}/usage'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'voucherId' + '}', encodeURIComponent(String(voucherId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateVoucherUsage.');
        }

        // verify required parameter 'voucherId' is not null or undefined
        if (voucherId === null || voucherId === undefined) {
            throw new Error('Required parameter voucherId was null or undefined when calling updateVoucherUsage.');
        }

        // verify required parameter 'voucherUsage' is not null or undefined
        if (voucherUsage === null || voucherUsage === undefined) {
            throw new Error('Required parameter voucherUsage was null or undefined when calling updateVoucherUsage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(voucherUsage, "UpdateVoucherUsage")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum WebhooksApiApiKeys {
}

export class WebhooksApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: WebhooksApiApiKeys, value: string) {
        (this.authentications as any)[WebhooksApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param oauthAppId 
     * @param webhookSubscription 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public createWebhookSubscription (oauthAppId: string, webhookSubscription: WebhookSubscription, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiIntegerResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling createWebhookSubscription.');
        }

        // verify required parameter 'webhookSubscription' is not null or undefined
        if (webhookSubscription === null || webhookSubscription === undefined) {
            throw new Error('Required parameter webhookSubscription was null or undefined when calling createWebhookSubscription.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createWebhookSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(webhookSubscription, "WebhookSubscription")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiIntegerResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiIntegerResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param oauthAppId 
     * @param webhookSubscriptionId 
     * @param eventName 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public createWebhookSubscriptionEventNames (oauthAppId: string, webhookSubscriptionId: number, eventName: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}/events/{eventName}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)))
            .replace('{' + 'eventName' + '}', encodeURIComponent(String(eventName)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling createWebhookSubscriptionEventNames.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling createWebhookSubscriptionEventNames.');
        }

        // verify required parameter 'eventName' is not null or undefined
        if (eventName === null || eventName === undefined) {
            throw new Error('Required parameter eventName was null or undefined when calling createWebhookSubscriptionEventNames.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling createWebhookSubscriptionEventNames.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param oauthAppId 
     * @param webhookSubscriptionId 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public deleteWebhookSubscription (oauthAppId: string, webhookSubscriptionId: number, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling deleteWebhookSubscription.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling deleteWebhookSubscription.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteWebhookSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param oauthAppId 
     * @param webhookSubscriptionId 
     * @param eventName 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public deleteWebhookSubscriptionEventName (oauthAppId: string, webhookSubscriptionId: number, eventName: string, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}/events/{eventName}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)))
            .replace('{' + 'eventName' + '}', encodeURIComponent(String(eventName)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling deleteWebhookSubscriptionEventName.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling deleteWebhookSubscriptionEventName.');
        }

        // verify required parameter 'eventName' is not null or undefined
        if (eventName === null || eventName === undefined) {
            throw new Error('Required parameter eventName was null or undefined when calling deleteWebhookSubscriptionEventName.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteWebhookSubscriptionEventName.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getWebhookEventNames (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringArrayResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/events'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getWebhookEventNames.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringArrayResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringArrayResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param oauthAppId 
     * @param webhookSubscriptionId 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getWebhookEventNamesBySubscriptionId (oauthAppId: string, webhookSubscriptionId: number, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiStringArrayResult;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}/events'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getWebhookEventNamesBySubscriptionId.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling getWebhookEventNamesBySubscriptionId.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getWebhookEventNamesBySubscriptionId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiStringArrayResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiStringArrayResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param eventName 
     * @param appId 
     * @param oauthAppId 
     * @param webhookSubscriptionId 
     * @param version 
     * @param {*} [options] Override http request options.
     */
    public getWebhookEventSample (eventName: string, appId: string, oauthAppId: string, webhookSubscriptionId: string, version?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: WebhookEventSample;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}/events/{eventName}/test'
            .replace('{' + 'eventName' + '}', encodeURIComponent(String(eventName)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'eventName' is not null or undefined
        if (eventName === null || eventName === undefined) {
            throw new Error('Required parameter eventName was null or undefined when calling getWebhookEventSample.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getWebhookEventSample.');
        }

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getWebhookEventSample.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling getWebhookEventSample.');
        }

        if (version !== undefined) {
            localVarQueryParameters['version'] = ObjectSerializer.serialize(version, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WebhookEventSample;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WebhookEventSample");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param oauthAppId 
     * @param webhookSubscriptionId 
     * @param start 
     * @param end 
     * @param appId 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getWebhookLogs (oauthAppId: string, webhookSubscriptionId: number, start: Date, end: Date, appId: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultWebhookLog;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}/logs'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getWebhookLogs.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling getWebhookLogs.');
        }

        // verify required parameter 'start' is not null or undefined
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling getWebhookLogs.');
        }

        // verify required parameter 'end' is not null or undefined
        if (end === null || end === undefined) {
            throw new Error('Required parameter end was null or undefined when calling getWebhookLogs.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getWebhookLogs.');
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultWebhookLog;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultWebhookLog");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param oauthAppId 
     * @param appId 
     * @param page 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getWebhookSubscriptions (oauthAppId: string, appId: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultWebhookSubscription;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling getWebhookSubscriptions.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getWebhookSubscriptions.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiPaginationResultWebhookSubscription;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiPaginationResultWebhookSubscription");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param oauthAppId 
     * @param webhookSubscriptionId 
     * @param webhookSubscription 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public updateWebhookSubscription (oauthAppId: string, webhookSubscriptionId: number, webhookSubscription: WebhookSubscription, appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/webhooks/{oauthAppId}/subscriptions/{webhookSubscriptionId}'
            .replace('{' + 'oauthAppId' + '}', encodeURIComponent(String(oauthAppId)))
            .replace('{' + 'webhookSubscriptionId' + '}', encodeURIComponent(String(webhookSubscriptionId)))
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oauthAppId' is not null or undefined
        if (oauthAppId === null || oauthAppId === undefined) {
            throw new Error('Required parameter oauthAppId was null or undefined when calling updateWebhookSubscription.');
        }

        // verify required parameter 'webhookSubscriptionId' is not null or undefined
        if (webhookSubscriptionId === null || webhookSubscriptionId === undefined) {
            throw new Error('Required parameter webhookSubscriptionId was null or undefined when calling updateWebhookSubscription.');
        }

        // verify required parameter 'webhookSubscription' is not null or undefined
        if (webhookSubscription === null || webhookSubscription === undefined) {
            throw new Error('Required parameter webhookSubscription was null or undefined when calling updateWebhookSubscription.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling updateWebhookSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(webhookSubscription, "WebhookSubscription")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum WebsiteApiApiKeys {
}

export class WebsiteApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: WebsiteApiApiKeys, value: string) {
        (this.authentications as any)[WebsiteApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }
    /**
     * 
     * @param appId 
     * @param testimonial 
     * @param {*} [options] Override http request options.
     */
    public addTestimonial (appId: string, testimonial: WebsiteTestimonialBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultWebsiteTestimonial;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/testimonial'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling addTestimonial.');
        }

        // verify required parameter 'testimonial' is not null or undefined
        if (testimonial === null || testimonial === undefined) {
            throw new Error('Required parameter testimonial was null or undefined when calling addTestimonial.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(testimonial, "WebsiteTestimonialBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultWebsiteTestimonial;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultWebsiteTestimonial");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param testimonialId 
     * @param {*} [options] Override http request options.
     */
    public deleteTestimonial (appId: string, testimonialId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/testimonial/{testimonialId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'testimonialId' + '}', encodeURIComponent(String(testimonialId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteTestimonial.');
        }

        // verify required parameter 'testimonialId' is not null or undefined
        if (testimonialId === null || testimonialId === undefined) {
            throw new Error('Required parameter testimonialId was null or undefined when calling deleteTestimonial.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param imageId 
     * @param {*} [options] Override http request options.
     */
    public deleteWebsiteImage (appId: string, imageId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/image/{imageId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'imageId' + '}', encodeURIComponent(String(imageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling deleteWebsiteImage.');
        }

        // verify required parameter 'imageId' is not null or undefined
        if (imageId === null || imageId === undefined) {
            throw new Error('Required parameter imageId was null or undefined when calling deleteWebsiteImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param testimonialId 
     * @param testimonial 
     * @param {*} [options] Override http request options.
     */
    public editTestimonial (appId: string, testimonialId: number, testimonial: WebsiteTestimonialBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultWebsiteTestimonial;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/testimonial/{testimonialId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'testimonialId' + '}', encodeURIComponent(String(testimonialId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling editTestimonial.');
        }

        // verify required parameter 'testimonialId' is not null or undefined
        if (testimonialId === null || testimonialId === undefined) {
            throw new Error('Required parameter testimonialId was null or undefined when calling editTestimonial.');
        }

        // verify required parameter 'testimonial' is not null or undefined
        if (testimonial === null || testimonial === undefined) {
            throw new Error('Required parameter testimonial was null or undefined when calling editTestimonial.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(testimonial, "WebsiteTestimonialBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultWebsiteTestimonial;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultWebsiteTestimonial");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public getIndexConfiguration (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultIndexPage;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/index'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getIndexConfiguration.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultIndexPage;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultIndexPage");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param indexPage 
     * @param {*} [options] Override http request options.
     */
    public setIndexConfiguration (appId: string, indexPage: IndexPageBase, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultIndexPageBase;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/index'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling setIndexConfiguration.');
        }

        // verify required parameter 'indexPage' is not null or undefined
        if (indexPage === null || indexPage === undefined) {
            throw new Error('Required parameter indexPage was null or undefined when calling setIndexConfiguration.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(indexPage, "IndexPageBase")
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultIndexPageBase;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultIndexPageBase");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param imageLocation 
     * @param Image App Logo
     * @param {*} [options] Override http request options.
     */
    public uploadWebsiteImage (appId: string, imageLocation: 'IndexHeader' | 'IndexAboutSectionLeft' | 'IndexAboutSectionRight' | 'IndexGallery' | 'IndexOpeningHoursHeader' | 'IndexTestimonialsHeader', Image: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RestApiResultWebsiteImage;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/image/{imageLocation}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)))
            .replace('{' + 'imageLocation' + '}', encodeURIComponent(String(imageLocation)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling uploadWebsiteImage.');
        }

        // verify required parameter 'imageLocation' is not null or undefined
        if (imageLocation === null || imageLocation === undefined) {
            throw new Error('Required parameter imageLocation was null or undefined when calling uploadWebsiteImage.');
        }

        // verify required parameter 'Image' is not null or undefined
        if (Image === null || Image === undefined) {
            throw new Error('Required parameter Image was null or undefined when calling uploadWebsiteImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (Image !== undefined) {
            localVarFormParams['Image'] = Image;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RestApiResultWebsiteImage;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RestApiResultWebsiteImage");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appId 
     * @param {*} [options] Override http request options.
     */
    public websiteCheckNow (appId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1.0/{appId}/website/dnscheck'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling websiteCheckNow.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.oauth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
